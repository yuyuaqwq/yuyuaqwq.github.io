{
    "version": "https://jsonfeed.org/version/1",
    "title": "鹿鹿鱼鱼 • All posts by \"编译原理\" tag",
    "description": "人为什么要起床？",
    "home_page_url": "http://yuyuaqwq.github.io",
    "items": [
        {
            "id": "http://yuyuaqwq.github.io/posts/56ac.html",
            "url": "http://yuyuaqwq.github.io/posts/56ac.html",
            "title": "【动手写ToyLang】1.从四则运算表达式开始",
            "date_published": "2022-10-28T15:01:12.000Z",
            "content_html": "<h1 id=\"编译原理\"><a class=\"markdownIt-Anchor\" href=\"#编译原理\">#</a> 编译原理</h1>\n<p>如果你曾经接触过《编译原理》的话，不知道是否与我有着同样的困惑呢？</p>\n<p>各种不近人情的名词，公式乱飞，这让我学习起来格外痛苦。</p>\n<p>我在尝试阅读过不少文章、书籍，动手之后，才逐渐理解了一些比较关键的东西。</p>\n<p><em>实际上，当我真正自己动手完成了对四则运算表达式的解析的那一刻，我才真切感受到了编译原理的优雅与美妙之处，这也是由无数人智慧造就的伟大吧 (偏得有点远了)。</em></p>\n<hr>\n<h1 id=\"初尝构思\"><a class=\"markdownIt-Anchor\" href=\"#初尝构思\">#</a> 初尝构思</h1>\n<p><strong>现在，我来尝试给你出一道题吧，请你用你所熟悉的语言，编写一个模块：</strong></p>\n<ol>\n<li>\n<p>输入符合四则运算表达式规范的字符串 (可以假定只有整数，不存在括号)；</p>\n</li>\n<li>\n<p>输出整型结果；</p>\n</li>\n<li>\n<p>要求关键逻辑由自己实现，不可借由库、语言本身提供的功能。</p>\n</li>\n</ol>\n<p>你能实现吗？</p>\n<p>是否觉得脑子有些空白，难以组织成较为优雅的实现思路呢？</p>\n<pre><code>如果你现在就能想到很棒的解法，那至少你要比我厉害多了。\n</code></pre>\n<p>我曾经因为某些需求做过尝试，虽然最后写出来了，但是具体实现也非常丑陋，这里就不献丑了。</p>\n<p>但是我可以给你大致描述一下我当初的思路：</p>\n<ul>\n<li>\n<p>首先，查找字符串中优先级较高的运算符  <code>*</code>   <code>/</code> ，再前 / 后瞻运算符前后的数字，这个子串也能形成一个表达式；</p>\n</li>\n<li>\n<p>算出结果后，在原表达式中，用结果替换掉子串 (刚刚被计算的表达式)，再继续查找。</p>\n</li>\n<li>\n<p>完成后再从头开始查找优先级更低一级的运算符 <code>+</code>   <code>-</code> ，直到运算完成。</p>\n</li>\n</ul>\n<p><strong>当然，我们不会用这么低效的方法，也不会要求你真的写出来。</strong></p>\n<p><strong>现在提出来，也不是为了为难你，只是为了让你记住眼下的感觉，当你学完本系列文章后，再回来看看，这一道题，是否真的有那么难呢？</strong></p>\n<hr>\n<h1 id=\"抽象语法树\"><a class=\"markdownIt-Anchor\" href=\"#抽象语法树\">#</a> 抽象语法树</h1>\n<blockquote>\n<p>在计算机科学中，抽象语法树（Abstract Syntax Tree，AST），或简称<a href=\"https://baike.baidu.com/item/%E8%AF%AD%E6%B3%95%E6%A0%91/7031301?fromModule=lemma_inlink\">语法树</a>（Syntax tree），是<a href=\"https://baike.baidu.com/item/%E6%BA%90%E4%BB%A3%E7%A0%81?fromModule=lemma_inlink\">源代码</a><a href=\"https://baike.baidu.com/item/%E8%AF%AD%E6%B3%95?fromModule=lemma_inlink\">语法</a>结构的一种抽象表示。它以树状的形式表现<a href=\"https://baike.baidu.com/item/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80?fromModule=lemma_inlink\">编程语言</a>的语法结构，树上的每个节点都表示源代码中的一种结构。---- 摘自百度百科</p>\n</blockquote>\n<p>嗯… 不愧是名字就带着抽象的东西，连说明都这么抽象。</p>\n<p>咱们先不整那么多虚头巴脑的，干就完了。</p>\n<h2 id=\"构造四则运算表达式的ast\"><a class=\"markdownIt-Anchor\" href=\"#构造四则运算表达式的ast\">#</a> 构造四则运算表达式的 AST</h2>\n<p><code>3 + 2</code></p>\n<p>这个是大家熟悉的算术表达式，实际上，我们人脑是如何计算这个表达式的呢？当然需要遵循某些规则：</p>\n<ol>\n<li>\n<p>先乘除</p>\n</li>\n<li>\n<p>再加减</p>\n</li>\n<li>\n<p>从左往右结合</p>\n</li>\n</ol>\n<p>那我们自然是需要先在表达式中找到 <code>*</code> 、 <code>/</code>  两种符号，好消息是，没有，嘿嘿。</p>\n<p>接下来继续左往右找 <code>+</code> 、 <code>-</code> ，找到之后将其取出，这也是我们需要计算的子表达式。</p>\n<p>我们将其分成三部分，分别是：</p>\n<ul>\n<li>左边的数字  <code>3</code></li>\n<li>加法运算符  <code>+</code></li>\n<li>右边的数字  <code>2</code></li>\n</ul>\n<p>可以得到这么一棵树型结构：</p>\n<ul>\n<li>\n<img src=\"/posts/56ac/1.png\" class=\"\" title=\"这是一张图片\">\n</li>\n</ul>\n<p>接下来我们遍历这棵树：</p>\n<ol>\n<li>根节点，是加法，表明要对两个子节点进行加法；</li>\n<li>将左子节点与右子节点相加；</li>\n<li><code>3 + 2</code> ，返回结果  <code>5</code> ；</li>\n<li>遍历结束；</li>\n</ol>\n<ul>\n<li>\n<img src=\"/posts/56ac/2.png\" class=\"\" title=\"这是一张图片\">\n</li>\n</ul>\n<h3 id=\"多运算符与结合律\"><a class=\"markdownIt-Anchor\" href=\"#多运算符与结合律\">#</a> 多运算符与结合律</h3>\n<p>那么，当一个表达式中，存在多个运算符时，应该如何构造语法树呢？</p>\n<p>接下来我们构造表达式  <code>3 - 2 + 4</code>  的树。</p>\n<p><strong>首先我们应该注意的一点是，需要先被执行运算 (优先级更高) 的子表达式，其节点相对的，要在更底下：</strong></p>\n<ul>\n<li>\n<img src=\"/posts/56ac/3.png\" class=\"\" title=\"这是一张图片\">\n</li>\n</ul>\n<p>还是先来遍历这颗树：</p>\n<ol>\n<li>根节点，是减法，表明要对两个子节点进行减法，用左子节点减去右子节点；\n<ol>\n<li>左子节点是加法，表明要对两个子节点进行加法，将左子节点与右子节点相加，需要继续向下展开；</li>\n<li><code>3 - 2</code> ，返回结果  <code>1</code> ；</li>\n</ol>\n</li>\n<li><code>1 + 4</code> ，返回结果  <code>5</code> ；</li>\n<li>遍历结束；</li>\n</ol>\n<p><strong>因此，遍历的过程也符合我们所要求的 <code>左结合律</code> 。</strong></p>\n<ul>\n<li>因为同优先级下，我们更优先计算左边的运算符组成的子表达式，</li>\n</ul>\n<p>接下来我再给你画一下另一种情况，你大概也就明白了。</p>\n<ul>\n<li>\n<img src=\"/posts/56ac/4.png\" class=\"\" title=\"这是一张图片\">\n</li>\n</ul>\n<p>你可以尝试一下遍历这棵树，会发现先被执行的一定是减法，这并不符合我们的从一开始就要求的 <code>左结合律</code> 。<br>\n在部分情况下，由于结合律的错误，就会产出错误的结果：</p>\n<ul>\n<li>如我们本次求解的表达式，通过遍历此树得出的结果为 <code>-3</code> 。</li>\n</ul>\n<h2 id=\"目标根据语法规则生成ast\"><a class=\"markdownIt-Anchor\" href=\"#目标根据语法规则生成ast\">#</a> 目标：根据语法规则生成 AST</h2>\n<p>我不说你大概也已经猜到了，其实我们上面所构造的树，在当前应用场景下，就叫做 <code>抽象语法树</code> 。</p>\n<p><em><strong>并且遍历树并计算的过程，与我们人脑对表达式的计算的过程是十分相似的。</strong></em></p>\n<p><strong>也就是说，我们只需要构造出这么一颗抽象语法树，就已经基本上完成了编译工作的一大半甚至全部。</strong><br>\n<strong>此时，若我们需要执行编译产生的结果，只需要遍历我们所生成 AST 即可。</strong></p>\n<p>如下图：</p>\n<ul>\n<li>\n<img src=\"/posts/56ac/5.png\" class=\"\" title=\"这是一张图片\">\n</li>\n</ul>\n<p>在遍历的过程中，我们就能够完成对表达式加法运算，赋值表达式赋值运算。</p>\n<hr>\n<h1 id=\"ast解释器\"><a class=\"markdownIt-Anchor\" href=\"#ast解释器\">#</a> AST 解释器</h1>\n<p>最后，我们也确实展示了有关 &quot;解释器&quot; 的东西，是的，即便你难以置信。<br>\n但是遍历这棵树的过程，可以叫做解释，完整一点就是我们所编写的 <code>AST解释器</code> 。</p>\n<p>当然，解释器是一种比较广泛的概念，即便到后面我们基于 AST 生成了字节码，交给虚拟机执行，我们的程序也依然可以称之为解释器，只不过解释的对象从 AST 换成了字节码。</p>\n<p>我个人觉得，当初造这个词的人只是为了区分所谓的 &quot;编译型语言&quot; 和 &quot;解释型语言&quot;。<br>\n以下是百度百科对解释器的定义：</p>\n<blockquote>\n<p>解释器（<a href=\"https://baike.baidu.com/item/%E8%8B%B1%E8%AF%AD/109997?fromModule=lemma_inlink\">英语</a>：Interpreter），又译为直译器，是一种电脑程序，能够把高级<a href=\"https://baike.baidu.com/item/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80?fromModule=lemma_inlink\">编程语言</a>一行一行直接转译运行。解释器不会一次把整个程序转译出来，只像一位 “中间人”，每次运行程序时都要先转成另一种语言再作运行，因此解释器的程序运行速度比较缓慢。它每转译一行程序叙述就立刻运行，然后再转译下一行，再运行，如此不停地进行下去。</p>\n</blockquote>\n<ul>\n<li><em>此处关于 <code>每转译一行程序叙述就立刻运行</code> 的说明也不尽然，至少现在很多被称为 <code>解释器</code> 的程序，并非如此 (如 Python 解释器、Java 解释器等)。</em></li>\n</ul>\n",
            "tags": [
                "编译原理",
                "动手写ToyLang"
            ]
        },
        {
            "id": "http://yuyuaqwq.github.io/posts/c4d3.html",
            "url": "http://yuyuaqwq.github.io/posts/c4d3.html",
            "title": "【动手写ToyLang】0.前言",
            "date_published": "2022-10-28T13:18:53.000Z",
            "content_html": "<h1 id=\"关于\"><a class=\"markdownIt-Anchor\" href=\"#关于\">#</a> 关于</h1>\n<p><strong>本系列文章会手把手教你打造一门在别人看来是<emp>玩具</emp>的通用计算机语言，事实也确实如此。</strong></p>\n<p>但计算机本身就是一门需要动手的学科，在对基本原理有一定程度的理解之后，自己动手实践才是学习的最好的捷径，为此制造 &quot;玩具&quot;，并不丢人。</p>\n<p>笔者对《编译原理》这门学科的学习程度也十分有限，因此本系列文章的读者不仅仅是你们，也包括我，写下的这篇文章也是支撑我继续动手实践的动力。</p>\n<p><em>我会尽可能的查阅资料、学习，以保证输出内容的可靠性，如果还是难以避免的出现了错误，望批评指正，感激不尽。</em></p>\n<hr>\n<h1 id=\"准备工作\"><a class=\"markdownIt-Anchor\" href=\"#准备工作\">#</a> 准备工作</h1>\n<h2 id=\"开发语言\"><a class=\"markdownIt-Anchor\" href=\"#开发语言\">#</a> 开发语言</h2>\n<p>这里我选用我个人较为常用的 C++ 作为开发语言，风格尽量以《Google C++ Style Guide》为准，在我个人能力范围内尽量写得 &quot;现代 C++&quot; 一点。</p>\n<p>当然，我个人也还是 C++ 彩笔，代码写得不好，还请理解。</p>\n<h2 id=\"开发环境\"><a class=\"markdownIt-Anchor\" href=\"#开发环境\">#</a> 开发环境</h2>\n<p>我基本上只在 Windows 上工作，因此选择自然是 <code>Visual Studio</code> 。</p>\n",
            "tags": [
                "编译原理",
                "动手写ToyLang"
            ]
        }
    ]
}