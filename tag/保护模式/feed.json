{
    "version": "https://jsonfeed.org/version/1",
    "title": "鹿鹿鱼鱼 • All posts by \"保护模式\" tag",
    "description": "人为什么要起床？",
    "home_page_url": "http://yuyuaqwq.github.io",
    "items": [
        {
            "id": "http://yuyuaqwq.github.io/posts/41fe.html",
            "url": "http://yuyuaqwq.github.io/posts/41fe.html",
            "title": "【Windows内核】x64下定位随机页表基址的思路",
            "date_published": "2022-12-02T08:21:05.000Z",
            "content_html": "<h1 id=\"前言\"><a class=\"markdownIt-Anchor\" href=\"#前言\">#</a> 前言</h1>\n<p><em>昨天在看周哥讲 x64 内核的时候，得知了 windows10 的某个版本开始，页表基址不再固定了。</em><br>\n<em>今天晚上突然有了个思路，就动手把他敲出来了，这种思路是不是已经烂大街了我也不确定，就当发出来学习交流吧。</em></p>\n<h1 id=\"随机页表基址原理\"><a class=\"markdownIt-Anchor\" href=\"#随机页表基址原理\">#</a> 随机页表基址原理</h1>\n<p>这里用 x86 的 10-10-12 分页举例吧，比较好理解，理解了 x64 的也差不多的</p>\n<p>启用了保护模式和分页机制后，咱就不能直接访问物理地址了，都会被 MMU 当作虚拟地址进行转换。</p>\n<p>但是 cr3 存的又是物理地址，不能直接操作页表了，那咋办呢？</p>\n<p>聪明的前辈们，选择在页目录表中选择一项 (共 1024 项，每一项 4 字节)，使其存储的物理地址与页目录表的基址 (cr3) 相同，这样子就可以构造一个访问页表的虚拟地址了，大概就是<strong>让 cpu 在地址转换的过程中绕圈圈</strong>。</p>\n<ul>\n<li>画个图吧</li>\n<li>\n<img src=\"/posts/41fe/1.png\" class=\"\" title=\"这是一张图片\">\n</li>\n</ul>\n<h2 id=\"定位思路\"><a class=\"markdownIt-Anchor\" href=\"#定位思路\">#</a> 定位思路</h2>\n<ul>\n<li>x64 也必然是随机选择 PXT 的其中一项 PXE 来存储 PXT 的物理地址，实现的随机页表基址</li>\n<li>那么就可以通过<strong>构造所有可能指向 PXT 的虚拟地址 (共 512 项)</strong>，转换为物理地址，再与 cr3 比较，最终得到正确的 PXT 基址。</li>\n<li>只要知道了存储 PXT 的物理地址的 PXE 的 PXI，构造 PPT/PDT/PTT 基址都很简单了</li>\n</ul>\n<h1 id=\"实现\"><a class=\"markdownIt-Anchor\" href=\"#实现\">#</a> 实现</h1>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">PVOID <span class=\"title\">GetPXTBase</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tUINT64 cr3 = __readcr3();</span><br><span class=\"line\">\t<span class=\"built_in\">KdPrint</span>((<span class=\"string\">&quot;yuyu:cr3:%p\\n&quot;</span>, cr3));</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (UINT64 i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">512</span>; i++) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 通过PXI构造虚拟地址</span></span><br><span class=\"line\">\t\tPVOID pxtBase = (PVOID)(<span class=\"number\">0xffff000000000000</span> | (i &lt;&lt; <span class=\"number\">12</span>) | (i &lt;&lt; <span class=\"number\">21</span>) | (i &lt;&lt; <span class=\"number\">30</span>) | (i &lt;&lt; <span class=\"number\">39</span>));</span><br><span class=\"line\">\t\tPHYSICAL_ADDRESS physical = <span class=\"built_in\">MmGetPhysicalAddress</span>(pxtBase);</span><br><span class=\"line\">\t\t<span class=\"built_in\">KdPrint</span>((<span class=\"string\">&quot;yuyu:i:%d 物理:%p 虚拟:%p\\n&quot;</span>, i, physical.QuadPart, pxtBase));</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (cr3 == physical.QuadPart) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> pxtBase;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>\n<img src=\"/posts/41fe/2.png\" class=\"\" title=\"这是一张图片\">\n</li>\n</ul>\n<h1 id=\"结尾\"><a class=\"markdownIt-Anchor\" href=\"#结尾\">#</a> 结尾</h1>\n<p>理解有限，如有错误，还请指正</p>\n<h1 id=\"2022514补充\"><a class=\"markdownIt-Anchor\" href=\"#2022514补充\">#</a> 2022/5/14 补充</h1>\n<ul>\n<li>其实除开这个之外，我先想到的是另一个思路，即<strong>构造所有可能存储 PXT 的物理地址的 PXE 的虚拟地址</strong>。\n<ul>\n<li>依旧是 512 项，探测地址是否可访问，读取 8 字节；</li>\n<li>将其当作 PXE，取出物理页面基址，再与 cr3 进行比较。</li>\n</ul>\n</li>\n<li>但是这种方法有概率出现问题，即存放的数据可能正好与 cr3 相同，但所在页面并不是 PXT。\n<ul>\n<li>因此我就没有写出来，不过我想了一下，还是贴出来了，也算是一种思路嘛。</li>\n</ul>\n</li>\n</ul>\n",
            "tags": [
                "保护模式",
                "Windows内核"
            ]
        }
    ]
}