<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://yuyuaqwq.github.io</id>
    <title>鹿鹿鱼鱼 • Posts by &#34;windows内核&#34; tag</title>
    <link href="http://yuyuaqwq.github.io" />
    <updated>2023-02-17T14:57:07.000Z</updated>
    <category term="MFC" />
    <category term="没饭吃" />
    <category term="逆向分析" />
    <category term="工具" />
    <category term="C/C++" />
    <category term="反汇编" />
    <category term="网络分析" />
    <category term="Proxifier" />
    <category term="编译原理" />
    <category term="动手写ToyLang" />
    <category term="C++" />
    <category term="界面开发" />
    <category term="Qt" />
    <category term="保护模式" />
    <category term="Windows内核" />
    <category term="密码学" />
    <category term="PKI" />
    <category term="证书" />
    <category term="签名" />
    <category term="Git" />
    <category term="版本管理" />
    <entry>
        <id>http://yuyuaqwq.github.io/posts/f54c.html</id>
        <title>【保护模式】2.基于段的保护</title>
        <link rel="alternate" href="http://yuyuaqwq.github.io/posts/f54c.html"/>
        <content type="html">&lt;h1 id=&#34;段寄存器的扩展&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#段寄存器的扩展&#34;&gt;#&lt;/a&gt; 段寄存器的扩展&lt;/h1&gt;
&lt;p&gt;我们需要划分权限，让操作系统和应用处在不同的权限中，以保证系统安全；&lt;br&gt;
并且决定基于段机制进行延展。&lt;/p&gt;
&lt;p&gt;相较于实模式的 1MB 寻址 (2&lt;sup&gt;20)，保护模式下的寻址范围已经达到了 4GB (2&lt;/sup&gt;32)，在汇编指令上可以直接书写 4 字节的内存地址。&lt;/p&gt;
&lt;p&gt;此时，段寄存器的 16 位宽度已经显得有些相形见绌了。&lt;br&gt;
为了扩展，段寄存器在保护模式下，不再直接存放段的基址，而是存放了&lt;strong&gt;索引&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;全局描述符表-global-descriptor-table&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#全局描述符表-global-descriptor-table&#34;&gt;#&lt;/a&gt; 全局描述符表 (Global Descriptor Table)&lt;/h2&gt;
&lt;p&gt;具体是索引什么呢？&lt;br&gt;
这里引入了一张表，叫做&lt;strong&gt;全局描述符表&lt;/strong&gt;，其实就是在内存中存放的数组。&lt;br&gt;
其元素叫做&lt;strong&gt;段描述符&lt;/strong&gt;，在内存中顺序组织起来，也就是一张表。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;简称&lt;strong&gt; GDT&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;段选择子&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#段选择子&#34;&gt;#&lt;/a&gt; 段选择子&lt;/h2&gt;
&lt;p&gt;段寄存器由于有了新的用途，因此也有了新的名字，叫做&lt;strong&gt;段选择子&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;大概是意为用于选择段的寄存器吧&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;段描述符&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#段描述符&#34;&gt;#&lt;/a&gt; 段描述符&lt;/h2&gt;
&lt;p&gt;那么说回段描述符，它究竟有什么作用呢？为什么会有这么一个东西呢？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;段描述符是 GDT 或 LDT (暂时忽略) 中的元素；&lt;br&gt;
它为处理器提供诸如段基址，段大小，访问权限及状态等信息。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;先来看英特尔白皮书上对段描述符的图示
&lt;ul&gt;
&lt;li&gt;

&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;每个段描述符是 8 字节，由多个字段组成。&lt;br&gt;
我们发现，字段的排列有些混乱，基址 (Base)、界限 (Limit) 甚至需要跨几个字段组合。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;据说是英特尔为了兼容，这里也不做探究。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;字段这么多，咱们先来看最熟悉的基址字段。&lt;br&gt;
还记得 &lt;strong&gt;4. 段寄存器&lt;/strong&gt; 小节中的 &lt;strong&gt;CPU 对内存的访问&lt;/strong&gt; 那部分吗？&lt;br&gt;
&lt;strong&gt;在实模式下，cpu 访问任何在汇编指令中显式书写的地址，都会将地址视作偏移 (逻辑地址)，加上段基地址形成真正的物理地址。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在这里也不例外，只不过段寄存器并不直接存放段基址了，而是存放用于了在 GDT 中选择段描述符的索引值。&lt;/p&gt;
&lt;h2 id=&#34;访问内存&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#访问内存&#34;&gt;#&lt;/a&gt; 访问内存&lt;/h2&gt;
&lt;p&gt;至此，我们也能初步设想在保护模式下，CPU 是如何基于段访问内存的：&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;mov eax, dword ptr ds:[0x12345678]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;汇编指令中的内存地址 (偏移，&lt;strong&gt;offset&lt;/strong&gt;) 是&lt;strong&gt; 0x12345678&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;汇编指令中指定使用的段寄存器是 &lt;strong&gt;ds&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;访问 ds 段寄存器，得到&lt;strong&gt;索引 (index)&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;访问&lt;strong&gt; GDT [index]&lt;/strong&gt;，得到段描述符；&lt;/li&gt;
&lt;li&gt;解析段描述符中的&lt;strong&gt; Base&lt;/strong&gt; 字段；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ds.Base&lt;/strong&gt; + &lt;strong&gt;offset&lt;/strong&gt; = &lt;strong&gt;最终的物理地址&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;通过物理地址访问内存。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;地址分类&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#地址分类&#34;&gt;#&lt;/a&gt; 地址分类&lt;/h1&gt;
&lt;p&gt;至此我们基本了解了，保护模式下 CPU 如何基于段描述符进行寻址。&lt;br&gt;
并且在上文，我列出了 CPU 将汇编指令中书写的地址转换为物理地址的猜想。&lt;/p&gt;
&lt;p&gt;在保护模式下，实际寻址过程的各个阶段的地址也都是有命名的。&lt;br&gt;
为了向下深入学习，先了解一下还是有必要的。&lt;/p&gt;
&lt;h2 id=&#34;逻辑地址相对地址&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#逻辑地址相对地址&#34;&gt;#&lt;/a&gt; 逻辑地址 / 相对地址&lt;/h2&gt;
&lt;p&gt;百度百科的解释是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;指在计算机体系结构中是指应用程序角度看到的内存单元（memory cell）、存储单元（storage element）、网络主机（network host）的地址。 逻辑地址往往不同于物理地址（physical address），通过地址翻译器（address translator）或映射函数可以把逻辑地址转化为物理地址。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;咱们简单一点，&lt;strong&gt;还是理解成在汇编指令中显式书写的地址。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如上一节举例的汇编指令：&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;mov eax, dword ptr ds:[0x12345678]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;我们在当时把它叫做偏移 (offset)，其实它应该叫做&lt;strong&gt;逻辑地址&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在实模式下，&lt;strong&gt;逻辑地址 + 段基地址 = 物理地址&lt;/strong&gt;；&lt;br&gt;
在保护模式下， &lt;strong&gt;逻辑地址 + 段基地址 = 线性地址&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;线性地址虚拟地址&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#线性地址虚拟地址&#34;&gt;#&lt;/a&gt; 线性地址 / 虚拟地址&lt;/h2&gt;
&lt;p&gt;摘自百度百科：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;线性地址（Linear Address）是逻辑地址到物理地址变换之间的中间层。在分段部件中逻辑地址是段中的偏移地址，然后加上基地址就是线性地址。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;线性地址是在保护模式下出现的，通过&lt;strong&gt;页表&lt;/strong&gt;将&lt;strong&gt;线性地址&lt;/strong&gt;转换成&lt;strong&gt;物理地址&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;在上节举例时，我们将 &amp;quot;线性地址&amp;quot; 称为 &amp;quot;物理地址&amp;quot;；&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;线性地址到物理地址的转换涉及到分页机制，在未学习分页机制之前，请暂时将笔记中所有 &amp;quot;线性地址&amp;quot; 视作 &amp;quot;物理地址&amp;quot;。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;物理地址&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#物理地址&#34;&gt;#&lt;/a&gt; 物理地址&lt;/h2&gt;
&lt;p&gt;摘自百度百科：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在存储器里以字节为单位存储信息，为正确地存放或取得信息，每一个字节单元给以一个唯一的存储器地址，称为物理地址（Physical Address），又叫实际地址或绝对地址。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;CPU 最终通过&lt;strong&gt;物理地址&lt;/strong&gt;去访问&lt;strong&gt;真正的存储单元&lt;/strong&gt;。&lt;/p&gt;
&lt;h1 id=&#34;段描述符缓存&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#段描述符缓存&#34;&gt;#&lt;/a&gt; 段描述符缓存&lt;/h1&gt;
&lt;h2 id=&#34;gdtr&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#gdtr&#34;&gt;#&lt;/a&gt; GDTR&lt;/h2&gt;
&lt;p&gt;我们说到，既然 CPU 访问内存，需要先访问 GDT，那么 GDT 的地址又是从哪里来的呢？&lt;/p&gt;
&lt;p&gt;CPU 提供了一个 48bit、名为&lt;strong&gt; GDTR&lt;/strong&gt; 的寄存器。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;高 32bit 存放 GDT 的首地址（线性地址）；&lt;br&gt;
低 16bit 存放 GDT 的界限，即整个 GDT 表的长度。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;通过 windbg 调试 Windows XP，查看&lt;strong&gt; GDTR&lt;/strong&gt; 的内容：
&lt;ul&gt;
&lt;li&gt;

&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;关于 windbg 的使用，在内核的学习阶段是非常重要的，所学的知识都需要自己动手实验、验证；&lt;br&gt;
如果有需要的话，我会考虑再找时间写一篇关于环境配置的文章。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在 windbg 下：&lt;br&gt;
查询&lt;strong&gt; gdtr&lt;/strong&gt;，即查询 GDT 的首地址；&lt;br&gt;
查询&lt;strong&gt; gdtl&lt;/strong&gt;，即查询 GDT 的界限。&lt;/p&gt;
&lt;p&gt;CPU 每次访问&lt;strong&gt; GDT&lt;/strong&gt; 时，都是从&lt;strong&gt; GDTR&lt;/strong&gt; 中获取&lt;strong&gt;线性地址&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;而 GDTR 的值，是由操作系统在初始化阶段填入的。&lt;/p&gt;
&lt;h2 id=&#34;不可见寄存器&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#不可见寄存器&#34;&gt;#&lt;/a&gt; 不可见寄存器&lt;/h2&gt;
&lt;p&gt;解决了一个问题，当然又会出现新的问题。&lt;br&gt;
通过引入&lt;strong&gt; GDT&lt;/strong&gt;，我们解决了&lt;strong&gt;段寄存器&lt;/strong&gt;宽度太小无法满足保护模式需求的问题。&lt;/p&gt;
&lt;p&gt;但是每次访问内存，都要先查&lt;strong&gt; GDT&lt;/strong&gt;，这是不是有点浪费 CPU 的性能了？&lt;/p&gt;
&lt;p&gt;是的，内存访问对于 CPU 而言，是很慢的行为，为了避免这种性能浪费，引入了名为&lt;strong&gt;描述符缓存&lt;/strong&gt;的寄存器。&lt;br&gt;
实际上，&lt;strong&gt;描述符缓存&lt;/strong&gt;是不可见的，它在保护模式下是属于&lt;strong&gt;段寄存器&lt;/strong&gt;的一部分。&lt;/p&gt;
&lt;p&gt;保护模式下的段寄存器，就分为了&lt;strong&gt;两个部分&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;段选择子
&lt;ul&gt;
&lt;li&gt;原先的段寄存器，可见。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;描述符缓存
&lt;ul&gt;
&lt;li&gt;对段寄存器进行扩展，不可见。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;虽然它不可见，无法直接操作，但是是真实存在的。&lt;/p&gt;
&lt;h2 id=&#34;段寄存器&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#段寄存器&#34;&gt;#&lt;/a&gt; 段寄存器&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;保护模式下，将段选择子与描述符缓存部分 合称为段寄存器&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;加载段寄存器&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#加载段寄存器&#34;&gt;#&lt;/a&gt; 加载段寄存器&lt;/h3&gt;
&lt;p&gt;在&lt;strong&gt;加载段选择子&lt;/strong&gt;时，CPU 会通过我们给定的段选择子，查询 GDT，得到描述符。&lt;/p&gt;
&lt;p&gt;解析描述符，将字段填入&lt;strong&gt;描述符缓存&lt;/strong&gt;中。&lt;/p&gt;
&lt;p&gt;未来每次发生内存访问，都不会去查询 GDT，而是直接从&lt;strong&gt;描述符缓存&lt;/strong&gt;中获取字段。&lt;/p&gt;
&lt;p&gt;那么，段选择子是由谁加载的呢？为什么我们平时没有见到过相关的代码呢？&lt;br&gt;
我们可以在 windows 下打开随意 x64dbg、od 之类的调试器，拖入一个程序，就可以看到，段选择子是存在初始值的，而加载的工作是由操作系统负责的。&lt;br&gt;
我们也应该明白，所谓的&lt;strong&gt;加载段选择子&lt;/strong&gt;，实际上也是&lt;strong&gt;加载描述符缓存&lt;/strong&gt;，合称为&lt;strong&gt;加载段寄存器&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;访问内存-2&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#访问内存-2&#34;&gt;#&lt;/a&gt; 访问内存&lt;/h2&gt;
&lt;p&gt;至此，我们可以将上一节的设想进行改进：&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;mov eax, dword ptr ds:[0x12345678]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;逻辑地址&lt;/strong&gt;是&lt;strong&gt; 0x12345678&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;汇编指令中指定使用的段寄存器是 &lt;strong&gt;ds&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;从&lt;strong&gt;描述符缓存&lt;/strong&gt;中取得&lt;strong&gt; Base&lt;/strong&gt; 字段&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ds.Base&lt;/strong&gt; + &lt;strong&gt;逻辑地址&lt;/strong&gt; = &lt;strong&gt;线性地址&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;通过&lt;strong&gt;线性地址&lt;/strong&gt;访问内存。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;访问控制&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#访问控制&#34;&gt;#&lt;/a&gt; 访问控制&lt;/h1&gt;
&lt;p&gt;那么，说了这么久保护，究竟应该怎样才能做到所谓的保护呢？&lt;/p&gt;
&lt;p&gt;在第 5 节我们简单提及了权限的建立，通过为不同的段设置权限级别，以&lt;strong&gt;控制不同程序对内存的访问&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;特权级划分&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#特权级划分&#34;&gt;#&lt;/a&gt; 特权级划分&lt;/h2&gt;
&lt;p&gt;接下来咱们想一下，既然是权限，那自然是有高有低，就像身份一样，我是排长，你是士卒，那我的级别自然就比你高。&lt;/p&gt;
&lt;p&gt;接下来我们尝试用两个数字表示两种权限级别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;0
&lt;ul&gt;
&lt;li&gt;最高权限级别，表示当前的 CPU 是以&lt;strong&gt;系统&lt;/strong&gt;身份在跑的，操作系统运行在此级别下；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;3
&lt;ul&gt;
&lt;li&gt;最低权限级别，表示当前的 CPU 是以&lt;strong&gt;用户&lt;/strong&gt;身份在跑的，应用程序运行在此级别下。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;再次构思&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#再次构思&#34;&gt;#&lt;/a&gt; 再次构思&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;地址&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;程序&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;基地址 (Base)&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;访问此段需要权限 (DPL)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;0x00 ~ 0x3f&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;提供给操作系统内核存放数据&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;0x00&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;0x40 ~ 0x7f&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;提供给操作系统内核存放代码&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;0x40&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;0x80 ~ 0xcf&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;提供给程序 A 存放数据&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;0x80&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;0xd0 ~ 0xff&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;提供给程序 A 存放代码&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;0xd0&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;…&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;…&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;…&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;…&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;内核是指操作系统驻留在内存中的最基本的部分。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;同时，我们已经学习过段描述符了，&lt;strong&gt;段基址&lt;/strong&gt;是放到段描述符中的，那么&lt;strong&gt;访问权限&lt;/strong&gt;自然也可以放到段描述符中。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;基本控制&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#基本控制&#34;&gt;#&lt;/a&gt; 基本控制&lt;/h2&gt;
&lt;p&gt;假定我是 CPU，此刻我的 ip 指针指向了应用程序中的指令序列，并且我的&lt;strong&gt;当前身份是用户&lt;/strong&gt;。&lt;br&gt;
一旦我试图&lt;strong&gt;访问我不应该访问的内存&lt;/strong&gt; (如提供给操作系统内核存放数据的段)，因为我没有那么高的特权，&lt;strong&gt;就应当受到制止。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;表明当前程序的身份&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#表明当前程序的身份&#34;&gt;#&lt;/a&gt; 表明当前程序的身份&lt;/h3&gt;
&lt;p&gt;既然我们知道，访问内存中的段增加了一项对权限的例行检查，那么自然就需要有一项能表示我们当前身份的东西了。&lt;/p&gt;
&lt;h3 id=&#34;dpl&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#dpl&#34;&gt;#&lt;/a&gt; DPL&lt;/h3&gt;
&lt;p&gt;组成段描述符的字段之一，表明段描述符的特权级，访问该段应具备的权限。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Descriptor Privilege Level，描述符特权级&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;rpl&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#rpl&#34;&gt;#&lt;/a&gt; RPL&lt;/h3&gt;
&lt;p&gt;还记得我们之前学过的段选择子吗？当时我们只说了，段选择子用于从 GDT 中选择段描述符并加载，实际上，段选择子一共有 16bit，其中高 13bit，才是 GDT 的索引。&lt;/p&gt;
&lt;p&gt;在段选择子中，低 3bit 是另作他用的，其中低 2bit，用于表示 CPU 加载段描述符时的请求权限。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;即 RPL，Requested Privilege Level ，请求特权级&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;意为发起访问请求时的特权级&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;cpl&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#cpl&#34;&gt;#&lt;/a&gt; CPL&lt;/h3&gt;
&lt;p&gt;cs 段选择子与 ss 段选择子的 RPL 字段。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;又称为 CPL，Current Privilege Level，当前特权级&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;示例&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#示例&#34;&gt;#&lt;/a&gt; 示例&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;接下来我们通过使用机密文档来举个栗子，尝试理解它。&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;文档&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;最低阅读准许级别&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;文档 A&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;排长&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;文档 B&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;连长&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;首先，假定军官可以申请阅读机密文档，并且每个机密文档都有对应的权限要求；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;又假定我是排长，想阅读排长级别才能阅读的机密文件，于是我写了一份申请报告 (请求)，上面写着 **“排长级别”&lt;strong&gt;，并且对审核人员说，我希望能阅读&lt;/strong&gt;文档 A**，审核人员在查看了报告上的请求级别，再与文档 A 的级别进行比较，如果报告上的级别达到了文档 A 的阅读准许级别，审核人员则会批准，我就可以阅读了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;但是当我想阅读具有连长身份才能阅读的机密文档时，于是我依旧提交申请报告，填写 **“排长级别”&lt;strong&gt;，并告诉他我希望阅读&lt;/strong&gt;文档 B**，负责审批的人一看，你这不对啊，你这申请报告上写的是排长级别，但你想阅读的文档是连长级别才能阅读的机密文档，拒绝也就是理所当然的事。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;此处 以军官的身份与阅读机密文件进行比喻 仅出于个人认为易于理解的想法，无其他意义，我尊敬军人，热爱祖国。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;既然有 RPL 了，那么为什么要多此一举，弄出来一个 CPL，这个 CPL 又是个什么东西呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在上面我们强调的是&lt;strong&gt;请求&lt;/strong&gt;，那么为什么要划分&lt;strong&gt;请求&lt;/strong&gt;和&lt;strong&gt;当前&lt;/strong&gt;呢？&lt;/p&gt;
&lt;p&gt;就好比阅读机密文档，需要有足够的身份，才能拥有对应的权限。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;请求
&lt;ul&gt;
&lt;li&gt;即我希望阅读的机密文档的级别；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;当前
&lt;ul&gt;
&lt;li&gt;表示我现在的身份。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果没有对&lt;strong&gt;当前身份&lt;/strong&gt;的检查，那么即便我是排长，我也可以&lt;strong&gt;提交一个 &amp;quot;连长级别&amp;quot; 的申请报告&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;只校验请求是不够的，更重要的是当前的身份&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;程序的运行是依赖于 CPU 的，而 CPU 通过 CPL，辨认当前被 CPU 取指执行的程序的身份；通过 RPL，确定当前程序发起的请求时指定的特权级。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可能有的同学又要发炎啦，啊那我直接看身份级别不就行了，为什么还要多此一举，弄出来一个请求级别。&lt;/p&gt;
&lt;h3 id=&#34;arpl&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#arpl&#34;&gt;#&lt;/a&gt; ARPL&lt;/h3&gt;
&lt;p&gt;咱们再看一个例子，假设我有一个朋友，他是团长，在平时我抽不开身的时候，就干脆让他帮我递交&lt;strong&gt;申请报告&lt;/strong&gt;，并且告诉他我想查看什么文档，让他替我带回文档。&lt;/p&gt;
&lt;p&gt;而 RPL 的意义在于此，假设我想阅读&lt;strong&gt;文档 B&lt;/strong&gt;，但是我转交给他的申请报告写的是 &amp;quot;排长级别&amp;quot;，就算他&lt;strong&gt;以团长的身份递交申请报告，因为申请报告中填写的级别不足，依旧会被拒绝&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这个时候新的问题又来了，如果我转交给他的是一个 &amp;quot;连长级别&amp;quot; 的申请报告呢？这个时候的检查工作就落在团长的身上，他必须&lt;strong&gt;先检查我的身份和我的申请报告&lt;/strong&gt;，如果我的申请报告与我的身份存在问题，那么他就会将我递交的申请报告进行修改，虽然他依旧会原样传达我的话 (我想阅读&lt;strong&gt;文档 B&lt;/strong&gt;)，但是审核人员可以通过查阅申请报告，以及团长传递的话，从而选择拒绝与否。&lt;/p&gt;
&lt;h4 id=&#34;检查工作&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#检查工作&#34;&gt;#&lt;/a&gt; 检查工作&lt;/h4&gt;
&lt;p&gt;而这个检查与修改的过程就是 ARPL 指令所做的工作&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;我们的&lt;strong&gt;应用 (连长)&lt;strong&gt; 委托&lt;/strong&gt;操作系统 (团长)&lt;strong&gt; 访问指定的&lt;/strong&gt;段 (机密文档)&lt;/strong&gt;；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;应用的&lt;strong&gt; RPL (申请报告)&lt;/strong&gt;，以及应用的&lt;strong&gt; CPL (身份)&lt;/strong&gt;，&lt;strong&gt;操作系统&lt;/strong&gt;通过 ARPL 指令进行校验以及修改，以保证操作系统不会不小心替应用访问了不应该访问的段。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最后由&lt;strong&gt; cpu (审核员)&lt;strong&gt; 检查段的访问权限&lt;/strong&gt; DPL (机密文档的阅读权限)&lt;/strong&gt;；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;而 应用是如何委托操作系统 等内容，请在学习权限切换后，再次回来复习。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;权限检查&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#权限检查&#34;&gt;#&lt;/a&gt; 权限检查&lt;/h1&gt;
&lt;p&gt;我们讲述了基于段机制的内存访问是如何受到控制的。&lt;/p&gt;
&lt;p&gt;我想，各位看完之后依旧会存在不少疑惑，比如所谓的&lt;strong&gt;访问&lt;/strong&gt;，对权限的检查，具体是发生在什么时候呢？&lt;/p&gt;
&lt;h2 id=&#34;段的分类&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#段的分类&#34;&gt;#&lt;/a&gt; 段的分类&lt;/h2&gt;
&lt;p&gt;我们知道，由地址上连续的多个内存单元组织而成的内存区域，就可以将其称之为段。&lt;br&gt;
为了减少错误的出现与降低开发难度，在实模式时，就已经开始将内存划分为多个段，并且根据用途为段进行了分类。&lt;/p&gt;
&lt;p&gt;在前面的笔记我们粗略提及过段的分类，本篇再对保护模式下的段的分类进行讲述。&lt;/p&gt;
&lt;h2 id=&#34;实模式&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#实模式&#34;&gt;#&lt;/a&gt; 实模式&lt;/h2&gt;
&lt;p&gt;在实模式下，段的分类更偏向于程序设计者自主安排，我不强求，你想怎么安排，就可以怎么安排，重要的是哪个段寄存器指向了那块内存区域。&lt;/p&gt;
&lt;p&gt;如将 x8000 这个地址作为段的基址，我可以将其赋值给 cs，也可以将其赋值给 ds，取决于我如何使用它。&lt;/p&gt;
&lt;h2 id=&#34;保护模式&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#保护模式&#34;&gt;#&lt;/a&gt; 保护模式&lt;/h2&gt;
&lt;p&gt;为何我会说实模式的段分类下是程序设计者的自主安排，难道保护模式就不是了吗？&lt;br&gt;
实际上，对于应用程序设计者而言，确实是的。&lt;/p&gt;
&lt;p&gt;你也许会想，实模式的段寄存器我可以随便加载，保护模式的段选择子就不可以了吗？&lt;/p&gt;
&lt;p&gt;很遗憾，应用程序设计者确实没有这么大的权限，要不为何会着重&lt;strong&gt;保护&lt;/strong&gt;二字呢？&lt;/p&gt;
&lt;h2 id=&#34;段描述符相关字段&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#段描述符相关字段&#34;&gt;#&lt;/a&gt; 段描述符相关字段&lt;/h2&gt;
&lt;p&gt;咱们还是要看英特尔白皮书中对段描述符的解释，在往后的笔记中还会经常与它见面。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- &amp;#123;% asset_img 1.png 这是一张图片 %&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;s字段&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#s字段&#34;&gt;#&lt;/a&gt; S 字段&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;S 字段为 1
&lt;ul&gt;
&lt;li&gt;当前段描述符描述的段是代码段或数据段&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;S 字段为 0
&lt;ul&gt;
&lt;li&gt;当前段描述符描述的段是系统段&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;数据段&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#数据段&#34;&gt;#&lt;/a&gt; 数据段&lt;/h3&gt;
&lt;p&gt;数据段是指用于存放数据的内存区域，向下还能再细分为&lt;strong&gt;只读数据段&lt;/strong&gt;、&lt;strong&gt;栈段&lt;/strong&gt;等，供 CPU 读或写。&lt;/p&gt;
&lt;h3 id=&#34;代码段&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#代码段&#34;&gt;#&lt;/a&gt; 代码段&lt;/h3&gt;
&lt;p&gt;代码段是指用于存放指令序列的内存区域，供 CPU 执行。&lt;/p&gt;
</content>
        <category term="保护模式" />
        <category term="Windows内核" />
        <updated>2023-02-17T14:57:07.000Z</updated>
    </entry>
    <entry>
        <id>http://yuyuaqwq.github.io/posts/4aaf.html</id>
        <title>【保护模式】1.初探保护模式与分段机制</title>
        <link rel="alternate" href="http://yuyuaqwq.github.io/posts/4aaf.html"/>
        <content type="html">&lt;h1 id=&#34;保护模式&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#保护模式&#34;&gt;#&lt;/a&gt; 保护模式&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;保护模式是在硬件层面提供的 CPU 运行机制，是现代操作系统的根本。&lt;/li&gt;
&lt;li&gt;没有保护模式，操作系统是没有安全性可言的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;何为保护&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#何为保护&#34;&gt;#&lt;/a&gt; 何为保护&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;指令是存放在内存中的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;假定你的程序试图对操作系统的关键代码进行破坏：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;mov byte ptr ds:[kernel], 0x90&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;操作系统应该如何制止？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;也许这个时候有同学发炎了：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;“也许操作系统它能监控呢？”&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;答案是，监控你程序的并不是操作系统，这种工作必须在硬件层完成&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;很简单的道理，实际上运行指令的是 CPU，只有 CPU 知道当前 CPU 正在做什么事，操作系统是不可能知道的
&lt;ul&gt;
&lt;li&gt;操作系统也是由 CPU 运行的指令序列。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;除非 CPU 提供了一种回调机制，运行任何指令都先运行操作系统的指令，但这是不现实的，对性能影响过于严重
&lt;ul&gt;
&lt;li&gt;实现一套虚拟机也可以保证安全性，但是依旧存在性能问题，也不在本文讨论范围之内。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;模式之分&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#模式之分&#34;&gt;#&lt;/a&gt; 模式之分&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;我们得到了结论，保证 操作系统的安全性 这种机制，必须是硬件提供的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在早期，CPU 并未提供这种保护模式，为此才划分出了 “实模式” 与 “保护模式”&lt;/li&gt;
&lt;li&gt;在保护模式出现时，为了兼容，因此也诞生了 “虚拟 8086 模式”，但已经不重要了，也不在本文讨论范围内。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;在学习保护模式时也需要牢记，保护模式是硬件层的东西，切勿与操作系统混淆。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;物理内存&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#物理内存&#34;&gt;#&lt;/a&gt; 物理内存&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;我们都知道，我们可见的物理内存，其实就是&lt;strong&gt;连续的、对每一个单元进行了地址编号的很大的存储器。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;地址&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;数据&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;0x00&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;0xff&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;0x01&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;0x00&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;…&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;…&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;em&gt;表格仅为举例，与真实物理内存布局无关&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;程序必须是存放在内存中，才能被 CPU&lt;strong&gt; 取指执行&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;假定你是操作系统 (给你管理硬件资源)，那么多个程序又如何存放比较好呢？&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;多个程序的安置&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#多个程序的安置&#34;&gt;#&lt;/a&gt; 多个程序的安置&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;可能有同学回答了：
&lt;ul&gt;
&lt;li&gt;我&lt;strong&gt;顺序加载&lt;/strong&gt;嘛，第一个程序从哪里占用到哪里，第二个程序从哪里占用到哪里&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;地址&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;程序&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;0x00 ~ 0x7f&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;提供给程序 A&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;0x80 ~ 0xff&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;提供给程序 B&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;…&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;…&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如表格所述，我们成功将两个程序分别放到了不同的位置。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;这样子他们就互不干扰了，我们真是个小天才。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;问题仍在&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#问题仍在&#34;&gt;#&lt;/a&gt; 问题仍在&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;很遗憾，这样子的程序，运行依旧存在困难&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在编写程序的时候，无法预知程序在运行时究竟会被加载到内存的哪个位置。&lt;/li&gt;
&lt;li&gt;假设&lt;strong&gt; B&lt;/strong&gt; 选择 &lt;code&gt;0x40&lt;/code&gt;  这个地址存放一些数据，那不是正好破坏了&lt;strong&gt; A&lt;/strong&gt; 的指令序列？&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;为此，&lt;strong&gt;内存分段&lt;/strong&gt;诞生了&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&#34;内存分段&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#内存分段&#34;&gt;#&lt;/a&gt; 内存分段&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果我们在编写程序的时候，任何使用内存的指令，填写的内存地址，都是一个&lt;strong&gt;偏移值&lt;/strong&gt;，让 CPU 替我们去与&lt;strong&gt;基地址&lt;/strong&gt;相加，最终得到真正的&lt;strong&gt;物理地址&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;那么不管我们的程序被加载到内存的哪个位置，只要提供一个正确的&lt;strong&gt;基地址&lt;/strong&gt;，就可以让多个程序互不干扰了！&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;示例&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#示例&#34;&gt;#&lt;/a&gt; 示例&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;地址&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;程序&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;基地址&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;0x00 ~ 0x7f&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;提供给程序 A&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;0x00&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;0x80 ~ 0xff&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;提供给程序 B&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;0x80&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;…&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;…&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;…&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;假设&lt;strong&gt; B&lt;/strong&gt; 选择 &lt;code&gt;0x40&lt;/code&gt;  这个地址存放一些数据，我们还会破坏&lt;strong&gt; A&lt;/strong&gt; 的指令序列吗？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;这样看上去，是不是像给&lt;strong&gt;内存分段&lt;/strong&gt;了一样？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;0x00 ~ 0x7f&lt;/code&gt;  看作一段，分给&lt;strong&gt;程序 A&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0x80 ~ 0xff&lt;/code&gt;  看作一段，分给&lt;strong&gt;程序 B&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;实模式下的分段机制大抵如此。&lt;/p&gt;
&lt;h1 id=&#34;段寄存器&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#段寄存器&#34;&gt;#&lt;/a&gt; 段寄存器&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;想来各位读者对寄存器都有所了解，既然我们需要一个容器来存放&lt;strong&gt;段的基地址&lt;/strong&gt;，寄存器自然是不错的选择。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;但是通用寄存器本身数量也不够多，再想腾出来存放&lt;strong&gt;段基址&lt;/strong&gt;，也是心有余而力不足了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;因此，理所当然的，就有了以&lt;strong&gt;段&lt;/strong&gt;为名的&lt;strong&gt;段寄存器&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;ds寄存器&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#ds寄存器&#34;&gt;#&lt;/a&gt; ds 寄存器&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;ds，即 data segment，意为数据段&lt;/li&gt;
&lt;li&gt;咱们一看就知道，这个东西就是和&lt;strong&gt;数据&lt;/strong&gt;、&lt;strong&gt;段&lt;/strong&gt; 相关的。&lt;/li&gt;
&lt;li&gt;它也十分简单，16 位的宽度，作用就是存放数据段的基址&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;注解&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;实际在实模式下，物理地址的转换公式略微复杂一些&lt;br&gt;
 (ds &amp;lt;&amp;lt; 4) + address = 最终的物理地址&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;结合先前的示例&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#结合先前的示例&#34;&gt;#&lt;/a&gt; 结合先前的示例&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;地址&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;程序&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;基地址&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;0x00 ~ 0x7f&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;提供给程序 A&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;0x00&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;0x80 ~ 0xff&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;提供给程序 B&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;0x80&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;…&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;…&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;…&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;我们选择让&lt;strong&gt; B&lt;/strong&gt; 在 &lt;code&gt;0x40&lt;/code&gt;  这个位置存放一些数据&lt;/li&gt;
&lt;li&gt;而现在我们有了 ds 寄存器，只要在程序运行前初始化 ds 寄存器，就可以做到不破坏&lt;strong&gt; A&lt;/strong&gt; 的程序了。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;根据段的用途进行划分&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#根据段的用途进行划分&#34;&gt;#&lt;/a&gt; 根据段的用途进行划分&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;但是这样子明显我们还需要小心翼翼，毕竟虽然不会破坏其他程序了，但不代表不会破坏自己的指令序列啊！&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;代码&lt;/strong&gt;和&lt;strong&gt;数据&lt;/strong&gt;都放在一个段里，是不是不便管理？&lt;/li&gt;
&lt;li&gt;如果我们对代码和数据再做进一步的&lt;strong&gt;划分&lt;/strong&gt;，是不是更好？&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;地址&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;程序&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;基地址&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;0x00 ~ 0x3f&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;提供给程序 A 存放数据&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;0x00&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;0x40 ~ 0x7f&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;提供给程序 A 存放代码&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;0x40&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;0x80 ~ 0xcf&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;提供给程序 B 存放数据&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;0x80&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;0xd0 ~ 0xff&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;提供给程序 B 存放代码&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;0xd0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;…&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;…&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;…&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;为此，自然是可以存在更多的段寄存器&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;cs(code segment)&lt;/li&gt;
&lt;li&gt;ss(stack segment)&lt;/li&gt;
&lt;li&gt;ds(data segment)&lt;/li&gt;
&lt;li&gt;…&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;还是先前的问题，程序&lt;strong&gt; B&lt;/strong&gt; 试图在 &lt;code&gt;0x40&lt;/code&gt;  这个地址存放数据，我们只需要让 cpu 知道，&lt;strong&gt;数据段基址&lt;/strong&gt;是 &lt;code&gt;0x80&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;0x80 + 0x40 = 0xc0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;我们只需要划分好各个段，就可以很好的让程序工作了！&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;cpu对内存的访问&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#cpu对内存的访问&#34;&gt;#&lt;/a&gt; CPU 对内存的访问&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;为此，cpu 也被设计为，在&lt;strong&gt;访问任何汇编指令中显式书写的内存地址时&lt;/strong&gt;，都会先根据&lt;strong&gt;用途&lt;/strong&gt;选择&lt;strong&gt;段寄存器&lt;/strong&gt;，得到&lt;strong&gt;段基地址&lt;/strong&gt;，&lt;strong&gt;指令中的地址&lt;/strong&gt;视作&lt;strong&gt;偏移 (逻辑地址)&lt;/strong&gt;，&lt;strong&gt;运算后&lt;/strong&gt;得到&lt;strong&gt;真正的物理地址&lt;/strong&gt;，再进行&lt;strong&gt;访问&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;注解&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;读写内存，可以划分为对数据段的访问&lt;br&gt;
执行指令，可以划分为对代码段的访问&lt;br&gt;
…&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;初探基于段的保护&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#初探基于段的保护&#34;&gt;#&lt;/a&gt; 初探基于段的保护&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在实模式下，对于任何存在于内存中的指令序列，cpu 是&lt;strong&gt;一视同仁&lt;/strong&gt;的，ip 指哪它跑哪，埋头苦干。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;操作系统将我们的程序加载到内存，使得 cs:ip 指向我们程序的入口点之后，&lt;strong&gt;我们想干什么，就不是操作系统能说了算了&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当然我们也可以反手来一波背刺，&lt;strong&gt;捅死操作系统&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;尝试分段&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#尝试分段&#34;&gt;#&lt;/a&gt; 尝试分段&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;你可能想到了，啊，我们先前不是才讲过，分段不就好了吗？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;其实所谓的分段，也是建立在大家都&lt;strong&gt;规规矩矩&lt;/strong&gt;，&lt;strong&gt;和睦相处&lt;/strong&gt;的情况下，才能最大程度上避免 &amp;quot;不小心&amp;quot; 出现的问题。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;简单地说，全看编写程序的人自觉不自觉。&lt;/li&gt;
&lt;li&gt;既然操作系统能&lt;strong&gt;修改 cs、ds 段寄存器&lt;/strong&gt;，我们有何不可呢？&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;权限的建立&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#权限的建立&#34;&gt;#&lt;/a&gt; 权限的建立&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;首先，咱们既然要保证&lt;strong&gt;安全&lt;/strong&gt;，那自然就要划分哪些是应用能做的，哪些是应用不能做的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;其次，总归要有程序去管理软硬件的，操作系统的不受限制也理所应当了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;权限划分&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#权限划分&#34;&gt;#&lt;/a&gt; 权限划分&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;既然有了&lt;strong&gt;不能做&lt;/strong&gt;和&lt;strong&gt;能做&lt;/strong&gt;之分，并且还有了 &amp;quot;区别对待&amp;quot;，&lt;strong&gt;权限&lt;/strong&gt;自然也就建立起来了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;至此，咱们初步确定了&lt;strong&gt;权限&lt;/strong&gt;的划分。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;常规应用，拥有&lt;strong&gt;部分权限&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;操作系统，拥有&lt;strong&gt;所有权限&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;段机制的延展&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#段机制的延展&#34;&gt;#&lt;/a&gt; 段机制的延展&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;咱们最先想到的，最不能让应用去乱搞的是什么呢？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;首先就是不能让应用去破坏咱们的操作系统，咱们首先要把自己&lt;strong&gt;保护&lt;/strong&gt;起来。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;如果应用能随意修改操作系统的指令序列，那么所谓的保护将毫无意义&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;初步构想&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#初步构想&#34;&gt;#&lt;/a&gt; 初步构想&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;我们可以沿用实模式下存在的段机制，为段设立权限。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;应用的指令序列处在一个&lt;strong&gt;权限受限&lt;/strong&gt;的段中，&lt;strong&gt;不允许访问除自己段内的任何内存。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;而操作系统就处在拥有&lt;strong&gt;最高特权&lt;/strong&gt;的段中，&lt;strong&gt;掌有生杀大权&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</content>
        <category term="保护模式" />
        <category term="Windows内核" />
        <updated>2023-02-17T14:34:48.000Z</updated>
    </entry>
    <entry>
        <id>http://yuyuaqwq.github.io/posts/41fe.html</id>
        <title>【保护模式】x64下定位随机页表基址的思路</title>
        <link rel="alternate" href="http://yuyuaqwq.github.io/posts/41fe.html"/>
        <content type="html">&lt;h1 id=&#34;前言&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#前言&#34;&gt;#&lt;/a&gt; 前言&lt;/h1&gt;
&lt;p&gt;&lt;em&gt;昨天在看周哥讲 x64 内核的时候，得知了 windows10 的某个版本开始，页表基址不再固定了。&lt;/em&gt;&lt;br&gt;
&lt;em&gt;今天晚上突然有了个思路，就动手把他敲出来了，这种思路是不是已经烂大街了我也不确定，就当发出来学习交流吧。&lt;/em&gt;&lt;/p&gt;
&lt;h1 id=&#34;随机页表基址原理&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#随机页表基址原理&#34;&gt;#&lt;/a&gt; 随机页表基址原理&lt;/h1&gt;
&lt;p&gt;这里用 x86 的 10-10-12 分页举例吧，比较好理解，理解了 x64 的也差不多的&lt;/p&gt;
&lt;p&gt;启用了保护模式和分页机制后，咱就不能直接访问物理地址了，都会被 MMU 当作虚拟地址进行转换。&lt;/p&gt;
&lt;p&gt;但是 cr3 存的又是物理地址，不能直接操作页表了，那咋办呢？&lt;/p&gt;
&lt;p&gt;聪明的前辈们，选择在页目录表中选择一项 (共 1024 项，每一项 4 字节)，使其存储的物理地址与页目录表的基址 (cr3) 相同，这样子就可以构造一个访问页表的虚拟地址了，大概就是&lt;strong&gt;让 cpu 在地址转换的过程中绕圈圈&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;画个图吧&lt;/li&gt;
&lt;li&gt;
&lt;img src=&#34;/posts/41fe/1.png&#34; class=&#34;&#34; title=&#34;这是一张图片&#34;&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;定位思路&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#定位思路&#34;&gt;#&lt;/a&gt; 定位思路&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;x64 也必然是随机选择 PXT 的其中一项 PXE 来存储 PXT 的物理地址，实现的随机页表基址&lt;/li&gt;
&lt;li&gt;那么就可以通过&lt;strong&gt;构造所有可能指向 PXT 的虚拟地址 (共 512 项)&lt;/strong&gt;，转换为物理地址，再与 cr3 比较，最终得到正确的 PXT 基址。&lt;/li&gt;
&lt;li&gt;只要知道了存储 PXT 的物理地址的 PXE 的 PXI，构造 PPT/PDT/PTT 基址都很简单了&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;实现&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#实现&#34;&gt;#&lt;/a&gt; 实现&lt;/h1&gt;
&lt;figure class=&#34;highlight c++&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;function&#34;&gt;PVOID &lt;span class=&#34;title&#34;&gt;GetPXTBase&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	UINT64 cr3 = __readcr3();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	&lt;span class=&#34;built_in&#34;&gt;KdPrint&lt;/span&gt;((&lt;span class=&#34;string&#34;&gt;&amp;quot;yuyu:cr3:%p\n&amp;quot;&lt;/span&gt;, cr3));&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	&lt;span class=&#34;keyword&#34;&gt;for&lt;/span&gt; (UINT64 i = &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&#34;number&#34;&gt;512&lt;/span&gt;; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;		&lt;span class=&#34;comment&#34;&gt;// 通过PXI构造虚拟地址&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;		PVOID pxtBase = (PVOID)(&lt;span class=&#34;number&#34;&gt;0xffff000000000000&lt;/span&gt; | (i &amp;lt;&amp;lt; &lt;span class=&#34;number&#34;&gt;12&lt;/span&gt;) | (i &amp;lt;&amp;lt; &lt;span class=&#34;number&#34;&gt;21&lt;/span&gt;) | (i &amp;lt;&amp;lt; &lt;span class=&#34;number&#34;&gt;30&lt;/span&gt;) | (i &amp;lt;&amp;lt; &lt;span class=&#34;number&#34;&gt;39&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;		PHYSICAL_ADDRESS physical = &lt;span class=&#34;built_in&#34;&gt;MmGetPhysicalAddress&lt;/span&gt;(pxtBase);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;		&lt;span class=&#34;built_in&#34;&gt;KdPrint&lt;/span&gt;((&lt;span class=&#34;string&#34;&gt;&amp;quot;yuyu:i:%d 物理:%p 虚拟:%p\n&amp;quot;&lt;/span&gt;, i, physical.QuadPart, pxtBase));&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;		&lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (cr3 == physical.QuadPart) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;			&lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; pxtBase;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;		&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	&lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;literal&#34;&gt;NULL&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;img src=&#34;/posts/41fe/2.png&#34; class=&#34;&#34; title=&#34;这是一张图片&#34;&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;结尾&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#结尾&#34;&gt;#&lt;/a&gt; 结尾&lt;/h1&gt;
&lt;p&gt;理解有限，如有错误，还请指正&lt;/p&gt;
&lt;h1 id=&#34;2022514补充&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#2022514补充&#34;&gt;#&lt;/a&gt; 2022/5/14 补充&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;其实除开这个之外，我先想到的是另一个思路，即&lt;strong&gt;构造所有可能存储 PXT 的物理地址的 PXE 的虚拟地址&lt;/strong&gt;。
&lt;ul&gt;
&lt;li&gt;依旧是 512 项，探测地址是否可访问，读取 8 字节；&lt;/li&gt;
&lt;li&gt;将其当作 PXE，取出物理页面基址，再与 cr3 进行比较。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;但是这种方法有概率出现问题，即存放的数据可能正好与 cr3 相同，但所在页面并不是 PXT。
&lt;ul&gt;
&lt;li&gt;因此我就没有写出来，不过我想了一下，还是贴出来了，也算是一种思路嘛。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</content>
        <category term="保护模式" />
        <category term="Windows内核" />
        <updated>2022-12-02T08:21:05.000Z</updated>
    </entry>
</feed>
