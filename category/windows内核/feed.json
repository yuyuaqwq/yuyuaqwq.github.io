{
    "version": "https://jsonfeed.org/version/1",
    "title": "鹿鹿鱼鱼 • All posts by \"windows内核\" category",
    "description": "人为什么要起床？",
    "home_page_url": "http://yuyuaqwq.github.io",
    "items": [
        {
            "id": "http://yuyuaqwq.github.io/posts/f54c.html",
            "url": "http://yuyuaqwq.github.io/posts/f54c.html",
            "title": "【保护模式】2.基于段的保护",
            "date_published": "2023-02-17T14:57:07.000Z",
            "content_html": "<h1 id=\"段寄存器的扩展\"><a class=\"markdownIt-Anchor\" href=\"#段寄存器的扩展\">#</a> 段寄存器的扩展</h1>\n<p>我们需要划分权限，让操作系统和应用处在不同的权限中，以保证系统安全；<br>\n并且决定基于段机制进行延展。</p>\n<p>相较于实模式的 1MB 寻址 (2<sup>20)，保护模式下的寻址范围已经达到了 4GB (2</sup>32)，在汇编指令上可以直接书写 4 字节的内存地址。</p>\n<p>此时，段寄存器的 16 位宽度已经显得有些相形见绌了。<br>\n为了扩展，段寄存器在保护模式下，不再直接存放段的基址，而是存放了<strong>索引</strong>。</p>\n<h2 id=\"全局描述符表-global-descriptor-table\"><a class=\"markdownIt-Anchor\" href=\"#全局描述符表-global-descriptor-table\">#</a> 全局描述符表 (Global Descriptor Table)</h2>\n<p>具体是索引什么呢？<br>\n这里引入了一张表，叫做<strong>全局描述符表</strong>，其实就是在内存中存放的数组。<br>\n其元素叫做<strong>段描述符</strong>，在内存中顺序组织起来，也就是一张表。</p>\n<ul>\n<li>简称<strong> GDT</strong></li>\n</ul>\n<h2 id=\"段选择子\"><a class=\"markdownIt-Anchor\" href=\"#段选择子\">#</a> 段选择子</h2>\n<p>段寄存器由于有了新的用途，因此也有了新的名字，叫做<strong>段选择子</strong>。</p>\n<blockquote>\n<p>大概是意为用于选择段的寄存器吧</p>\n</blockquote>\n<h2 id=\"段描述符\"><a class=\"markdownIt-Anchor\" href=\"#段描述符\">#</a> 段描述符</h2>\n<p>那么说回段描述符，它究竟有什么作用呢？为什么会有这么一个东西呢？</p>\n<blockquote>\n<p>段描述符是 GDT 或 LDT (暂时忽略) 中的元素；<br>\n它为处理器提供诸如段基址，段大小，访问权限及状态等信息。</p>\n</blockquote>\n<ul>\n<li>先来看英特尔白皮书上对段描述符的图示\n<ul>\n<li>\n\n</li>\n</ul>\n</li>\n</ul>\n<p>每个段描述符是 8 字节，由多个字段组成。<br>\n我们发现，字段的排列有些混乱，基址 (Base)、界限 (Limit) 甚至需要跨几个字段组合。</p>\n<blockquote>\n<p>据说是英特尔为了兼容，这里也不做探究。</p>\n</blockquote>\n<p>字段这么多，咱们先来看最熟悉的基址字段。<br>\n还记得 <strong>4. 段寄存器</strong> 小节中的 <strong>CPU 对内存的访问</strong> 那部分吗？<br>\n<strong>在实模式下，cpu 访问任何在汇编指令中显式书写的地址，都会将地址视作偏移 (逻辑地址)，加上段基地址形成真正的物理地址。</strong></p>\n<p>在这里也不例外，只不过段寄存器并不直接存放段基址了，而是存放用于了在 GDT 中选择段描述符的索引值。</p>\n<h2 id=\"访问内存\"><a class=\"markdownIt-Anchor\" href=\"#访问内存\">#</a> 访问内存</h2>\n<p>至此，我们也能初步设想在保护模式下，CPU 是如何基于段访问内存的：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov eax, dword ptr ds:[0x12345678]</span><br></pre></td></tr></table></figure>\n<ol>\n<li>汇编指令中的内存地址 (偏移，<strong>offset</strong>) 是<strong> 0x12345678</strong>；</li>\n<li>汇编指令中指定使用的段寄存器是 <strong>ds</strong>；</li>\n<li>访问 ds 段寄存器，得到<strong>索引 (index)</strong>；</li>\n<li>访问<strong> GDT [index]</strong>，得到段描述符；</li>\n<li>解析段描述符中的<strong> Base</strong> 字段；</li>\n<li><strong>ds.Base</strong> + <strong>offset</strong> = <strong>最终的物理地址</strong>；</li>\n<li>通过物理地址访问内存。</li>\n</ol>\n<h1 id=\"地址分类\"><a class=\"markdownIt-Anchor\" href=\"#地址分类\">#</a> 地址分类</h1>\n<p>至此我们基本了解了，保护模式下 CPU 如何基于段描述符进行寻址。<br>\n并且在上文，我列出了 CPU 将汇编指令中书写的地址转换为物理地址的猜想。</p>\n<p>在保护模式下，实际寻址过程的各个阶段的地址也都是有命名的。<br>\n为了向下深入学习，先了解一下还是有必要的。</p>\n<h2 id=\"逻辑地址相对地址\"><a class=\"markdownIt-Anchor\" href=\"#逻辑地址相对地址\">#</a> 逻辑地址 / 相对地址</h2>\n<p>百度百科的解释是：</p>\n<blockquote>\n<p>指在计算机体系结构中是指应用程序角度看到的内存单元（memory cell）、存储单元（storage element）、网络主机（network host）的地址。 逻辑地址往往不同于物理地址（physical address），通过地址翻译器（address translator）或映射函数可以把逻辑地址转化为物理地址。</p>\n</blockquote>\n<p>咱们简单一点，<strong>还是理解成在汇编指令中显式书写的地址。</strong></p>\n<p>如上一节举例的汇编指令：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov eax, dword ptr ds:[0x12345678]</span><br></pre></td></tr></table></figure>\n<p>我们在当时把它叫做偏移 (offset)，其实它应该叫做<strong>逻辑地址</strong>。</p>\n<p>在实模式下，<strong>逻辑地址 + 段基地址 = 物理地址</strong>；<br>\n在保护模式下， <strong>逻辑地址 + 段基地址 = 线性地址</strong>。</p>\n<h2 id=\"线性地址虚拟地址\"><a class=\"markdownIt-Anchor\" href=\"#线性地址虚拟地址\">#</a> 线性地址 / 虚拟地址</h2>\n<p>摘自百度百科：</p>\n<blockquote>\n<p>线性地址（Linear Address）是逻辑地址到物理地址变换之间的中间层。在分段部件中逻辑地址是段中的偏移地址，然后加上基地址就是线性地址。</p>\n</blockquote>\n<p>线性地址是在保护模式下出现的，通过<strong>页表</strong>将<strong>线性地址</strong>转换成<strong>物理地址</strong>。</p>\n<ul>\n<li><strong>在上节举例时，我们将 &quot;线性地址&quot; 称为 &quot;物理地址&quot;；</strong></li>\n<li><strong>线性地址到物理地址的转换涉及到分页机制，在未学习分页机制之前，请暂时将笔记中所有 &quot;线性地址&quot; 视作 &quot;物理地址&quot;。</strong></li>\n</ul>\n<h2 id=\"物理地址\"><a class=\"markdownIt-Anchor\" href=\"#物理地址\">#</a> 物理地址</h2>\n<p>摘自百度百科：</p>\n<blockquote>\n<p>在存储器里以字节为单位存储信息，为正确地存放或取得信息，每一个字节单元给以一个唯一的存储器地址，称为物理地址（Physical Address），又叫实际地址或绝对地址。</p>\n</blockquote>\n<p>CPU 最终通过<strong>物理地址</strong>去访问<strong>真正的存储单元</strong>。</p>\n<h1 id=\"段描述符缓存\"><a class=\"markdownIt-Anchor\" href=\"#段描述符缓存\">#</a> 段描述符缓存</h1>\n<h2 id=\"gdtr\"><a class=\"markdownIt-Anchor\" href=\"#gdtr\">#</a> GDTR</h2>\n<p>我们说到，既然 CPU 访问内存，需要先访问 GDT，那么 GDT 的地址又是从哪里来的呢？</p>\n<p>CPU 提供了一个 48bit、名为<strong> GDTR</strong> 的寄存器。</p>\n<blockquote>\n<p>高 32bit 存放 GDT 的首地址（线性地址）；<br>\n低 16bit 存放 GDT 的界限，即整个 GDT 表的长度。</p>\n</blockquote>\n<ul>\n<li>通过 windbg 调试 Windows XP，查看<strong> GDTR</strong> 的内容：\n<ul>\n<li>\n\n</li>\n</ul>\n<blockquote>\n<p>关于 windbg 的使用，在内核的学习阶段是非常重要的，所学的知识都需要自己动手实验、验证；<br>\n如果有需要的话，我会考虑再找时间写一篇关于环境配置的文章。</p>\n</blockquote>\n</li>\n</ul>\n<p>在 windbg 下：<br>\n查询<strong> gdtr</strong>，即查询 GDT 的首地址；<br>\n查询<strong> gdtl</strong>，即查询 GDT 的界限。</p>\n<p>CPU 每次访问<strong> GDT</strong> 时，都是从<strong> GDTR</strong> 中获取<strong>线性地址</strong>。</p>\n<p>而 GDTR 的值，是由操作系统在初始化阶段填入的。</p>\n<h2 id=\"不可见寄存器\"><a class=\"markdownIt-Anchor\" href=\"#不可见寄存器\">#</a> 不可见寄存器</h2>\n<p>解决了一个问题，当然又会出现新的问题。<br>\n通过引入<strong> GDT</strong>，我们解决了<strong>段寄存器</strong>宽度太小无法满足保护模式需求的问题。</p>\n<p>但是每次访问内存，都要先查<strong> GDT</strong>，这是不是有点浪费 CPU 的性能了？</p>\n<p>是的，内存访问对于 CPU 而言，是很慢的行为，为了避免这种性能浪费，引入了名为<strong>描述符缓存</strong>的寄存器。<br>\n实际上，<strong>描述符缓存</strong>是不可见的，它在保护模式下是属于<strong>段寄存器</strong>的一部分。</p>\n<p>保护模式下的段寄存器，就分为了<strong>两个部分</strong>：</p>\n<ul>\n<li>段选择子\n<ul>\n<li>原先的段寄存器，可见。</li>\n</ul>\n</li>\n<li>描述符缓存\n<ul>\n<li>对段寄存器进行扩展，不可见。</li>\n</ul>\n</li>\n</ul>\n<p>虽然它不可见，无法直接操作，但是是真实存在的。</p>\n<h2 id=\"段寄存器\"><a class=\"markdownIt-Anchor\" href=\"#段寄存器\">#</a> 段寄存器</h2>\n<ul>\n<li><strong>保护模式下，将段选择子与描述符缓存部分 合称为段寄存器</strong></li>\n</ul>\n<h3 id=\"加载段寄存器\"><a class=\"markdownIt-Anchor\" href=\"#加载段寄存器\">#</a> 加载段寄存器</h3>\n<p>在<strong>加载段选择子</strong>时，CPU 会通过我们给定的段选择子，查询 GDT，得到描述符。</p>\n<p>解析描述符，将字段填入<strong>描述符缓存</strong>中。</p>\n<p>未来每次发生内存访问，都不会去查询 GDT，而是直接从<strong>描述符缓存</strong>中获取字段。</p>\n<p>那么，段选择子是由谁加载的呢？为什么我们平时没有见到过相关的代码呢？<br>\n我们可以在 windows 下打开随意 x64dbg、od 之类的调试器，拖入一个程序，就可以看到，段选择子是存在初始值的，而加载的工作是由操作系统负责的。<br>\n我们也应该明白，所谓的<strong>加载段选择子</strong>，实际上也是<strong>加载描述符缓存</strong>，合称为<strong>加载段寄存器</strong>。</p>\n<h2 id=\"访问内存-2\"><a class=\"markdownIt-Anchor\" href=\"#访问内存-2\">#</a> 访问内存</h2>\n<p>至此，我们可以将上一节的设想进行改进：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov eax, dword ptr ds:[0x12345678]</span><br></pre></td></tr></table></figure>\n<ol>\n<li><strong>逻辑地址</strong>是<strong> 0x12345678</strong>；</li>\n<li>汇编指令中指定使用的段寄存器是 <strong>ds</strong>；</li>\n<li>从<strong>描述符缓存</strong>中取得<strong> Base</strong> 字段</li>\n<li><strong>ds.Base</strong> + <strong>逻辑地址</strong> = <strong>线性地址</strong>；</li>\n<li>通过<strong>线性地址</strong>访问内存。</li>\n</ol>\n<h1 id=\"访问控制\"><a class=\"markdownIt-Anchor\" href=\"#访问控制\">#</a> 访问控制</h1>\n<p>那么，说了这么久保护，究竟应该怎样才能做到所谓的保护呢？</p>\n<p>在第 5 节我们简单提及了权限的建立，通过为不同的段设置权限级别，以<strong>控制不同程序对内存的访问</strong>。</p>\n<h2 id=\"特权级划分\"><a class=\"markdownIt-Anchor\" href=\"#特权级划分\">#</a> 特权级划分</h2>\n<p>接下来咱们想一下，既然是权限，那自然是有高有低，就像身份一样，我是排长，你是士卒，那我的级别自然就比你高。</p>\n<p>接下来我们尝试用两个数字表示两种权限级别：</p>\n<ul>\n<li>0\n<ul>\n<li>最高权限级别，表示当前的 CPU 是以<strong>系统</strong>身份在跑的，操作系统运行在此级别下；</li>\n</ul>\n</li>\n<li>3\n<ul>\n<li>最低权限级别，表示当前的 CPU 是以<strong>用户</strong>身份在跑的，应用程序运行在此级别下。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"再次构思\"><a class=\"markdownIt-Anchor\" href=\"#再次构思\">#</a> 再次构思</h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">地址</th>\n<th style=\"text-align:left\">程序</th>\n<th style=\"text-align:left\">基地址 (Base)</th>\n<th style=\"text-align:left\">访问此段需要权限 (DPL)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">0x00 ~ 0x3f</td>\n<td style=\"text-align:left\">提供给操作系统内核存放数据</td>\n<td style=\"text-align:left\">0x00</td>\n<td style=\"text-align:left\">0</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">0x40 ~ 0x7f</td>\n<td style=\"text-align:left\">提供给操作系统内核存放代码</td>\n<td style=\"text-align:left\">0x40</td>\n<td style=\"text-align:left\">0</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">0x80 ~ 0xcf</td>\n<td style=\"text-align:left\">提供给程序 A 存放数据</td>\n<td style=\"text-align:left\">0x80</td>\n<td style=\"text-align:left\">3</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">0xd0 ~ 0xff</td>\n<td style=\"text-align:left\">提供给程序 A 存放代码</td>\n<td style=\"text-align:left\">0xd0</td>\n<td style=\"text-align:left\">3</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">…</td>\n<td style=\"text-align:left\">…</td>\n<td style=\"text-align:left\">…</td>\n<td style=\"text-align:left\">…</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>内核是指操作系统驻留在内存中的最基本的部分。</p>\n</blockquote>\n<ul>\n<li>同时，我们已经学习过段描述符了，<strong>段基址</strong>是放到段描述符中的，那么<strong>访问权限</strong>自然也可以放到段描述符中。</li>\n</ul>\n<h2 id=\"基本控制\"><a class=\"markdownIt-Anchor\" href=\"#基本控制\">#</a> 基本控制</h2>\n<p>假定我是 CPU，此刻我的 ip 指针指向了应用程序中的指令序列，并且我的<strong>当前身份是用户</strong>。<br>\n一旦我试图<strong>访问我不应该访问的内存</strong> (如提供给操作系统内核存放数据的段)，因为我没有那么高的特权，<strong>就应当受到制止。</strong></p>\n<h3 id=\"表明当前程序的身份\"><a class=\"markdownIt-Anchor\" href=\"#表明当前程序的身份\">#</a> 表明当前程序的身份</h3>\n<p>既然我们知道，访问内存中的段增加了一项对权限的例行检查，那么自然就需要有一项能表示我们当前身份的东西了。</p>\n<h3 id=\"dpl\"><a class=\"markdownIt-Anchor\" href=\"#dpl\">#</a> DPL</h3>\n<p>组成段描述符的字段之一，表明段描述符的特权级，访问该段应具备的权限。</p>\n<ul>\n<li>Descriptor Privilege Level，描述符特权级</li>\n</ul>\n<h3 id=\"rpl\"><a class=\"markdownIt-Anchor\" href=\"#rpl\">#</a> RPL</h3>\n<p>还记得我们之前学过的段选择子吗？当时我们只说了，段选择子用于从 GDT 中选择段描述符并加载，实际上，段选择子一共有 16bit，其中高 13bit，才是 GDT 的索引。</p>\n<p>在段选择子中，低 3bit 是另作他用的，其中低 2bit，用于表示 CPU 加载段描述符时的请求权限。</p>\n<ul>\n<li><strong>即 RPL，Requested Privilege Level ，请求特权级</strong></li>\n</ul>\n<p><strong>意为发起访问请求时的特权级</strong></p>\n<h3 id=\"cpl\"><a class=\"markdownIt-Anchor\" href=\"#cpl\">#</a> CPL</h3>\n<p>cs 段选择子与 ss 段选择子的 RPL 字段。</p>\n<ul>\n<li><strong>又称为 CPL，Current Privilege Level，当前特权级</strong></li>\n</ul>\n<h3 id=\"示例\"><a class=\"markdownIt-Anchor\" href=\"#示例\">#</a> 示例</h3>\n<ul>\n<li>接下来我们通过使用机密文档来举个栗子，尝试理解它。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">文档</th>\n<th style=\"text-align:center\">最低阅读准许级别</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">文档 A</td>\n<td style=\"text-align:center\">排长</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">文档 B</td>\n<td style=\"text-align:center\">连长</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>\n<p>首先，假定军官可以申请阅读机密文档，并且每个机密文档都有对应的权限要求；</p>\n</li>\n<li>\n<p>又假定我是排长，想阅读排长级别才能阅读的机密文件，于是我写了一份申请报告 (请求)，上面写着 **“排长级别”<strong>，并且对审核人员说，我希望能阅读</strong>文档 A**，审核人员在查看了报告上的请求级别，再与文档 A 的级别进行比较，如果报告上的级别达到了文档 A 的阅读准许级别，审核人员则会批准，我就可以阅读了。</p>\n</li>\n<li>\n<p>但是当我想阅读具有连长身份才能阅读的机密文档时，于是我依旧提交申请报告，填写 **“排长级别”<strong>，并告诉他我希望阅读</strong>文档 B**，负责审批的人一看，你这不对啊，你这申请报告上写的是排长级别，但你想阅读的文档是连长级别才能阅读的机密文档，拒绝也就是理所当然的事。</p>\n</li>\n</ul>\n<blockquote>\n<p>此处 以军官的身份与阅读机密文件进行比喻 仅出于个人认为易于理解的想法，无其他意义，我尊敬军人，热爱祖国。</p>\n</blockquote>\n<p><strong>既然有 RPL 了，那么为什么要多此一举，弄出来一个 CPL，这个 CPL 又是个什么东西呢？</strong></p>\n<p>在上面我们强调的是<strong>请求</strong>，那么为什么要划分<strong>请求</strong>和<strong>当前</strong>呢？</p>\n<p>就好比阅读机密文档，需要有足够的身份，才能拥有对应的权限。</p>\n<ul>\n<li>请求\n<ul>\n<li>即我希望阅读的机密文档的级别；</li>\n</ul>\n</li>\n<li>当前\n<ul>\n<li>表示我现在的身份。</li>\n</ul>\n</li>\n</ul>\n<p>如果没有对<strong>当前身份</strong>的检查，那么即便我是排长，我也可以<strong>提交一个 &quot;连长级别&quot; 的申请报告</strong>。</p>\n<ul>\n<li><strong>只校验请求是不够的，更重要的是当前的身份</strong>。</li>\n</ul>\n<blockquote>\n<p>程序的运行是依赖于 CPU 的，而 CPU 通过 CPL，辨认当前被 CPU 取指执行的程序的身份；通过 RPL，确定当前程序发起的请求时指定的特权级。</p>\n</blockquote>\n<p>可能有的同学又要发炎啦，啊那我直接看身份级别不就行了，为什么还要多此一举，弄出来一个请求级别。</p>\n<h3 id=\"arpl\"><a class=\"markdownIt-Anchor\" href=\"#arpl\">#</a> ARPL</h3>\n<p>咱们再看一个例子，假设我有一个朋友，他是团长，在平时我抽不开身的时候，就干脆让他帮我递交<strong>申请报告</strong>，并且告诉他我想查看什么文档，让他替我带回文档。</p>\n<p>而 RPL 的意义在于此，假设我想阅读<strong>文档 B</strong>，但是我转交给他的申请报告写的是 &quot;排长级别&quot;，就算他<strong>以团长的身份递交申请报告，因为申请报告中填写的级别不足，依旧会被拒绝</strong>。</p>\n<p>这个时候新的问题又来了，如果我转交给他的是一个 &quot;连长级别&quot; 的申请报告呢？这个时候的检查工作就落在团长的身上，他必须<strong>先检查我的身份和我的申请报告</strong>，如果我的申请报告与我的身份存在问题，那么他就会将我递交的申请报告进行修改，虽然他依旧会原样传达我的话 (我想阅读<strong>文档 B</strong>)，但是审核人员可以通过查阅申请报告，以及团长传递的话，从而选择拒绝与否。</p>\n<h4 id=\"检查工作\"><a class=\"markdownIt-Anchor\" href=\"#检查工作\">#</a> 检查工作</h4>\n<p>而这个检查与修改的过程就是 ARPL 指令所做的工作</p>\n<ul>\n<li>\n<p>我们的<strong>应用 (连长)<strong> 委托</strong>操作系统 (团长)<strong> 访问指定的</strong>段 (机密文档)</strong>；</p>\n</li>\n<li>\n<p>应用的<strong> RPL (申请报告)</strong>，以及应用的<strong> CPL (身份)</strong>，<strong>操作系统</strong>通过 ARPL 指令进行校验以及修改，以保证操作系统不会不小心替应用访问了不应该访问的段。</p>\n</li>\n<li>\n<p>最后由<strong> cpu (审核员)<strong> 检查段的访问权限</strong> DPL (机密文档的阅读权限)</strong>；</p>\n</li>\n<li>\n<p><strong>而 应用是如何委托操作系统 等内容，请在学习权限切换后，再次回来复习。</strong></p>\n</li>\n</ul>\n<h1 id=\"权限检查\"><a class=\"markdownIt-Anchor\" href=\"#权限检查\">#</a> 权限检查</h1>\n<p>我们讲述了基于段机制的内存访问是如何受到控制的。</p>\n<p>我想，各位看完之后依旧会存在不少疑惑，比如所谓的<strong>访问</strong>，对权限的检查，具体是发生在什么时候呢？</p>\n<h2 id=\"段的分类\"><a class=\"markdownIt-Anchor\" href=\"#段的分类\">#</a> 段的分类</h2>\n<p>我们知道，由地址上连续的多个内存单元组织而成的内存区域，就可以将其称之为段。<br>\n为了减少错误的出现与降低开发难度，在实模式时，就已经开始将内存划分为多个段，并且根据用途为段进行了分类。</p>\n<p>在前面的笔记我们粗略提及过段的分类，本篇再对保护模式下的段的分类进行讲述。</p>\n<h2 id=\"实模式\"><a class=\"markdownIt-Anchor\" href=\"#实模式\">#</a> 实模式</h2>\n<p>在实模式下，段的分类更偏向于程序设计者自主安排，我不强求，你想怎么安排，就可以怎么安排，重要的是哪个段寄存器指向了那块内存区域。</p>\n<p>如将 x8000 这个地址作为段的基址，我可以将其赋值给 cs，也可以将其赋值给 ds，取决于我如何使用它。</p>\n<h2 id=\"保护模式\"><a class=\"markdownIt-Anchor\" href=\"#保护模式\">#</a> 保护模式</h2>\n<p>为何我会说实模式的段分类下是程序设计者的自主安排，难道保护模式就不是了吗？<br>\n实际上，对于应用程序设计者而言，确实是的。</p>\n<p>你也许会想，实模式的段寄存器我可以随便加载，保护模式的段选择子就不可以了吗？</p>\n<p>很遗憾，应用程序设计者确实没有这么大的权限，要不为何会着重<strong>保护</strong>二字呢？</p>\n<h2 id=\"段描述符相关字段\"><a class=\"markdownIt-Anchor\" href=\"#段描述符相关字段\">#</a> 段描述符相关字段</h2>\n<p>咱们还是要看英特尔白皮书中对段描述符的解释，在往后的笔记中还会经常与它见面。</p>\n<pre><code>- &#123;% asset_img 1.png 这是一张图片 %&#125;\n</code></pre>\n<h3 id=\"s字段\"><a class=\"markdownIt-Anchor\" href=\"#s字段\">#</a> S 字段</h3>\n<ul>\n<li>S 字段为 1\n<ul>\n<li>当前段描述符描述的段是代码段或数据段</li>\n</ul>\n</li>\n<li>S 字段为 0\n<ul>\n<li>当前段描述符描述的段是系统段</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"数据段\"><a class=\"markdownIt-Anchor\" href=\"#数据段\">#</a> 数据段</h3>\n<p>数据段是指用于存放数据的内存区域，向下还能再细分为<strong>只读数据段</strong>、<strong>栈段</strong>等，供 CPU 读或写。</p>\n<h3 id=\"代码段\"><a class=\"markdownIt-Anchor\" href=\"#代码段\">#</a> 代码段</h3>\n<p>代码段是指用于存放指令序列的内存区域，供 CPU 执行。</p>\n",
            "tags": [
                "保护模式",
                "Windows内核"
            ]
        },
        {
            "id": "http://yuyuaqwq.github.io/posts/4aaf.html",
            "url": "http://yuyuaqwq.github.io/posts/4aaf.html",
            "title": "【保护模式】1.初探保护模式与分段机制",
            "date_published": "2023-02-17T14:34:48.000Z",
            "content_html": "<h1 id=\"保护模式\"><a class=\"markdownIt-Anchor\" href=\"#保护模式\">#</a> 保护模式</h1>\n<ul>\n<li>保护模式是在硬件层面提供的 CPU 运行机制，是现代操作系统的根本。</li>\n<li>没有保护模式，操作系统是没有安全性可言的。</li>\n</ul>\n<h2 id=\"何为保护\"><a class=\"markdownIt-Anchor\" href=\"#何为保护\">#</a> 何为保护</h2>\n<ul>\n<li>\n<p>指令是存放在内存中的</p>\n</li>\n<li>\n<p>假定你的程序试图对操作系统的关键代码进行破坏：</p>\n<ul>\n<li><code>mov byte ptr ds:[kernel], 0x90</code></li>\n</ul>\n</li>\n<li>\n<p>操作系统应该如何制止？</p>\n</li>\n<li>\n<p>也许这个时候有同学发炎了：</p>\n<ul>\n<li>“也许操作系统它能监控呢？”</li>\n</ul>\n</li>\n<li>\n<p>答案是，监控你程序的并不是操作系统，这种工作必须在硬件层完成</p>\n<ul>\n<li>很简单的道理，实际上运行指令的是 CPU，只有 CPU 知道当前 CPU 正在做什么事，操作系统是不可能知道的\n<ul>\n<li>操作系统也是由 CPU 运行的指令序列。</li>\n</ul>\n</li>\n<li>除非 CPU 提供了一种回调机制，运行任何指令都先运行操作系统的指令，但这是不现实的，对性能影响过于严重\n<ul>\n<li>实现一套虚拟机也可以保证安全性，但是依旧存在性能问题，也不在本文讨论范围之内。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"模式之分\"><a class=\"markdownIt-Anchor\" href=\"#模式之分\">#</a> 模式之分</h2>\n<ul>\n<li>\n<p>我们得到了结论，保证 操作系统的安全性 这种机制，必须是硬件提供的。</p>\n<ul>\n<li>在早期，CPU 并未提供这种保护模式，为此才划分出了 “实模式” 与 “保护模式”</li>\n<li>在保护模式出现时，为了兼容，因此也诞生了 “虚拟 8086 模式”，但已经不重要了，也不在本文讨论范围内。</li>\n</ul>\n</li>\n<li>\n<p><strong>在学习保护模式时也需要牢记，保护模式是硬件层的东西，切勿与操作系统混淆。</strong></p>\n</li>\n</ul>\n<h1 id=\"物理内存\"><a class=\"markdownIt-Anchor\" href=\"#物理内存\">#</a> 物理内存</h1>\n<ul>\n<li>我们都知道，我们可见的物理内存，其实就是<strong>连续的、对每一个单元进行了地址编号的很大的存储器。</strong></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">地址</th>\n<th style=\"text-align:left\">数据</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">0x00</td>\n<td style=\"text-align:left\">0xff</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">0x01</td>\n<td style=\"text-align:left\">0x00</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">…</td>\n<td style=\"text-align:left\">…</td>\n</tr>\n</tbody>\n</table>\n<p><em>表格仅为举例，与真实物理内存布局无关</em></p>\n<ul>\n<li>\n<p>程序必须是存放在内存中，才能被 CPU<strong> 取指执行</strong>。</p>\n</li>\n<li>\n<p>假定你是操作系统 (给你管理硬件资源)，那么多个程序又如何存放比较好呢？</p>\n</li>\n</ul>\n<hr>\n<h2 id=\"多个程序的安置\"><a class=\"markdownIt-Anchor\" href=\"#多个程序的安置\">#</a> 多个程序的安置</h2>\n<ul>\n<li>可能有同学回答了：\n<ul>\n<li>我<strong>顺序加载</strong>嘛，第一个程序从哪里占用到哪里，第二个程序从哪里占用到哪里</li>\n</ul>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">地址</th>\n<th style=\"text-align:left\">程序</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">0x00 ~ 0x7f</td>\n<td style=\"text-align:left\">提供给程序 A</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">0x80 ~ 0xff</td>\n<td style=\"text-align:left\">提供给程序 B</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">…</td>\n<td style=\"text-align:left\">…</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>\n<p>如表格所述，我们成功将两个程序分别放到了不同的位置。</p>\n</li>\n<li>\n<p>这样子他们就互不干扰了，我们真是个小天才。</p>\n</li>\n</ul>\n<h2 id=\"问题仍在\"><a class=\"markdownIt-Anchor\" href=\"#问题仍在\">#</a> 问题仍在</h2>\n<ul>\n<li>\n<p>很遗憾，这样子的程序，运行依旧存在困难</p>\n<ul>\n<li>在编写程序的时候，无法预知程序在运行时究竟会被加载到内存的哪个位置。</li>\n<li>假设<strong> B</strong> 选择 <code>0x40</code>  这个地址存放一些数据，那不是正好破坏了<strong> A</strong> 的指令序列？</li>\n</ul>\n</li>\n<li>\n<p>为此，<strong>内存分段</strong>诞生了</p>\n</li>\n</ul>\n<hr>\n<h1 id=\"内存分段\"><a class=\"markdownIt-Anchor\" href=\"#内存分段\">#</a> 内存分段</h1>\n<ul>\n<li>\n<p>如果我们在编写程序的时候，任何使用内存的指令，填写的内存地址，都是一个<strong>偏移值</strong>，让 CPU 替我们去与<strong>基地址</strong>相加，最终得到真正的<strong>物理地址</strong>。</p>\n</li>\n<li>\n<p>那么不管我们的程序被加载到内存的哪个位置，只要提供一个正确的<strong>基地址</strong>，就可以让多个程序互不干扰了！</p>\n</li>\n</ul>\n<h2 id=\"示例\"><a class=\"markdownIt-Anchor\" href=\"#示例\">#</a> 示例</h2>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">地址</th>\n<th style=\"text-align:left\">程序</th>\n<th style=\"text-align:left\">基地址</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">0x00 ~ 0x7f</td>\n<td style=\"text-align:left\">提供给程序 A</td>\n<td style=\"text-align:left\">0x00</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">0x80 ~ 0xff</td>\n<td style=\"text-align:left\">提供给程序 B</td>\n<td style=\"text-align:left\">0x80</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">…</td>\n<td style=\"text-align:left\">…</td>\n<td style=\"text-align:left\">…</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>\n<p>假设<strong> B</strong> 选择 <code>0x40</code>  这个地址存放一些数据，我们还会破坏<strong> A</strong> 的指令序列吗？</p>\n</li>\n<li>\n<p>这样看上去，是不是像给<strong>内存分段</strong>了一样？</p>\n<ul>\n<li><code>0x00 ~ 0x7f</code>  看作一段，分给<strong>程序 A</strong></li>\n<li><code>0x80 ~ 0xff</code>  看作一段，分给<strong>程序 B</strong></li>\n</ul>\n</li>\n</ul>\n<hr>\n<p>实模式下的分段机制大抵如此。</p>\n<h1 id=\"段寄存器\"><a class=\"markdownIt-Anchor\" href=\"#段寄存器\">#</a> 段寄存器</h1>\n<ul>\n<li>\n<p>想来各位读者对寄存器都有所了解，既然我们需要一个容器来存放<strong>段的基地址</strong>，寄存器自然是不错的选择。</p>\n</li>\n<li>\n<p>但是通用寄存器本身数量也不够多，再想腾出来存放<strong>段基址</strong>，也是心有余而力不足了。</p>\n</li>\n<li>\n<p>因此，理所当然的，就有了以<strong>段</strong>为名的<strong>段寄存器</strong>。</p>\n</li>\n</ul>\n<h2 id=\"ds寄存器\"><a class=\"markdownIt-Anchor\" href=\"#ds寄存器\">#</a> ds 寄存器</h2>\n<ul>\n<li>ds，即 data segment，意为数据段</li>\n<li>咱们一看就知道，这个东西就是和<strong>数据</strong>、<strong>段</strong> 相关的。</li>\n<li>它也十分简单，16 位的宽度，作用就是存放数据段的基址</li>\n</ul>\n<blockquote>\n<p>注解</p>\n<blockquote>\n<p>实际在实模式下，物理地址的转换公式略微复杂一些<br>\n (ds &lt;&lt; 4) + address = 最终的物理地址</p>\n</blockquote>\n</blockquote>\n<h3 id=\"结合先前的示例\"><a class=\"markdownIt-Anchor\" href=\"#结合先前的示例\">#</a> 结合先前的示例</h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">地址</th>\n<th style=\"text-align:left\">程序</th>\n<th style=\"text-align:left\">基地址</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">0x00 ~ 0x7f</td>\n<td style=\"text-align:left\">提供给程序 A</td>\n<td style=\"text-align:left\">0x00</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">0x80 ~ 0xff</td>\n<td style=\"text-align:left\">提供给程序 B</td>\n<td style=\"text-align:left\">0x80</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">…</td>\n<td style=\"text-align:left\">…</td>\n<td style=\"text-align:left\">…</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>我们选择让<strong> B</strong> 在 <code>0x40</code>  这个位置存放一些数据</li>\n<li>而现在我们有了 ds 寄存器，只要在程序运行前初始化 ds 寄存器，就可以做到不破坏<strong> A</strong> 的程序了。</li>\n</ul>\n<h2 id=\"根据段的用途进行划分\"><a class=\"markdownIt-Anchor\" href=\"#根据段的用途进行划分\">#</a> 根据段的用途进行划分</h2>\n<ul>\n<li>但是这样子明显我们还需要小心翼翼，毕竟虽然不会破坏其他程序了，但不代表不会破坏自己的指令序列啊！</li>\n<li><strong>代码</strong>和<strong>数据</strong>都放在一个段里，是不是不便管理？</li>\n<li>如果我们对代码和数据再做进一步的<strong>划分</strong>，是不是更好？</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">地址</th>\n<th style=\"text-align:left\">程序</th>\n<th style=\"text-align:left\">基地址</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">0x00 ~ 0x3f</td>\n<td style=\"text-align:left\">提供给程序 A 存放数据</td>\n<td style=\"text-align:left\">0x00</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">0x40 ~ 0x7f</td>\n<td style=\"text-align:left\">提供给程序 A 存放代码</td>\n<td style=\"text-align:left\">0x40</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">0x80 ~ 0xcf</td>\n<td style=\"text-align:left\">提供给程序 B 存放数据</td>\n<td style=\"text-align:left\">0x80</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">0xd0 ~ 0xff</td>\n<td style=\"text-align:left\">提供给程序 B 存放代码</td>\n<td style=\"text-align:left\">0xd0</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">…</td>\n<td style=\"text-align:left\">…</td>\n<td style=\"text-align:left\">…</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>\n<p>为此，自然是可以存在更多的段寄存器</p>\n<ul>\n<li>cs(code segment)</li>\n<li>ss(stack segment)</li>\n<li>ds(data segment)</li>\n<li>…</li>\n</ul>\n</li>\n<li>\n<p>还是先前的问题，程序<strong> B</strong> 试图在 <code>0x40</code>  这个地址存放数据，我们只需要让 cpu 知道，<strong>数据段基址</strong>是 <code>0x80</code></p>\n<ul>\n<li><code>0x80 + 0x40 = 0xc0</code></li>\n</ul>\n</li>\n<li>\n<p>我们只需要划分好各个段，就可以很好的让程序工作了！</p>\n</li>\n</ul>\n<h2 id=\"cpu对内存的访问\"><a class=\"markdownIt-Anchor\" href=\"#cpu对内存的访问\">#</a> CPU 对内存的访问</h2>\n<ul>\n<li>为此，cpu 也被设计为，在<strong>访问任何汇编指令中显式书写的内存地址时</strong>，都会先根据<strong>用途</strong>选择<strong>段寄存器</strong>，得到<strong>段基地址</strong>，<strong>指令中的地址</strong>视作<strong>偏移 (逻辑地址)</strong>，<strong>运算后</strong>得到<strong>真正的物理地址</strong>，再进行<strong>访问</strong>。</li>\n</ul>\n<blockquote>\n<p>注解</p>\n<blockquote>\n<p>读写内存，可以划分为对数据段的访问<br>\n执行指令，可以划分为对代码段的访问<br>\n…</p>\n</blockquote>\n</blockquote>\n<h1 id=\"初探基于段的保护\"><a class=\"markdownIt-Anchor\" href=\"#初探基于段的保护\">#</a> 初探基于段的保护</h1>\n<ul>\n<li>\n<p>在实模式下，对于任何存在于内存中的指令序列，cpu 是<strong>一视同仁</strong>的，ip 指哪它跑哪，埋头苦干。</p>\n</li>\n<li>\n<p>操作系统将我们的程序加载到内存，使得 cs:ip 指向我们程序的入口点之后，<strong>我们想干什么，就不是操作系统能说了算了</strong>。</p>\n<ul>\n<li>当然我们也可以反手来一波背刺，<strong>捅死操作系统</strong>。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"尝试分段\"><a class=\"markdownIt-Anchor\" href=\"#尝试分段\">#</a> 尝试分段</h2>\n<ul>\n<li>\n<p>你可能想到了，啊，我们先前不是才讲过，分段不就好了吗？</p>\n</li>\n<li>\n<p>其实所谓的分段，也是建立在大家都<strong>规规矩矩</strong>，<strong>和睦相处</strong>的情况下，才能最大程度上避免 &quot;不小心&quot; 出现的问题。</p>\n<ul>\n<li>简单地说，全看编写程序的人自觉不自觉。</li>\n<li>既然操作系统能<strong>修改 cs、ds 段寄存器</strong>，我们有何不可呢？</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"权限的建立\"><a class=\"markdownIt-Anchor\" href=\"#权限的建立\">#</a> 权限的建立</h2>\n<ul>\n<li>\n<p>首先，咱们既然要保证<strong>安全</strong>，那自然就要划分哪些是应用能做的，哪些是应用不能做的。</p>\n</li>\n<li>\n<p>其次，总归要有程序去管理软硬件的，操作系统的不受限制也理所应当了。</p>\n</li>\n</ul>\n<h3 id=\"权限划分\"><a class=\"markdownIt-Anchor\" href=\"#权限划分\">#</a> 权限划分</h3>\n<ul>\n<li>\n<p>既然有了<strong>不能做</strong>和<strong>能做</strong>之分，并且还有了 &quot;区别对待&quot;，<strong>权限</strong>自然也就建立起来了。</p>\n</li>\n<li>\n<p>至此，咱们初步确定了<strong>权限</strong>的划分。</p>\n<ul>\n<li>常规应用，拥有<strong>部分权限</strong>；</li>\n<li>操作系统，拥有<strong>所有权限</strong>。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"段机制的延展\"><a class=\"markdownIt-Anchor\" href=\"#段机制的延展\">#</a> 段机制的延展</h2>\n<ul>\n<li>\n<p>咱们最先想到的，最不能让应用去乱搞的是什么呢？</p>\n</li>\n<li>\n<p>首先就是不能让应用去破坏咱们的操作系统，咱们首先要把自己<strong>保护</strong>起来。</p>\n<ul>\n<li><strong>如果应用能随意修改操作系统的指令序列，那么所谓的保护将毫无意义</strong>。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"初步构想\"><a class=\"markdownIt-Anchor\" href=\"#初步构想\">#</a> 初步构想</h3>\n<ul>\n<li>\n<p>我们可以沿用实模式下存在的段机制，为段设立权限。</p>\n<ul>\n<li>应用的指令序列处在一个<strong>权限受限</strong>的段中，<strong>不允许访问除自己段内的任何内存。</strong></li>\n</ul>\n</li>\n<li>\n<p>而操作系统就处在拥有<strong>最高特权</strong>的段中，<strong>掌有生杀大权</strong>。</p>\n</li>\n</ul>\n",
            "tags": [
                "保护模式",
                "Windows内核"
            ]
        },
        {
            "id": "http://yuyuaqwq.github.io/posts/41fe.html",
            "url": "http://yuyuaqwq.github.io/posts/41fe.html",
            "title": "【保护模式】x64下定位随机页表基址的思路",
            "date_published": "2022-12-02T08:21:05.000Z",
            "content_html": "<h1 id=\"前言\"><a class=\"markdownIt-Anchor\" href=\"#前言\">#</a> 前言</h1>\n<p><em>昨天在看周哥讲 x64 内核的时候，得知了 windows10 的某个版本开始，页表基址不再固定了。</em><br>\n<em>今天晚上突然有了个思路，就动手把他敲出来了，这种思路是不是已经烂大街了我也不确定，就当发出来学习交流吧。</em></p>\n<h1 id=\"随机页表基址原理\"><a class=\"markdownIt-Anchor\" href=\"#随机页表基址原理\">#</a> 随机页表基址原理</h1>\n<p>这里用 x86 的 10-10-12 分页举例吧，比较好理解，理解了 x64 的也差不多的</p>\n<p>启用了保护模式和分页机制后，咱就不能直接访问物理地址了，都会被 MMU 当作虚拟地址进行转换。</p>\n<p>但是 cr3 存的又是物理地址，不能直接操作页表了，那咋办呢？</p>\n<p>聪明的前辈们，选择在页目录表中选择一项 (共 1024 项，每一项 4 字节)，使其存储的物理地址与页目录表的基址 (cr3) 相同，这样子就可以构造一个访问页表的虚拟地址了，大概就是<strong>让 cpu 在地址转换的过程中绕圈圈</strong>。</p>\n<ul>\n<li>画个图吧</li>\n<li>\n<img src=\"/posts/41fe/1.png\" class=\"\" title=\"这是一张图片\">\n</li>\n</ul>\n<h2 id=\"定位思路\"><a class=\"markdownIt-Anchor\" href=\"#定位思路\">#</a> 定位思路</h2>\n<ul>\n<li>x64 也必然是随机选择 PXT 的其中一项 PXE 来存储 PXT 的物理地址，实现的随机页表基址</li>\n<li>那么就可以通过<strong>构造所有可能指向 PXT 的虚拟地址 (共 512 项)</strong>，转换为物理地址，再与 cr3 比较，最终得到正确的 PXT 基址。</li>\n<li>只要知道了存储 PXT 的物理地址的 PXE 的 PXI，构造 PPT/PDT/PTT 基址都很简单了</li>\n</ul>\n<h1 id=\"实现\"><a class=\"markdownIt-Anchor\" href=\"#实现\">#</a> 实现</h1>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">PVOID <span class=\"title\">GetPXTBase</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tUINT64 cr3 = __readcr3();</span><br><span class=\"line\">\t<span class=\"built_in\">KdPrint</span>((<span class=\"string\">&quot;yuyu:cr3:%p\\n&quot;</span>, cr3));</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (UINT64 i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">512</span>; i++) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 通过PXI构造虚拟地址</span></span><br><span class=\"line\">\t\tPVOID pxtBase = (PVOID)(<span class=\"number\">0xffff000000000000</span> | (i &lt;&lt; <span class=\"number\">12</span>) | (i &lt;&lt; <span class=\"number\">21</span>) | (i &lt;&lt; <span class=\"number\">30</span>) | (i &lt;&lt; <span class=\"number\">39</span>));</span><br><span class=\"line\">\t\tPHYSICAL_ADDRESS physical = <span class=\"built_in\">MmGetPhysicalAddress</span>(pxtBase);</span><br><span class=\"line\">\t\t<span class=\"built_in\">KdPrint</span>((<span class=\"string\">&quot;yuyu:i:%d 物理:%p 虚拟:%p\\n&quot;</span>, i, physical.QuadPart, pxtBase));</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (cr3 == physical.QuadPart) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> pxtBase;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>\n<img src=\"/posts/41fe/2.png\" class=\"\" title=\"这是一张图片\">\n</li>\n</ul>\n<h1 id=\"结尾\"><a class=\"markdownIt-Anchor\" href=\"#结尾\">#</a> 结尾</h1>\n<p>理解有限，如有错误，还请指正</p>\n<h1 id=\"2022514补充\"><a class=\"markdownIt-Anchor\" href=\"#2022514补充\">#</a> 2022/5/14 补充</h1>\n<ul>\n<li>其实除开这个之外，我先想到的是另一个思路，即<strong>构造所有可能存储 PXT 的物理地址的 PXE 的虚拟地址</strong>。\n<ul>\n<li>依旧是 512 项，探测地址是否可访问，读取 8 字节；</li>\n<li>将其当作 PXE，取出物理页面基址，再与 cr3 进行比较。</li>\n</ul>\n</li>\n<li>但是这种方法有概率出现问题，即存放的数据可能正好与 cr3 相同，但所在页面并不是 PXT。\n<ul>\n<li>因此我就没有写出来，不过我想了一下，还是贴出来了，也算是一种思路嘛。</li>\n</ul>\n</li>\n</ul>\n",
            "tags": [
                "保护模式",
                "Windows内核"
            ]
        }
    ]
}