<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title>鹿鹿鱼鱼 • Posts by &#34;编译原理&#34; category</title>
        <link>http://yuyuaqwq.github.io</link>
        <description>人为什么要起床？</description>
        <language>zh-CN</language>
        <pubDate>Fri, 28 Oct 2022 23:01:12 +0800</pubDate>
        <lastBuildDate>Fri, 28 Oct 2022 23:01:12 +0800</lastBuildDate>
        <category>MFC</category>
        <category>没饭吃</category>
        <category>逆向分析</category>
        <category>工具</category>
        <category>C/C++</category>
        <category>反汇编</category>
        <category>网络分析</category>
        <category>Proxifier</category>
        <category>编译原理</category>
        <category>动手写ToyLang</category>
        <item>
            <guid isPermalink="true">http://yuyuaqwq.github.io/posts/56ac.html</guid>
            <title>【动手写ToyLang】1.从四则运算表达式开始</title>
            <link>http://yuyuaqwq.github.io/posts/56ac.html</link>
            <category>编译原理</category>
            <category>动手写ToyLang</category>
            <pubDate>Fri, 28 Oct 2022 23:01:12 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;编译原理&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#编译原理&#34;&gt;#&lt;/a&gt; 编译原理&lt;/h1&gt;
&lt;p&gt;如果你曾经接触过《编译原理》的话，不知道是否与我有着同样的困惑呢？&lt;/p&gt;
&lt;p&gt;各种不近人情的名词，公式乱飞，这让我学习起来格外痛苦。&lt;/p&gt;
&lt;p&gt;我在尝试阅读过不少文章、书籍，动手之后，才逐渐理解了一些比较关键的东西。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;实际上，当我真正自己动手完成了对四则运算表达式的解析的那一刻，我才真切感受到了编译原理的优雅与美妙之处，这大概就是由无数人智慧造就的伟大吧 (偏得有点远了)。&lt;/em&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;初尝构思&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#初尝构思&#34;&gt;#&lt;/a&gt; 初尝构思&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;现在，我来尝试给你出一道题吧，请你用你所熟悉的语言，编写一个模块：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;输入符合四则运算表达式规范的字符串 (可以假定只有整数，不存在括号)；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;输出整型结果；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;要求关键逻辑由自己实现，不可借由库、语言本身提供的功能。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;你能实现吗？&lt;/p&gt;
&lt;p&gt;是否觉得脑子有些空白，难以组织成较为优雅的实现思路呢？&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;如果你现在就能想到很棒的解法，那至少你要比我厉害多了。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我曾经因为某些需求做过尝试，虽然最后写出来了，但是具体实现也非常丑陋，这里就不献丑了。&lt;/p&gt;
&lt;p&gt;但是我可以给你大致描述一下我当初的思路：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;首先，查找字符串中优先级较高的运算符  &lt;code&gt;*&lt;/code&gt;   &lt;code&gt;/&lt;/code&gt; ，再前 / 后瞻运算符前后的数字，这个子串也能形成一个表达式；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;算出结果后，在原表达式中，用结果替换掉子串 (刚刚被计算的表达式)，再继续查找。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;完成后再从头开始查找优先级更低一级的运算符 &lt;code&gt;+&lt;/code&gt;   &lt;code&gt;-&lt;/code&gt; ，直到运算完成。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;当然，我们不会用这么低效的方法，也不会要求你真的写出来。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;现在提出来，也不是为了为难你，只是为了让你记住眼下的感觉，当你学完本系列文章后，再回来看看，这一道题，是否真的有那么难呢？&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;抽象语法树&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#抽象语法树&#34;&gt;#&lt;/a&gt; 抽象语法树&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;在计算机科学中，抽象语法树（Abstract Syntax Tree，AST），或简称&lt;a href=&#34;https://baike.baidu.com/item/%E8%AF%AD%E6%B3%95%E6%A0%91/7031301?fromModule=lemma_inlink&#34;&gt;语法树&lt;/a&gt;（Syntax tree），是&lt;a href=&#34;https://baike.baidu.com/item/%E6%BA%90%E4%BB%A3%E7%A0%81?fromModule=lemma_inlink&#34;&gt;源代码&lt;/a&gt;&lt;a href=&#34;https://baike.baidu.com/item/%E8%AF%AD%E6%B3%95?fromModule=lemma_inlink&#34;&gt;语法&lt;/a&gt;结构的一种抽象表示。它以树状的形式表现&lt;a href=&#34;https://baike.baidu.com/item/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80?fromModule=lemma_inlink&#34;&gt;编程语言&lt;/a&gt;的语法结构，树上的每个节点都表示源代码中的一种结构。---- 摘自百度百科&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;嗯… 不愧是名字就带着抽象的东西，连说明都这么抽象。&lt;/p&gt;
&lt;p&gt;咱们先不整那么多虚头巴脑的，干就完了。&lt;/p&gt;
&lt;h2 id=&#34;构造四则运算表达式的ast&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#构造四则运算表达式的ast&#34;&gt;#&lt;/a&gt; 构造四则运算表达式的 AST&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;3 + 2&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这个是大家熟悉的算术表达式，实际上，我们人脑是如何计算这个表达式的呢？当然需要遵循某些规则：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;先乘除&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;再加减&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;从左往右结合&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;那我们自然是需要先&lt;strong&gt;左往右找&lt;/strong&gt;在表达式中找到 &lt;code&gt;*&lt;/code&gt; 、 &lt;code&gt;/&lt;/code&gt;  两种符号，好消息是，没有，嘿嘿。&lt;/p&gt;
&lt;p&gt;接下来继续&lt;strong&gt;左往右找&lt;/strong&gt; &lt;code&gt;+&lt;/code&gt; 、 &lt;code&gt;-&lt;/code&gt; ，找到之后将其取出，这也是我们需要计算的子表达式。&lt;/p&gt;
&lt;p&gt;我们将其分成三部分，分别是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;左边的数字  &lt;code&gt;3&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;加法运算符  &lt;code&gt;+&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;右边的数字  &lt;code&gt;2&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以得到这么一棵树型结构：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;img src=&#34;/posts/56ac/1.png&#34; class=&#34;&#34; title=&#34;这是一张图片&#34;&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接下来我们遍历这棵树：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;根节点，是加法，表明需要将左子节点与右子节点相加；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;3 + 2&lt;/code&gt; ，返回结果  &lt;code&gt;5&lt;/code&gt; ；&lt;/li&gt;
&lt;li&gt;遍历结束；&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;img src=&#34;/posts/56ac/2.png&#34; class=&#34;&#34; title=&#34;这是一张图片&#34;&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;多运算符与结合律&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#多运算符与结合律&#34;&gt;#&lt;/a&gt; 多运算符与结合律&lt;/h3&gt;
&lt;p&gt;那么，当一个表达式中，存在多个运算符时，应该如何构造语法树呢？&lt;/p&gt;
&lt;p&gt;接下来我们构造表达式  &lt;code&gt;3 - 2 + 4&lt;/code&gt;  的树。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;首先我们应该注意的一点是，需要先被执行运算 (优先级更高) 的子表达式，其节点相对的，要在更底下：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;img src=&#34;/posts/56ac/3.png&#34; class=&#34;&#34; title=&#34;这是一张图片&#34;&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;还是先来遍历这颗树：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;根节点，是加法，表明需要将左子节点与右子节点相加；
&lt;ol&gt;
&lt;li&gt;左子节点是减法，表明需要用左子节点减去右子节点，需要继续向下展开；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;3 - 2&lt;/code&gt; ，返回结果  &lt;code&gt;1&lt;/code&gt; ；&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;1 + 4&lt;/code&gt; ，返回结果  &lt;code&gt;5&lt;/code&gt; ；&lt;/li&gt;
&lt;li&gt;遍历结束；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;因此，遍历的过程也符合我们所要求的 &lt;code&gt;左结合律&lt;/code&gt; ，也就是由左边的运算符开始，向右边的运算符结合。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;因为同优先级下，我们更优先计算左边的运算符组成的子表达式，&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接下来我再给你画一下另一种情况，你大概也就明白了。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;img src=&#34;/posts/56ac/4.png&#34; class=&#34;&#34; title=&#34;这是一张图片&#34;&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;你可以尝试一下遍历这棵树，会发现先被执行的一定是加法，这并不符合我们的从一开始就要求的 &lt;code&gt;左结合律&lt;/code&gt; 。&lt;br&gt;
在部分情况下，由于结合律的错误，就会产出错误的结果：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如我们本次求解的表达式，通过遍历此树得出的结果为 &lt;code&gt;-3&lt;/code&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;目标根据语法规则生成ast&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#目标根据语法规则生成ast&#34;&gt;#&lt;/a&gt; 目标：根据语法规则生成 AST&lt;/h2&gt;
&lt;p&gt;我不说你大概也已经猜到了，其实我们上面所构造的树，在当前的应用场景下，就叫做 &lt;code&gt;抽象语法树&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;并且遍历树并计算的过程，与我们人脑对表达式的计算的过程是十分相似的。&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;也就是说，我们只需要构造出这么一颗抽象语法树，就已经基本上完成了编译工作的一大半甚至全部。&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;此时，若我们需要执行编译产生的结果，只需要遍历我们所生成 AST 即可。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如下图：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;img src=&#34;/posts/56ac/5.png&#34; class=&#34;&#34; title=&#34;这是一张图片&#34;&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在遍历的过程中，我们就能够正确的完成对加法表达式的加法运算，再对赋值表达式的赋值运算。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;ast解释器&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#ast解释器&#34;&gt;#&lt;/a&gt; AST 解释器&lt;/h1&gt;
&lt;p&gt;最后，我们也确实展示了有关 &amp;quot;解释器&amp;quot; 的东西，是的，即便你难以置信。&lt;br&gt;
但是遍历这棵树的过程，可以叫做解释，完整一点就是我们所编写的 &lt;code&gt;AST解释器&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;当然，解释器是一种比较广泛的概念，即便到后面我们基于 AST 生成了字节码，交给虚拟机执行，我们的程序也依然可以称之为解释器，只不过解释的对象从 AST 换成了字节码。&lt;/p&gt;
&lt;p&gt;我个人觉得，当初造这个词的人只是为了区分所谓的 &amp;quot;编译型语言&amp;quot; 和 &amp;quot;解释型语言&amp;quot;。&lt;br&gt;
以下是百度百科对解释器的定义：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;解释器（&lt;a href=&#34;https://baike.baidu.com/item/%E8%8B%B1%E8%AF%AD/109997?fromModule=lemma_inlink&#34;&gt;英语&lt;/a&gt;：Interpreter），又译为直译器，是一种电脑程序，能够把高级&lt;a href=&#34;https://baike.baidu.com/item/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80?fromModule=lemma_inlink&#34;&gt;编程语言&lt;/a&gt;一行一行直接转译运行。解释器不会一次把整个程序转译出来，只像一位 “中间人”，每次运行程序时都要先转成另一种语言再作运行，因此解释器的程序运行速度比较缓慢。它每转译一行程序叙述就立刻运行，然后再转译下一行，再运行，如此不停地进行下去。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;此处关于 &lt;code&gt;每转译一行程序叙述就立刻运行&lt;/code&gt; 的说明也不尽然，至少现在很多被称为 &lt;code&gt;解释器&lt;/code&gt; 的程序，并非如此 (如 Python 解释器、Java 解释器等)。&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://yuyuaqwq.github.io/posts/c4d3.html</guid>
            <title>【动手写ToyLang】0.前言</title>
            <link>http://yuyuaqwq.github.io/posts/c4d3.html</link>
            <category>编译原理</category>
            <category>动手写ToyLang</category>
            <pubDate>Fri, 28 Oct 2022 21:18:53 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;关于&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#关于&#34;&gt;#&lt;/a&gt; 关于&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;本系列文章会手把手教你打造一门在别人看来是&lt;emp&gt;玩具&lt;/emp&gt;的通用计算机语言，事实也确实如此。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;但计算机本身就是一门需要动手的学科，在对基本原理有一定程度的理解之后，自己动手实践才是学习的最好的捷径，为此制造 &amp;quot;玩具&amp;quot;，并不丢人。&lt;/p&gt;
&lt;p&gt;笔者对《编译原理》这门学科的学习程度也十分有限，因此本系列文章的读者不仅仅是你们，也包括我，写下的这篇文章也是支撑我继续动手实践的动力。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;我会尽可能的查阅资料、学习，以保证输出内容的可靠性，如果还是难以避免的出现了错误，望批评指正，感激不尽。&lt;/em&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;准备工作&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#准备工作&#34;&gt;#&lt;/a&gt; 准备工作&lt;/h1&gt;
&lt;h2 id=&#34;开发语言&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#开发语言&#34;&gt;#&lt;/a&gt; 开发语言&lt;/h2&gt;
&lt;p&gt;这里我选用我个人较为常用的 C++ 作为开发语言，风格尽量以《Google C++ Style Guide》为准，在我个人能力范围内尽量写得 &amp;quot;现代 C++&amp;quot; 一点。&lt;/p&gt;
&lt;p&gt;当然，我个人也还是 C++ 彩笔，代码写得不好，还请理解。&lt;/p&gt;
&lt;h2 id=&#34;开发环境&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#开发环境&#34;&gt;#&lt;/a&gt; 开发环境&lt;/h2&gt;
&lt;p&gt;我基本上只在 Windows 上工作，因此选择自然是 &lt;code&gt;Visual Studio&lt;/code&gt; 。&lt;/p&gt;
 ]]></description>
        </item>
    </channel>
</rss>
