{
    "version": "https://jsonfeed.org/version/1",
    "title": "鹿鹿鱼鱼 • All posts by \"编译原理\" category",
    "description": "人为什么要起床？",
    "home_page_url": "http://yuyuaqwq.github.io",
    "items": [
        {
            "id": "http://yuyuaqwq.github.io/posts/f573.html",
            "url": "http://yuyuaqwq.github.io/posts/f573.html",
            "title": "【动手写ToyLang】4.递归下降",
            "date_published": "2022-10-30T08:34:27.524Z",
            "content_html": "<h1 id=\"递归下降\"><a class=\"markdownIt-Anchor\" href=\"#递归下降\">#</a> 递归下降</h1>\n<p>先前用于描述的加减运算表达式的文法，实际上并不能直接通过递归下降分析法来解析。</p>\n<p>说了这么多，递归下降到底是个什么玩意呢？<br>\n接下来我们通过以下能够应用递归下降进行解析的文法来解析输入串，了解其解析过程，你大概就明白了。</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">block</span> = <span class=\"string\">&#x27;&#123;&#x27;</span> &#123;stat&#125; <span class=\"string\">&#x27;&#125;&#x27;</span></span><br><span class=\"line\">stat = assignExp <span class=\"string\">&#x27;;&#x27;</span></span><br><span class=\"line\">assignExp = ident <span class=\"string\">&#x27;=&#x27;</span> value</span><br><span class=\"line\">value = number | string</span><br></pre></td></tr></table></figure>\n<p><code>&#123;&#125;</code>  表示重复，此处表示可以有 0~n 个 <code>stat</code> 。<br>\n其中， <code>ident</code>  是标识符，包括 <code>number</code> ， <code>string</code> ，我们都会放到词法分析中去解析，故不在此列出其文法。</p>\n<p>首先，假设 <code>block</code>  输入串为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    a = 1;</span><br><span class=\"line\">    b = &quot;qwq&quot;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以下是解析的伪代码：</p>\n<h2 id=\"解析block\"><a class=\"markdownIt-Anchor\" href=\"#解析block\">#</a> 解析 <code>block</code></h2>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func ParseBlock(inStr) &#123;</span><br><span class=\"line\">    inStr.match(&#x27;&#123;&#x27;);</span><br><span class=\"line\">    while in.is(&#x27;&#125;&#x27;) == false &#123;</span><br><span class=\"line\">        ParseStat(in);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    inStr.match(&#x27;&#125;&#x27;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>首先从输入串中匹配 <code>&#123;</code> 字符；<br>\n由于语句是可选的，因此需要检查紧接着的符号是否为 <code>&#125;</code>  字符，不是的话就可以匹配 <code>stat</code>  了；<br>\n <code>stat</code>  是一个非终结符，需要继续展开，此处交给 <code>ParseStat</code>  进一步解析；<br>\n <code>ParseStat</code>  返回后，表示一条语句的解析完成了，但语句可能存在多条，因此循环进行；<br>\n最后匹配一个 <code>&#125;</code>  字符；<br>\n <code>block</code>  解析完成。</p>\n<p>抽象语法树如下：</p>\n<ul>\n<li>\n<img src=\"/posts/f573/1.png\" class=\"\" title=\"这是一张图片\">\n</li>\n</ul>\n<p><em>为什么这里没有添加 <code>&#123;</code>  和  <code>&#125;</code>  节点呢？</em><br>\n<em>因为树构建完成后，我们自然可以知道这个节点是 block，在词法阶段的两个符号于语法树而言并无关紧要。</em></p>\n<h2 id=\"解析stat\"><a class=\"markdownIt-Anchor\" href=\"#解析stat\">#</a> 解析 <code>stat</code></h2>\n<p>关于 <code>stat</code>  的解析，在 <code>ParseStat</code>  函数中完成：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func ParseStat(inStr) &#123;</span><br><span class=\"line\">    ParseAssignExp(inStr);</span><br><span class=\"line\">    inStr.match(&#x27;;&#x27;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>\n<img src=\"/posts/f573/2.png\" class=\"\" title=\"这是一张图片\">\n</li>\n</ul>\n<h2 id=\"解析assignexp\"><a class=\"markdownIt-Anchor\" href=\"#解析assignexp\">#</a> 解析 <code>assignExp</code></h2>\n<p>接下来是 <code>assignExp</code> ：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func ParseAssignExp(inStr) &#123;</span><br><span class=\"line\">    inStr.match(kIdent);</span><br><span class=\"line\">    inStr.match(&#x27;=&#x27;);</span><br><span class=\"line\">    ParseValue(inStr);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>\n<img src=\"/posts/f573/3.png\" class=\"\" title=\"这是一张图片\">\n</li>\n</ul>\n<p><em>这里同样没有将符号 <code>=</code>  作为节点添加。</em></p>\n<h2 id=\"解析value\"><a class=\"markdownIt-Anchor\" href=\"#解析value\">#</a> 解析 <code>Value</code></h2>\n<p>最后完成关于 <code>Value</code>  的解析：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func ParseValue(inStr) &#123;</span><br><span class=\"line\">    inStr in.is(kNumber) &#123;</span><br><span class=\"line\">        in.match(kNumber);</span><br><span class=\"line\">        ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    inStr.match(kString);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"关键描述文法\"><a class=\"markdownIt-Anchor\" href=\"#关键描述文法\">#</a> 关键：描述文法</h2>\n<p><strong>这种自顶逐层向下解析，以构造语法树的分析法，就叫做递归下降。</strong><br>\n<em>虽然笔者并没有在伪代码中添加构造树的节点相关的代码，但不妨碍读者理解递归下降。</em></p>\n<p>你会发现，只要我们描述好了文法，用递归下降解析输入串是一件非常轻松的事情。</p>\n<h2 id=\"无限递进\"><a class=\"markdownIt-Anchor\" href=\"#无限递进\">#</a> 无限递进</h2>\n<p>还记得我在上一篇文章中所描述的文法吗？</p>\n<p>如果直接编写解析代码，就会形成无限递进：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func ParseExp(inStr) &#123;</span><br><span class=\"line\">    ParseExp(inStr);</span><br><span class=\"line\">    if inStr.is(&#x27;+&#x27;) &#123;</span><br><span class=\"line\">        inStr.match(&#x27;+&#x27;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else &#123;</span><br><span class=\"line\">        inStr.match(&#x27;-&#x27;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ParseNumber(inStr);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>\n<img src=\"/posts/f573/4.png\" class=\"\" title=\"这是一张图片\">\n</li>\n</ul>\n<h1 id=\"消除左递归\"><a class=\"markdownIt-Anchor\" href=\"#消除左递归\">#</a> 消除左递归</h1>\n<p><strong>如果非终结符 <code>r</code>  被直接或间接推导后，其结果最左边又出现非终结符 <code>r</code>  的情况，便称之为左递归。</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">exp = exp + number</span><br><span class=\"line\">-&gt; exp = exp + number + number</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>为此，我们需要改写文法，以避免出现左递归。</p>\n<h2 id=\"四则表达式文法\"><a class=\"markdownIt-Anchor\" href=\"#四则表达式文法\">#</a> 四则表达式文法</h2>\n<p>首先，我们用 EBNF 描述更加完整的四则表达式文法：</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">exp</span> = addexp</span><br><span class=\"line\">addexp = addexp oper2 mulexp | mulexp</span><br><span class=\"line\">oper2 = <span class=\"string\">&#x27;+&#x27;</span> | <span class=\"string\">&#x27;-&#x27;</span></span><br><span class=\"line\">mulexp = mulexp oper1 number | number</span><br><span class=\"line\">oper1 = <span class=\"string\">&#x27;*&#x27;</span> | <span class=\"string\">&#x27;/&#x27;</span></span><br></pre></td></tr></table></figure>\n<p><em>关于 <code>number</code>  的产生式就不再列出，实际上我们会在词法分析阶段将 <code>number</code>  解析为 <code>token</code> 。</em></p>\n<p>我们现在很容易就能看出，在该文法中，左式为 <code>addexp</code>  和 <code>mulexp</code>  的产生式都存在左递归的问题。</p>\n<p>如何消除呢？<br>\n首先观察产生式 <code>addexp = addexp oper2 mulexp | mulexp</code> <br>\n 我们会发现这么一条规律：</p>\n<ul>\n<li><code>addexp</code>  的推导产生的句型，必然是 <code>mulexp &#123;oper2 mulexp&#125;</code></li>\n</ul>\n<p>于是我们可以重写文法为：</p>\n<figure class=\"highlight bnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">addexp ::= mulexp addexp<span class=\"string\">&#x27;</span></span><br><span class=\"line\"><span class=\"string\">addexp&#x27;</span> ::= oper2 addexp<span class=\"string\">&#x27; | ε</span></span><br></pre></td></tr></table></figure>\n<p>或</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">addexp</span> = mulexp &#123;oper2 mulexp&#125;</span><br></pre></td></tr></table></figure>\n<p>第一种是教学时消除左递归时经常用于举例的 BNF 文法；<br>\n其中 <code>ε</code>  表示空。<br>\n<em>事实上关于 BNF 的规范，似乎网上许多文章的写法都不尽相同，这里也不做深究了。</em></p>\n<p>第二种则是使用 EBNF 描述的文法，通过 <code>&#123;&#125;</code>  做了简化。</p>\n<p><em>事实上，我们如果直接按照第一种文法编写解析代码，最终构成的语法树会存在结合律的问题。</em><br>\n<em>如果使用第二种文法，以多叉树的形式存储其节点，则会更加简单，因此本系列文章采用第二种文法。</em></p>\n<h1 id=\"构造语法树\"><a class=\"markdownIt-Anchor\" href=\"#构造语法树\">#</a> 构造语法树</h1>\n<p>接下来我们尝试基于此文法与表达式 <code>1 + 5 * 6</code> ，构造其抽象语法树。</p>\n<p>以下是完整文法：</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">exp</span> = addexp</span><br><span class=\"line\">addexp = mulexp &#123;oper2 mulexp&#125;</span><br><span class=\"line\">oper2 = <span class=\"string\">&#x27;+&#x27;</span> | <span class=\"string\">&#x27;-&#x27;</span></span><br><span class=\"line\">mulexp = number &#123;oper1 number&#125;</span><br><span class=\"line\">oper1 = <span class=\"string\">&#x27;*&#x27;</span> | <span class=\"string\">&#x27;/&#x27;</span></span><br></pre></td></tr></table></figure>\n<p>以下是解析过程：</p>\n<ul>\n<li>\n<img src=\"/posts/f573/5.png\" class=\"\" title=\"这是一张图片\">\n</li>\n<li>\n<img src=\"/posts/f573/6.png\" class=\"\" title=\"这是一张图片\">\n</li>\n<li>\n<img src=\"/posts/f573/7.png\" class=\"\" title=\"这是一张图片\">\n</li>\n<li>\n<img src=\"/posts/f573/8.png\" class=\"\" title=\"这是一张图片\">\n</li>\n<li>\n<img src=\"/posts/f573/9.png\" class=\"\" title=\"这是一张图片\">\n</li>\n</ul>\n<p>你可以尝试自己编写一些表达式，然后画画图，找找感觉。<br>\n也可以尝试自己在脑中遍历这颗语法树，试试看能否能够正确计算出结果。</p>\n<h1 id=\"参考文献\"><a class=\"markdownIt-Anchor\" href=\"#参考文献\">#</a> 参考文献</h1>\n<blockquote>\n<p><em>[1] 消除左递归.<a href=\"https://blog.csdn.net/qq2071114140/article/details/102787831\">https://blog.csdn.net/qq2071114140/article/details/102787831</a></em></p>\n</blockquote>\n",
            "tags": [
                "编译原理",
                "动手写ToyLang"
            ]
        },
        {
            "id": "http://yuyuaqwq.github.io/posts/1571.html",
            "url": "http://yuyuaqwq.github.io/posts/1571.html",
            "title": "【动手写ToyLang】3.语法分析",
            "date_published": "2022-10-30T03:52:33.000Z",
            "content_html": "<h1 id=\"语法分析\"><a class=\"markdownIt-Anchor\" href=\"#语法分析\">#</a> 语法分析</h1>\n<p>按照传统的编译原理教材讲述的编译器结构， <code>词法分析阶段</code> 之后，便是 <code>语法分析阶段</code> 。</p>\n<p>以下摘自百度百科：</p>\n<blockquote>\n<p><em>语法分析是编译过程的一个逻辑阶段。语法分析的任务是在词法分析的基础上将单词序列组合成各类语法短语，如 “程序”，“语句”，“表达式” 等等。语法分析程序判断源程序在结构上是否正确。源程序的结构由上下文无关文法描述。语法分析程序可以用 YACC 等工具自动生成。</em></p>\n</blockquote>\n<p><strong>简而言之，语法分析即要求完成对输入串是否能符合语言文法规定的检查。</strong><br>\n<em>关于文法的定义，参照下文。</em></p>\n<h2 id=\"语法分析器\"><a class=\"markdownIt-Anchor\" href=\"#语法分析器\">#</a> 语法分析器</h2>\n<p>我们需要实现的是语法分析器。<br>\n<strong>语法分析器的主要工作就是接收词法分析器输出的 Token，产出抽象语法树。</strong></p>\n<p><em>本意我是不想讲太多学科中严谨定义的内容，一个是不好懂，容易劝退；一个是我个人的理解也有限。</em><br>\n<em>所以本系列文章就只简单提及我认为的 ToyLang 开发过程中必要的东西。</em></p>\n<h1 id=\"文法\"><a class=\"markdownIt-Anchor\" href=\"#文法\">#</a> 文法</h1>\n<p>这里还是请出百度百科：</p>\n<blockquote>\n<p><em>文法是一个汉语词汇，读音为 wén fǎ ，即文章的书写法规，一般用来指以文字、词语、短句、句子的编排而组成的完整语句和文章的合理性组织。</em></p>\n</blockquote>\n<p>学编译原理确实有很多东西难以理解，特别是各种各样的名词。</p>\n<p>我们先简单理解成，<strong>文法就是描述如何将 token 组织成语法树的规则。</strong></p>\n<p>我们的语言自然也需要存在文法，比如 if 语句必须按照下列文法来解析：</p>\n<ul>\n<li><code>if</code>   <code>exp</code>   <code>block</code></li>\n</ul>\n<p>当然，现在我们还是将重心放到四则表达式的解析上。</p>\n<h2 id=\"上下文无关文法\"><a class=\"markdownIt-Anchor\" href=\"#上下文无关文法\">#</a> 上下文无关文法</h2>\n<p><strong>在推导产生式时，正在进行的非终结符展开与前后已经展开的终结符不存在关联的文法。</strong><br>\n可以先继续向下看。</p>\n<h1 id=\"ebnf\"><a class=\"markdownIt-Anchor\" href=\"#ebnf\">#</a> EBNF</h1>\n<p>我们选择通过 <code>EBNF</code>  来描述 <code>ToyLang</code>  的文法。</p>\n<p>EBNF 是什么呢？</p>\n<blockquote>\n<p><em>扩展巴科斯 - 瑙尔范式 (Extended Backus–Naur Form,EBNF) 是一种用于描述计算机编程语言等正式语言的与上下文无关语法的元语法 (metasyntax) 符号表示法。简而言之，它是一种描述语言的语言。它是基本巴科斯范式 (BNF) 元语法符号表示法的一种扩展。</em></p>\n</blockquote>\n<p>只看说明通常很难理解新事物，咱们尝试一下用 EBNF 描述四则运算表达式的文法。</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">exp</span> = exp <span class=\"string\">&#x27;+&#x27;</span> number | exp <span class=\"string\">&#x27;-&#x27;</span> number | number</span><br><span class=\"line\">number = digit &#123;digit&#125;</span><br><span class=\"line\">digit = <span class=\"string\">&#x27;0&#x27;</span> | <span class=\"string\">&#x27;1&#x27;</span> | <span class=\"string\">&#x27;2&#x27;</span> | <span class=\"string\">&#x27;3&#x27;</span> | <span class=\"string\">&#x27;4&#x27;</span> | <span class=\"string\">&#x27;5&#x27;</span> | <span class=\"string\">&#x27;6&#x27;</span> | <span class=\"string\">&#x27;7&#x27;</span> | <span class=\"string\">&#x27;8&#x27;</span> | <span class=\"string\">&#x27;9&#x27;</span></span><br></pre></td></tr></table></figure>\n<p>为了便于理解，这里只描述了加法与减法。</p>\n<h2 id=\"基本规则\"><a class=\"markdownIt-Anchor\" href=\"#基本规则\">#</a> 基本规则</h2>\n<p>你可能看不明白，没关系，我简单给你讲解一下：</p>\n<ul>\n<li>在 <code>=</code>  左边的，我们称为 <code>左式</code> ；</li>\n<li>在 <code>=</code>  右边的，我们称为 <code>右式</code> ；</li>\n<li>这样一行式子，我们称为 <code>产生式</code> 。</li>\n</ul>\n<h2 id=\"非终结符\"><a class=\"markdownIt-Anchor\" href=\"#非终结符\">#</a> 非终结符</h2>\n<p><strong>是某条产生式的左式，可以用其右式代换。</strong><br>\n如 <code>exp</code> ， <code>number</code> ， <code>digit</code> 。</p>\n<h2 id=\"终结符\"><a class=\"markdownIt-Anchor\" href=\"#终结符\">#</a> 终结符</h2>\n<p><strong>无法被再被代换的符号。</strong><br>\n如 <code>+</code> 、 <code>-</code> 、 <code>0</code> 、 <code>1</code> …。</p>\n<blockquote>\n<p><em>关于更多 EBNF 的语法规则，请参阅相关资料。</em></p>\n</blockquote>\n<h1 id=\"自顶向下\"><a class=\"markdownIt-Anchor\" href=\"#自顶向下\">#</a> 自顶向下</h1>\n<p><strong>已知 <code>输入串</code> 为某条产生式的左式，扫描输入串以不断展开其非终结符，直至只剩下终结符。</strong><br>\n<strong>这个展开的过程我们叫做推导，这属于自顶向下解析的思想。</strong></p>\n<h2 id=\"尝试解析\"><a class=\"markdownIt-Anchor\" href=\"#尝试解析\">#</a> 尝试解析</h2>\n<p>我们先来看第一行产生式：<br>\n <code>exp = exp '+' number | exp '-' number | number</code> <br>\n 它描述了 <code>表达式</code> 可以由：</p>\n<ul>\n<li><code>表达式+数字</code> 组成；</li>\n<li>也可以由 <code>表达式-数字</code> 组成；</li>\n<li>也可以只由 <code>数字</code> 组成。</li>\n</ul>\n<p><em>其中， <code>|</code>  表示或的意思，如果你学习过正则表达式，应当很容易理解。</em></p>\n<p>假设我们需要解析的 exp 输入串为 <code>1 + 2</code> ，解析过程如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">exp -&gt; exp &#x27;+&#x27; number</span><br><span class=\"line\">        -&gt; number &#x27;+&#x27; &#x27;number&#x27;</span><br><span class=\"line\">            -&gt; &#x27;1&#x27; &#x27;+&#x27; &#x27;number&#x27;</span><br><span class=\"line\">                -&gt; &#x27;1&#x27; &#x27;+&#x27; &#x27;2&#x27;</span><br></pre></td></tr></table></figure>\n<p>就是在重复将右式中的非终结符展开的过程。<br>\n<em>这里为了节约篇幅，我没有将从 number 推导成 digit，再推导成数字的推导过程记录下来，你明白这一点即可。</em></p>\n<p>再尝试一下解析 exp 输入串 <code>1</code>   <code>+</code>   <code>2</code>   <code>-</code>   <code>3</code> :</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">exp -&gt; exp &#x27;-&#x27; number</span><br><span class=\"line\">        -&gt; exp &#x27;+&#x27; number &#x27;-&#x27; number</span><br><span class=\"line\">            -&gt; number &#x27;+&#x27; number &#x27;-&#x27; number</span><br><span class=\"line\">                -&gt; &#x27;1&#x27; &#x27;+&#x27; number &#x27;-&#x27; number</span><br><span class=\"line\">                    -&gt; &#x27;1&#x27; &#x27;+&#x27; &#x27;2&#x27; &#x27;-&#x27; number</span><br><span class=\"line\">                        -&gt; &#x27;1&#x27; &#x27;+&#x27; &#x27;2&#x27; &#x27;-&#x27; &#x27;3&#x27;</span><br></pre></td></tr></table></figure>\n<p>当然，这个推导过程我们忽略了很多细节，并不能直接编写代码实现。</p>\n<h1 id=\"尾声\"><a class=\"markdownIt-Anchor\" href=\"#尾声\">#</a> 尾声</h1>\n<p>在下一篇文章，我们会通过 EBNF 来描述完整的四则表达式的文法，并讲解 <code>递归下降</code> 算法。</p>\n<h1 id=\"参考文献\"><a class=\"markdownIt-Anchor\" href=\"#参考文献\">#</a> 参考文献</h1>\n<blockquote>\n<p><em>[1] 扩展巴科斯范式 (EBNF) 简介.<a href=\"https://blog.csdn.net/lin_strong/article/details/78583543\">https://blog.csdn.net/lin_strong/article/details/78583543</a></em><br>\n<em> [2] 应该如何理解「上下文无关文法」？.<a href=\"https://www.zhihu.com/question/21833944\">https://www.zhihu.com/question/21833944</a></em><br>\n<em> 其他网络上较为零散的资料，无法一一列举，十分抱歉。</em></p>\n</blockquote>\n",
            "tags": [
                "编译原理",
                "动手写ToyLang"
            ]
        },
        {
            "id": "http://yuyuaqwq.github.io/posts/aca7.html",
            "url": "http://yuyuaqwq.github.io/posts/aca7.html",
            "title": "【动手写ToyLang】2.词法分析",
            "date_published": "2022-10-29T04:29:50.000Z",
            "content_html": "<h1 id=\"词法分析\"><a class=\"markdownIt-Anchor\" href=\"#词法分析\">#</a> 词法分析</h1>\n<p>词法分析是整个编译器结构中最简单的一个阶段，所以放轻松，咱们往下看。</p>\n<p>那么，词法分析是什么呢？<br>\n我们知道，程序开发者编写的源代码，也就是编译器最初能够接收到的输入，即连续的字符序列。</p>\n<p><strong>词法分析存在的意义，就是提前将源代码切分成能被后续编译程序直接使用的单词序列。</strong></p>\n<ul>\n<li>如源代码中的变量标识，关键字，字符串字面量，数值字面量等…</li>\n</ul>\n<p>我们上一节课所展示的算术表达式， <code>3 + 2</code> ，也是先将其分成 <code>3</code>   <code>+</code>   <code>2</code> ，才能用于构成抽象语法树。</p>\n<p><strong>词法分析器产出的单词序列，我们将其称为 <code>Token</code> 。</strong></p>\n<hr>\n<h1 id=\"输入四则运算表达式产出token\"><a class=\"markdownIt-Anchor\" href=\"#输入四则运算表达式产出token\">#</a> 输入四则运算表达式，产出 <code>Token</code></h1>\n<p>我们既然需要将四则运算表达式转成 <code>Token</code> ，也就需要知道其单词序列的规则，当然，关于这一点，我们早已烂熟于心了。<br>\n以下是我通过正则表达式描述的 <code>Token</code>  匹配规则 (以我们将要开发的词法分析器为准)。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">TokenType</th>\n<th style=\"text-align:left\">Regex</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">Eof</td>\n<td style=\"text-align:left\">\\0</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Number</td>\n<td style=\"text-align:left\">\\d+</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">OpAdd</td>\n<td style=\"text-align:left\">+</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">OpSub</td>\n<td style=\"text-align:left\">-</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">OpMul</td>\n<td style=\"text-align:left\">*</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">OpDiv</td>\n<td style=\"text-align:left\">/</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">SepLParen</td>\n<td style=\"text-align:left\">(</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">SepRParen</td>\n<td style=\"text-align:left\">)</td>\n</tr>\n</tbody>\n</table>\n<p><em>此处我忽略了运算符在正则表达式中需要转义的情况，做一个参考即可。</em></p>\n<h1 id=\"lexer\"><a class=\"markdownIt-Anchor\" href=\"#lexer\">#</a> Lexer</h1>\n<p>Lexer，即词法分析器。<br>\n接下来我们编写代码实现 Lexer。</p>\n<h2 id=\"token\"><a class=\"markdownIt-Anchor\" href=\"#token\">#</a> Token</h2>\n<details class=\"folding-tag\" blue><summary> \\lexer\\token.h </summary>\n              <div class='content'>\n              <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> LEXER_TOKEN_H_</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LEXER_TOKEN_H_</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> lexer &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// token类型常量</span></span><br><span class=\"line\"><span class=\"keyword\">enum class</span> <span class=\"title class_\">TokenType</span> &#123;</span><br><span class=\"line\">\tkNil = <span class=\"number\">0</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">\tkEof,</span><br><span class=\"line\">\tkNumber,</span><br><span class=\"line\"></span><br><span class=\"line\">\tkOpAdd,    <span class=\"comment\">// +</span></span><br><span class=\"line\">\tkOpSub,    <span class=\"comment\">// -</span></span><br><span class=\"line\">\tkOpMul,    <span class=\"comment\">// *</span></span><br><span class=\"line\">\tkOpDiv,    <span class=\"comment\">// /</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tkSepLPar,  <span class=\"comment\">// (</span></span><br><span class=\"line\">\tkSepRPar,  <span class=\"comment\">// )</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 描述token的结构体</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Token</span> &#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">Is</span><span class=\"params\">(TokenType t_type)</span> <span class=\"type\">const</span> <span class=\"keyword\">noexcept</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> line;\t\t<span class=\"comment\">// 行号</span></span><br><span class=\"line\">\tTokenType type;\t\t<span class=\"comment\">// token类型</span></span><br><span class=\"line\">\tstd::string str;\t<span class=\"comment\">// 保存必要的信息</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125; <span class=\"comment\">// namespace lexer</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span> <span class=\"comment\">// LEXER_TOKEN_H_</span></span></span><br></pre></td></tr></table></figure>\n              </div>\n            </details>\n<details class=\"folding-tag\" blue><summary> \\lexer\\token.cpp </summary>\n              <div class='content'>\n              <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;token.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> lexer &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">Token::Is</span><span class=\"params\">(TokenType t_type)</span> <span class=\"type\">const</span> <span class=\"keyword\">noexcept</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> t_type == type;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125; <span class=\"comment\">// namespace lexer</span></span><br></pre></td></tr></table></figure>\n              </div>\n            </details>\n<p>token 这部分十分简单，不赘述了。</p>\n<h2 id=\"lexer-2\"><a class=\"markdownIt-Anchor\" href=\"#lexer-2\">#</a> Lexer</h2>\n<details class=\"folding-tag\" blue><summary> \\lexer\\lexer.h </summary>\n              <div class='content'>\n              <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> LEXER_LEXER_H_</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LEXER_LEXER_H_</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;exception&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;lexer/token.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> lexer &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 词法分析时发生的异常</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">LexerException</span> : <span class=\"keyword\">public</span> std::exception &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">LexerException</span>(<span class=\"type\">const</span> <span class=\"type\">char</span>* t_msg);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 词法分析器类</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Lexer</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">Lexer</span>(<span class=\"type\">const</span> <span class=\"type\">char</span>* t_src);</span><br><span class=\"line\">\t~<span class=\"built_in\">Lexer</span>() <span class=\"keyword\">noexcept</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">char</span> <span class=\"title\">NextChar</span><span class=\"params\">()</span> <span class=\"keyword\">noexcept</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">SkipChar</span><span class=\"params\">(<span class=\"type\">int</span> count)</span> <span class=\"keyword\">noexcept</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\">Token <span class=\"title\">NextToken</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\tstd::string m_src;</span><br><span class=\"line\">\t<span class=\"type\">size_t</span> m_idx;</span><br><span class=\"line\">\tToken m_reserve;</span><br><span class=\"line\">\t<span class=\"type\">int</span> m_line;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125; <span class=\"comment\">// namespace lexer</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span> <span class=\"comment\">// LEXER_LEXER_H_</span></span></span><br></pre></td></tr></table></figure>\n              </div>\n            </details>\n<details class=\"folding-tag\" blue><summary> \\lexer\\lexer.cpp </summary>\n              <div class='content'>\n              <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;lexer.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> lexer &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">LexerException::<span class=\"built_in\">LexerException</span>(<span class=\"type\">const</span> <span class=\"type\">char</span>* t_msg) : std::<span class=\"built_in\">exception</span>(t_msg) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Lexer::<span class=\"built_in\">Lexer</span>(<span class=\"type\">const</span> <span class=\"type\">char</span>* t_src) : m_src&#123; t_src &#125;, m_line&#123; <span class=\"number\">0</span> &#125;, m_idx&#123; <span class=\"number\">0</span> &#125;, m_reserve&#123; <span class=\"number\">0</span>, TokenType::kNil &#125; &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Lexer::~<span class=\"built_in\">Lexer</span>() <span class=\"keyword\">noexcept</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取下一字符</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">char</span> <span class=\"title\">Lexer::NextChar</span><span class=\"params\">()</span> <span class=\"keyword\">noexcept</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (m_idx &lt; m_src.<span class=\"built_in\">size</span>()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> m_src[m_idx++];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 跳过指定字符数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Lexer::SkipChar</span><span class=\"params\">(<span class=\"type\">int</span> count)</span> <span class=\"keyword\">noexcept</span> </span>&#123;</span><br><span class=\"line\">    m_idx += count;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取下一Token</span></span><br><span class=\"line\"><span class=\"function\">Token <span class=\"title\">Lexer::NextToken</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Token token;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!m_reserve.<span class=\"built_in\">Is</span>(TokenType::kNil)) &#123;        <span class=\"comment\">// 如果有前瞻保存的token</span></span><br><span class=\"line\">        <span class=\"comment\">// 返回前瞻的结果</span></span><br><span class=\"line\">        token = m_reserve;</span><br><span class=\"line\">        m_reserve.type = TokenType::kNil;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> token;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">char</span> c;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 跳过空格</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> ((c = <span class=\"built_in\">NextChar</span>()) &amp;&amp; c == <span class=\"string\">&#x27; &#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    token.line = m_line;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (c == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        token.type = TokenType::kEof;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> token;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 根据字符返回对应类型的Token</span></span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (c) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&#x27;+&#x27;</span>:</span><br><span class=\"line\">        token.type = TokenType::kOpAdd;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> token;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&#x27;-&#x27;</span>:</span><br><span class=\"line\">        token.type = TokenType::kOpSub;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> token;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&#x27;*&#x27;</span>:</span><br><span class=\"line\">        token.type = TokenType::kOpMul;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> token;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&#x27;/&#x27;</span>:</span><br><span class=\"line\">        token.type = TokenType::kOpDiv;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> token;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&#x27;(&#x27;</span>:</span><br><span class=\"line\">        token.type = TokenType::kSepLParen;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> token;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&#x27;)&#x27;</span>:</span><br><span class=\"line\">        token.type = TokenType::kSepRParen;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> token;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (c &gt;= <span class=\"string\">&#x27;0&#x27;</span> || c &lt;= <span class=\"string\">&#x27;9&#x27;</span>) &#123;</span><br><span class=\"line\">        token.type = TokenType::kNumber;</span><br><span class=\"line\">        token.str.<span class=\"built_in\">push_back</span>(c);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (c = <span class=\"built_in\">NextChar</span>()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (c &gt;= <span class=\"string\">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class=\"string\">&#x27;9&#x27;</span>) &#123;</span><br><span class=\"line\">                token.str.<span class=\"built_in\">push_back</span>(c);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"built_in\">SkipChar</span>(<span class=\"number\">-1</span>);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> token;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"built_in\">LexerException</span>(<span class=\"string\">&quot;cannot parse token&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125; <span class=\"comment\">// namespace lexer</span></span><br></pre></td></tr></table></figure>\n              </div>\n            </details>\n<p>我们封装了一个词法分析器类；<br>\n <code>Lexer::NextToken</code>  是关键成员函数，用于扫描字符序列，匹配一个完整的 Token 并返回。</p>\n<h1 id=\"测试成果\"><a class=\"markdownIt-Anchor\" href=\"#测试成果\">#</a> 测试成果</h1>\n<p>接下来，我们编写测试代码，用于测试新鲜出炉的词法分析器。<br>\n用于测试的表达式是： <code>1 + 33 - 0 * (33 / 999) - 123</code></p>\n<details class=\"folding-tag\" blue><summary> \\entry.cpp </summary>\n              <div class='content'>\n              <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;lexer/lexer.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> lexer;</span><br><span class=\"line\"></span><br><span class=\"line\">    Lexer lexer&#123; <span class=\"string\">&quot;1 + 33 - 0 * (33 / 999) - 123&quot;</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> token = lexer.<span class=\"built_in\">NextToken</span>();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (token.<span class=\"built_in\">Is</span>(TokenType::kEof)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (token.type) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> TokenType::kNumber:&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s\\n&quot;</span>, token.str.<span class=\"built_in\">c_str</span>()); <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> TokenType::kOpAdd: &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;+\\n&quot;</span>); <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> TokenType::kOpDiv: &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;/\\n&quot;</span>); <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> TokenType::kOpMul: &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;*\\n&quot;</span>); <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> TokenType::kOpSub: &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;-\\n&quot;</span>); <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> TokenType::kSepLParen: &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;(\\n&quot;</span>); <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> TokenType::kSepRParen: &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;)\\n&quot;</span>); <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n              </div>\n            </details>\n<details class=\"folding-tag\" blue><summary> 打印结果 </summary>\n              <div class='content'>\n              <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">+</span><br><span class=\"line\">33</span><br><span class=\"line\">-</span><br><span class=\"line\">0</span><br><span class=\"line\">*</span><br><span class=\"line\">(</span><br><span class=\"line\">33</span><br><span class=\"line\">/</span><br><span class=\"line\">999</span><br><span class=\"line\">)</span><br><span class=\"line\">-</span><br><span class=\"line\">123</span><br></pre></td></tr></table></figure>\n              </div>\n            </details>",
            "tags": [
                "编译原理",
                "动手写ToyLang"
            ]
        },
        {
            "id": "http://yuyuaqwq.github.io/posts/56ac.html",
            "url": "http://yuyuaqwq.github.io/posts/56ac.html",
            "title": "【动手写ToyLang】1.从四则运算表达式开始",
            "date_published": "2022-10-28T15:01:12.000Z",
            "content_html": "<h1 id=\"由此开始\"><a class=\"markdownIt-Anchor\" href=\"#由此开始\">#</a> 由此开始</h1>\n<p>如果你曾经接触过《编译原理》的话，不知道是否与我有着同样的困惑呢？</p>\n<p>各种不近人情的名词，公式乱飞，这让我学习起来格外痛苦。</p>\n<p>我在尝试阅读过不少文章、书籍，动手之后，才逐渐理解了一些比较关键的东西。</p>\n<p><em>实际上，当我真正自己动手完成了对四则运算表达式的解析的那一刻，我才真切感受到了编译原理的优雅与美妙之处，这大概就是由无数人智慧造就的伟大吧 (偏得有点远了)。</em></p>\n<p><strong>因此，我才会选择先从四则运算表达式开始，将其逐步扩展成为一门 <code>通用编程语言</code> ，也能让读者每一节都能感受到学习有所反馈的喜悦。</strong></p>\n<hr>\n<h1 id=\"初尝构思\"><a class=\"markdownIt-Anchor\" href=\"#初尝构思\">#</a> 初尝构思</h1>\n<p><strong>现在，我来尝试给你出一道题吧，请你用你所熟悉的语言，编写一个模块：</strong></p>\n<ol>\n<li>输入符合四则运算表达式规范的字符串 (可以假定只有整数，不存在括号)；</li>\n<li>输出整型结果；</li>\n<li>要求关键逻辑由自己实现，不可借由库、语言本身提供的功能。</li>\n</ol>\n<p>你能实现吗？</p>\n<p>是否觉得脑子有些空白，难以组织成较为优雅的实现思路呢？</p>\n<pre><code>如果你现在就能想到很棒的解法，那至少你要比我厉害多了。\n</code></pre>\n<p>我曾经因为某些需求做过尝试，虽然最后写出来了，但是具体实现也非常丑陋，这里就不献丑了。</p>\n<p>但是我可以给你大致描述一下我当初的思路：</p>\n<ul>\n<li>\n<p>首先，查找字符串中优先级较高的运算符  <code>*</code>   <code>/</code> ，再前 / 后瞻运算符前后的数字，这个子串也能形成一个表达式；</p>\n</li>\n<li>\n<p>算出结果后，在原表达式中，用结果替换掉子串 (刚刚被计算的表达式)，再继续查找。</p>\n</li>\n<li>\n<p>完成后再从头开始查找优先级更低一级的运算符 <code>+</code>   <code>-</code> ，直到运算完成。</p>\n</li>\n</ul>\n<p><strong>当然，我们不会用这么低效的方法，也不会要求你真的写出来。</strong></p>\n<p><strong>现在提出来，也不是为了为难你，只是为了让你记住眼下的感觉，当你学完本系列文章后，再回来看看，这一道题，是否真的有那么难呢？</strong></p>\n<hr>\n<h1 id=\"抽象语法树\"><a class=\"markdownIt-Anchor\" href=\"#抽象语法树\">#</a> 抽象语法树</h1>\n<p>咱们先来看百度百科对 <code>抽象语法树</code> 的定义：</p>\n<blockquote>\n<p><em>在计算机科学中，抽象语法树（Abstract Syntax Tree，AST），或简称<a href=\"https://baike.baidu.com/item/%E8%AF%AD%E6%B3%95%E6%A0%91/7031301?fromModule=lemma_inlink\">语法树</a>（Syntax tree），是<a href=\"https://baike.baidu.com/item/%E6%BA%90%E4%BB%A3%E7%A0%81?fromModule=lemma_inlink\">源代码</a><a href=\"https://baike.baidu.com/item/%E8%AF%AD%E6%B3%95?fromModule=lemma_inlink\">语法</a>结构的一种抽象表示。它以树状的形式表现<a href=\"https://baike.baidu.com/item/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80?fromModule=lemma_inlink\">编程语言</a>的语法结构，树上的每个节点都表示源代码中的一种结构。</em></p>\n</blockquote>\n<p>嗯… 不愧是名字就带着抽象的东西，连说明都这么抽象。</p>\n<p>咱们先不整那么多虚头巴脑的，干就完了。</p>\n<h2 id=\"构造四则运算表达式的ast\"><a class=\"markdownIt-Anchor\" href=\"#构造四则运算表达式的ast\">#</a> 构造四则运算表达式的 AST</h2>\n<p><code>3 + 2</code></p>\n<p>这个是大家熟悉的算术表达式，实际上，我们人脑是如何计算这个表达式的呢？当然需要遵循某些规则：</p>\n<ol>\n<li>先乘除</li>\n<li>再加减</li>\n<li>从左往右结合</li>\n</ol>\n<p>那我们自然是需要先<strong>左往右找</strong>在表达式中找到 <code>*</code> 、 <code>/</code>  两种符号，好消息是，没有，嘿嘿。</p>\n<p>接下来继续<strong>左往右找</strong> <code>+</code> 、 <code>-</code> ，找到之后将其取出，这也是我们需要计算的子表达式。</p>\n<p>我们将其分成三部分，分别是：</p>\n<ul>\n<li>左边的数字  <code>3</code></li>\n<li>加法运算符  <code>+</code></li>\n<li>右边的数字  <code>2</code></li>\n</ul>\n<p>可以得到这么一棵树型结构：</p>\n<ul>\n<li>\n<img src=\"/posts/56ac/1.png\" class=\"\" title=\"这是一张图片\">\n</li>\n</ul>\n<p>接下来我们遍历这棵树：</p>\n<ol>\n<li>根节点，是加法，表明需要将左子节点与右子节点相加；</li>\n<li><code>3 + 2</code> ，返回结果  <code>5</code> ；</li>\n<li>遍历结束；</li>\n</ol>\n<ul>\n<li>\n<img src=\"/posts/56ac/2.png\" class=\"\" title=\"这是一张图片\">\n</li>\n</ul>\n<h3 id=\"多运算符与结合律\"><a class=\"markdownIt-Anchor\" href=\"#多运算符与结合律\">#</a> 多运算符与结合律</h3>\n<p>那么，当一个表达式中，存在多个运算符时，应该如何构造语法树呢？<br>\n接下来我们构造表达式  <code>3 - 2 + 4</code>  的树。</p>\n<p><strong>首先我们应该注意的一点是，需要先被执行运算 (优先级更高) 的子表达式，其节点相对的，要在更底下：</strong></p>\n<ul>\n<li>\n<img src=\"/posts/56ac/3.png\" class=\"\" title=\"这是一张图片\">\n</li>\n</ul>\n<p>还是先来遍历这颗树：</p>\n<ol>\n<li>根节点，是加法，表明需要将左子节点与右子节点相加；\n<ol>\n<li>左子节点是减法，表明需要用左子节点减去右子节点，需要继续向下展开；</li>\n<li><code>3 - 2</code> ，返回结果  <code>1</code> ；</li>\n</ol>\n</li>\n<li><code>1 + 4</code> ，返回结果  <code>5</code> ；</li>\n<li>遍历结束；</li>\n</ol>\n<p><strong>因此，遍历的过程也符合我们所要求的 <code>左结合律</code> 。</strong></p>\n<ul>\n<li>由左边的运算符开始，向右结合。</li>\n<li>同优先级下，我们需要优先计算左边的运算符组成的子表达式，</li>\n</ul>\n<p>接下来我再给你画一下另一种情况，你也就明白了。</p>\n<ul>\n<li>\n<img src=\"/posts/56ac/4.png\" class=\"\" title=\"这是一张图片\">\n</li>\n</ul>\n<p>你可以尝试一下遍历这棵树，会发现先被执行的一定是加法，这并不符合我们的从一开始就要求的 <code>左结合律</code> 。<br>\n在部分情况下，由于结合律的错误，就会产出错误的结果：</p>\n<ul>\n<li>如我们本次求解的表达式，通过遍历此树得出的结果为 <code>-3</code> 。</li>\n</ul>\n<h2 id=\"目标根据语法规则生成ast\"><a class=\"markdownIt-Anchor\" href=\"#目标根据语法规则生成ast\">#</a> 目标：根据语法规则生成 AST</h2>\n<p>我不说你大概也已经猜到了，其实我们上面所构造的树，在当前的应用场景下，就叫做 <code>抽象语法树</code> 。</p>\n<p><em><strong>遍历抽象语法树并计算的过程，与我们人脑对表达式的计算的过程是十分相似的。</strong></em></p>\n<p><strong>也就是说，我们只需要构造出这么一颗抽象语法树，就已经基本上完成了编译工作的一大半甚至全部。</strong><br>\n<strong>此时，若需要执行编译产生的结果，只需要遍历我们所生成 AST 即可。</strong></p>\n<p>如下图：</p>\n<ul>\n<li>\n<img src=\"/posts/56ac/5.png\" class=\"\" title=\"这是一张图片\">\n</li>\n</ul>\n<p>在遍历的过程中，我们就能够正确的完成对加法表达式的加法运算，再完成对赋值表达式的赋值运算。</p>\n<hr>\n<h1 id=\"ast解释器\"><a class=\"markdownIt-Anchor\" href=\"#ast解释器\">#</a> AST 解释器</h1>\n<p>最后，我们也确实展示了有关 &quot;解释器&quot; 的东西，是的，即便你难以置信。<br>\n遍历这棵树的过程，就可以叫做解释；<br>\n如果我们写出代码实现遍历树的过程，即是 <code>AST解释器</code> 。</p>\n<p>当然，解释器是一种比较广泛的概念，即便到后面我们基于 AST 生成了字节码，交给虚拟机执行，我们的程序也依然可以称之为解释器，只不过解释的对象从 AST 换成了字节码。</p>\n<p>我个人觉得，当初造这个词的人只是为了区分所谓的 &quot;编译型语言&quot; 和 &quot;解释型语言&quot;。<br>\n以下是百度百科对解释器的定义：</p>\n<blockquote>\n<p><em>解释器（<a href=\"https://baike.baidu.com/item/%E8%8B%B1%E8%AF%AD/109997?fromModule=lemma_inlink\">英语</a>：Interpreter），又译为直译器，是一种电脑程序，能够把高级<a href=\"https://baike.baidu.com/item/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80?fromModule=lemma_inlink\">编程语言</a>一行一行直接转译运行。解释器不会一次把整个程序转译出来，只像一位 “中间人”，每次运行程序时都要先转成另一种语言再作运行，因此解释器的程序运行速度比较缓慢。它每转译一行程序叙述就立刻运行，然后再转译下一行，再运行，如此不停地进行下去。</em></p>\n</blockquote>\n<ul>\n<li><em>此处关于 <code>每转译一行程序叙述就立刻运行</code> 的说明也不尽然，至少现在很多被称为 <code>解释器</code> 的程序，并非如此 (如 Python 解释器、Java 解释器等)。</em></li>\n</ul>\n",
            "tags": [
                "编译原理",
                "动手写ToyLang"
            ]
        },
        {
            "id": "http://yuyuaqwq.github.io/posts/c4d3.html",
            "url": "http://yuyuaqwq.github.io/posts/c4d3.html",
            "title": "【动手写ToyLang】0.前言",
            "date_published": "2022-10-28T13:18:53.000Z",
            "content_html": "<h1 id=\"关于\"><a class=\"markdownIt-Anchor\" href=\"#关于\">#</a> 关于</h1>\n<p><strong>本系列文章会手把手教你打造一门在别人看来是<emp>玩具</emp>的通用编程语言，事实也确实如此。</strong></p>\n<p>但计算机本身就是一门需要动手的学科，在对基本原理有一定程度的理解之后，自己动手实践才是学习的最好的捷径，为此制造 &quot;玩具&quot;，并不丢人。</p>\n<p>笔者对《编译原理》这门学科的学习程度也十分有限，因此本系列文章的读者不仅仅是你们，也包括我，写下的这篇文章也是支撑我继续动手实践的动力。<br>\n学完本系列文章之后，基本上可以对编译原理有一定程度的认知，再继续往下学习也就不会那么困难了。</p>\n<p><em>我会尽可能的查阅资料，以保证输出内容的可靠性，如果还是难以避免的出现了错误，望批评指正，感激不尽。</em></p>\n<hr>\n<h1 id=\"准备工作\"><a class=\"markdownIt-Anchor\" href=\"#准备工作\">#</a> 准备工作</h1>\n<h2 id=\"开发语言\"><a class=\"markdownIt-Anchor\" href=\"#开发语言\">#</a> 开发语言</h2>\n<p>这里我选用我个人较为常用的 C++ 作为开发语言，风格尽量以《Google C++ Style Guide》为准，在我个人能力范围内尽量写得 &quot;现代 C++&quot; 一点。</p>\n<p>当然，我个人也还是 C++ 彩笔，代码写得不好，还请理解。</p>\n<h2 id=\"开发环境\"><a class=\"markdownIt-Anchor\" href=\"#开发环境\">#</a> 开发环境</h2>\n<p>我基本上只在 Windows 上工作，因此选择自然是 <code>Visual Studio</code> ，你们可以选择自己喜欢的开发环境。</p>\n",
            "tags": [
                "编译原理",
                "动手写ToyLang"
            ]
        }
    ]
}