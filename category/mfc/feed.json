{
    "version": "https://jsonfeed.org/version/1",
    "title": "鹿鹿鱼鱼 • All posts by \"mfc\" category",
    "description": "人为什么要起床？",
    "home_page_url": "http://yuyuaqwq.github.io",
    "items": [
        {
            "id": "http://yuyuaqwq.github.io/posts/78f0.html",
            "url": "http://yuyuaqwq.github.io/posts/78f0.html",
            "title": "【MFC】探索窗口创建机制的实现原理",
            "date_published": "2022-10-06T04:48:45.000Z",
            "content_html": "<h1 id=\"何时创建窗口？\"><a href=\"#何时创建窗口？\" class=\"headerlink\" title=\"何时创建窗口？\"></a>何时创建窗口？</h1><p>我们在直接使用<code>Win32API</code>开发窗口程序的时候，一般都是在消息循环之前调用相关的函数创建窗口，那么MFC的窗口是在何时被创建的呢？</p>\n<p>实际上，我们重写了<code>InitInstance</code>成员虚函数，并在函数中编写了创建了窗口的代码。</p>\n<p>根据我们之前分析的程序流程，<code>InitInstance</code>的调用时机在<code>Run</code>之前，这也自然合情合理。</p>\n<p>还是之前的示例代码：</p>\n<details class=\"folding-tag\" blue><summary> 示例 </summary>\n              <div class='content'>\n              <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;afxwin.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">CMyFrameWnd</span> :<span class=\"keyword\">public</span> CFrameWnd &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">CMyWinApp</span> :<span class=\"keyword\">public</span> CWinApp &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">CMyWinApp</span>() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> BOOL <span class=\"title\">InitInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        CMyFrameWnd* frame = <span class=\"keyword\">new</span> CMyFrameWnd;</span><br><span class=\"line\">        frame-&gt;<span class=\"built_in\">Create</span>(<span class=\"literal\">nullptr</span>, <span class=\"string\">L&quot;MFCBase&quot;</span>);</span><br><span class=\"line\">        m_pMainWnd = frame;</span><br><span class=\"line\">        frame-&gt;<span class=\"built_in\">ShowWindow</span>(SW_SHOW);</span><br><span class=\"line\">        frame-&gt;<span class=\"built_in\">UpdateWindow</span>();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> TRUE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">CMyWinApp g_theApp;</span><br></pre></td></tr></table></figure>\n              </div>\n            </details>\n",
            "tags": [
                "MFC",
                "没饭吃"
            ]
        },
        {
            "id": "http://yuyuaqwq.github.io/posts/a6e.html",
            "url": "http://yuyuaqwq.github.io/posts/a6e.html",
            "title": "【MFC】探索程序启动机制的实现原理",
            "date_published": "2022-10-05T02:45:26.000Z",
            "content_html": "<h1 id=\"全局对象的构造\"><a href=\"#全局对象的构造\" class=\"headerlink\" title=\"全局对象的构造\"></a>全局对象的构造</h1><p>C++的对象在创建时，会调用构造函数。<br>而全局对象的构造时机，<emp>自然应当在入口函数`main/WinMain`被调用之前</emp>，否则我们也就无法在入口函数中使用全局对象了。</p>\n<p>这里以上节编写的示例代码为例，我们在代码中实例化了一个全局对象<code>g_theApp</code>，基于VS强大的源码调试能力，我们来对MFC程序的启动机制一探究竟。</p>\n<details class=\"folding-tag\" blue><summary> 示例 </summary>\n              <div class='content'>\n              <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;afxwin.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">CMyFrameWnd</span> :<span class=\"keyword\">public</span> CFrameWnd &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">CMyWinApp</span> :<span class=\"keyword\">public</span> CWinApp &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">CMyWinApp</span>() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> BOOL <span class=\"title\">InitInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        CMyFrameWnd* frame = <span class=\"keyword\">new</span> CMyFrameWnd;</span><br><span class=\"line\">        frame-&gt;<span class=\"built_in\">Create</span>(<span class=\"literal\">nullptr</span>, <span class=\"string\">L&quot;MFCBase&quot;</span>);</span><br><span class=\"line\">        m_pMainWnd = frame;</span><br><span class=\"line\">        frame-&gt;<span class=\"built_in\">ShowWindow</span>(SW_SHOW);</span><br><span class=\"line\">        frame-&gt;<span class=\"built_in\">UpdateWindow</span>();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> TRUE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">CMyWinApp g_theApp;</span><br></pre></td></tr></table></figure>\n              </div>\n            </details>\n<h2 id=\"g-theApp构造调试\"><a href=\"#g-theApp构造调试\" class=\"headerlink\" title=\"g_theApp构造调试\"></a><code>g_theApp</code>构造调试</h2><ol>\n<li>让光标停留在<code>CMyWinApp g_theApp;</code>行，按下<code>F9</code>，设置断点<ul>\n<li><img src=\"/posts/a6e/1.png\" class=\"\" title=\"这是一张图片\"></li>\n</ul>\n</li>\n<li><code>F5</code>运行，让程序中断到当前行</li>\n<li><code>F11</code>单步步入，进入到<code>CMyWinApp</code>的构造函数中</li>\n<li>继续单步步入，进入到基类<code>CWinApp</code>的构造函数中</li>\n</ol>\n<p>到这里，我们就开始调试到MFC的源码了。</p>\n<h2 id=\"g-theApp构造分析\"><a href=\"#g-theApp构造分析\" class=\"headerlink\" title=\"g_theApp构造分析\"></a><code>g_theApp</code>构造分析</h2><p>接下来我们选择部分代码进行讲解</p>\n<details class=\"folding-tag\" blue><summary> CWinApp::CWinApp 部分代码一 </summary>\n              <div class='content'>\n              <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CWinApp::<span class=\"built_in\">CWinApp</span>(LPCTSTR lpszAppName)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (lpszAppName != <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        m_pszAppName = _tcsdup(lpszAppName);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        m_pszAppName = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// initialize CWinThread state</span></span><br><span class=\"line\">    AFX_MODULE_STATE* pModuleState = _AFX_CMDTARGET_GETSTATE();</span><br><span class=\"line\">    <span class=\"built_in\">ENSURE</span>(pModuleState);</span><br><span class=\"line\">    AFX_MODULE_THREAD_STATE* pThreadState = pModuleState-&gt;m_thread;</span><br><span class=\"line\">    <span class=\"built_in\">ENSURE</span>(pThreadState);</span><br><span class=\"line\">    <span class=\"built_in\">ASSERT</span>(<span class=\"built_in\">AfxGetThread</span>() == <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    pThreadState-&gt;m_pCurrentWinThread = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    <span class=\"built_in\">ASSERT</span>(<span class=\"built_in\">AfxGetThread</span>() == <span class=\"keyword\">this</span>);</span><br><span class=\"line\">    m_hThread = ::<span class=\"built_in\">GetCurrentThread</span>();</span><br><span class=\"line\">    m_nThreadID = ::<span class=\"built_in\">GetCurrentThreadId</span>();</span><br><span class=\"line\">    ......</span><br></pre></td></tr></table></figure>\n              </div>\n            </details>\n<div class=\"note warning no-icon flat\"><p><code>AFX_MODULE_STATE* pModuleState = _AFX_CMDTARGET_GETSTATE();</code></p>\n</div>\n<p>MFC类库中有一个描述<strong>主模块状态</strong>的全局对象，<code>_AFX_CMDTARGET_GETSTATE</code>宏函数就是用于获取该全局对象的地址</p>\n<div class=\"note warning no-icon flat\"><p><code>AFX_MODULE_THREAD_STATE* pThreadState = pModuleState-&gt;m_thread;</code></p>\n</div>\n<p>以及描述<strong>主模块线程状态</strong>的全局对象，其地址保存在<strong>主模块状态</strong>中的成员中。</p>\n<div class=\"tip \"><p>MFC在设计时想必已经安排好了构造顺序已确保程序运行的正确性，此处我们的全局对象<code>g_theApp</code>的父类部分<code>CWinApp</code>在构造时才能够正确使用这些全局对象，这里不再做深究。</p>\n</div>\n<div class=\"note warning no-icon flat\"><p><code>pThreadState-&gt;m_pCurrentWinThread = this;</code></p>\n</div>\n<p>将我们创建的<code>g_theApp</code>的地址保存到<strong>主模块线程状态</strong>的<code>m_pCurrentWinThread</code>成员中。</p>\n<details class=\"folding-tag\" blue><summary> CWinApp::CWinApp 部分代码二 </summary>\n              <div class='content'>\n              <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// initialize CWinApp state</span></span><br><span class=\"line\"><span class=\"built_in\">ASSERT</span>(afxCurrentWinApp == <span class=\"literal\">NULL</span>); <span class=\"comment\">// only one CWinApp object please</span></span><br><span class=\"line\">pModuleState-&gt;m_pCurrentWinApp = <span class=\"keyword\">this</span>;</span><br><span class=\"line\"><span class=\"built_in\">ASSERT</span>(<span class=\"built_in\">AfxGetApp</span>() == <span class=\"keyword\">this</span>);</span><br><span class=\"line\">......</span><br></pre></td></tr></table></figure>\n              </div>\n            </details>\n<div class=\"note warning no-icon flat\"><p><code>pModuleState-&gt;m_pCurrentWinApp = this;</code></p>\n</div>\n<p>将我们创建的<code>g_theApp</code>的地址保存到<strong>主模块状态</strong>的<code>m_pCurrentWinApp</code>成员中。</p>\n<hr>\n<h1 id=\"WinMain的启动流程\"><a href=\"#WinMain的启动流程\" class=\"headerlink\" title=\"WinMain的启动流程\"></a>WinMain的启动流程</h1><p>回忆我们的<code>CMyWinApp</code>类，在类中我们重写了虚函数<code>InitInstance</code>。<br>见名知意，我们猜测，这是一个初始化函数，但是我们不清楚函数是何时、如何被调用，因此我们需要继续分析MFC的源码。</p>\n<h2 id=\"InitInstance回调调试\"><a href=\"#InitInstance回调调试\" class=\"headerlink\" title=\"InitInstance回调调试\"></a><code>InitInstance</code>回调调试</h2><ol>\n<li>在<code>CMyFrameWnd* frame = new CMyFrameWnd;</code>行设置断点</li>\n<li>运行程序，中断在此行</li>\n<li>查看<code>调用堆栈</code>，我们可以看到<code>InitInstance</code>的调用函数，以及调用函数的调用函数…等层级关系。<ul>\n<li>在这里我们也看到了我们熟悉的<code>WinMain</code>函数，说明<code>InitInstance</code>是在<code>WinMain</code>执行过程中被调用的。</li>\n<li>而我们并没有实现<code>WinMain</code>，那么<code>WinMain</code>自然也是由MFC实现的，至此，我们先前的一个疑惑也解决了。</li>\n</ul>\n</li>\n<li>从<code>调用堆栈</code>中定位到<code>WinMain</code>函数，在此处设置断点，重新运行程序。<ul>\n<li><img src=\"/posts/a6e/2.png\" class=\"\" title=\"这是一张图片\"></li>\n</ul>\n</li>\n<li><code>WinMain</code>函数中仅有一行代码，即调用<code>AfxWinMain</code>并返回，单步进入</li>\n</ol>\n<h2 id=\"AfxWinMain源码分析\"><a href=\"#AfxWinMain源码分析\" class=\"headerlink\" title=\"AfxWinMain源码分析\"></a><code>AfxWinMain</code>源码分析</h2><p>我们依旧选择我们感兴趣的源码进行讲解</p>\n<p><code>AfxWinMain</code>是MFC实现的全局函数。<br><div class=\"tip \"><p>以<code>Afx</code>开头的函数，基本上都是MFC实现的全局函数。</p>\n</div></p>\n<details class=\"folding-tag\" blue><summary> AfxWinMain 部分代码 </summary>\n              <div class='content'>\n              <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> AFXAPI <span class=\"title\">AfxWinMain</span><span class=\"params\">(HINSTANCE hInstance, HINSTANCE hPrevInstance,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t_In_ LPTSTR lpCmdLine, <span class=\"type\">int</span> nCmdShow)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">ASSERT</span>(hPrevInstance == <span class=\"literal\">NULL</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> nReturnCode = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\tCWinThread* pThread = <span class=\"built_in\">AfxGetThread</span>();</span><br><span class=\"line\">\tCWinApp* pApp = <span class=\"built_in\">AfxGetApp</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// AFX internal initialization</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!<span class=\"built_in\">AfxWinInit</span>(hInstance, hPrevInstance, lpCmdLine, nCmdShow))</span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> InitFailure;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// App global initializations (rare)</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (pApp != <span class=\"literal\">NULL</span> &amp;&amp; !pApp-&gt;<span class=\"built_in\">InitApplication</span>())</span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> InitFailure;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// Perform specific initializations</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!pThread-&gt;<span class=\"built_in\">InitInstance</span>())</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (pThread-&gt;m_pMainWnd != <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">TRACE</span>(traceAppMsg, <span class=\"number\">0</span>, <span class=\"string\">&quot;Warning: Destroying non-NULL m_pMainWnd\\n&quot;</span>);</span><br><span class=\"line\">\t\t\tpThread-&gt;m_pMainWnd-&gt;<span class=\"built_in\">DestroyWindow</span>();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tnReturnCode = pThread-&gt;<span class=\"built_in\">ExitInstance</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> InitFailure;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tnReturnCode = pThread-&gt;<span class=\"built_in\">Run</span>();</span><br><span class=\"line\">    ......</span><br></pre></td></tr></table></figure>\n              </div>\n            </details>\n<div class=\"note warning no-icon flat\"><p><code>CWinThread* pThread = AfxGetThread();</code></p>\n</div>\n<p>此函数获取<strong>主模块线程状态</strong>的<code>m_pCurrentWinThread</code>成员。<br>先前我们在构造<code>g_theApp</code>的过程中已经看到，<strong>主模块线程状态</strong>的<code>m_pCurrentWinThread</code>成员保存的是<code>g_theApp</code>的地址；<br>因此，此函数实际上是获取<code>g_theApp</code>的地址，也就是说，在MFC的启动流程中，可能要使用我们创建的全局对象<code>g_theApp</code>。</p>\n<div class=\"note warning no-icon flat\"><p><code>CWinApp* pApp = AfxGetApp();</code></p>\n</div>\n<p>此函数获取<strong>主模块状态</strong>的<code>m_pCurrentWinApp</code>成员。<br>先前我们在构造<code>g_theApp</code>的过程中已经看到，<strong>主模块状态</strong>的<code>m_pCurrentWinApp</code>成员保存的是<code>g_theApp</code>的地址；<br>与AfxGetThread作用类似。</p>\n<div class=\"tip \"><p><code>CWinApp*</code>指向<code>CMyWinApp</code>类型的对象，我们是能够理解的；<br>但是为什么<code>CWinThread*</code>的赋值也能被允许呢？因为<code>CWinApp</code>类就继承自<code>CWinThread</code>类。</p>\n</div>\n<div class=\"note warning no-icon flat\"><p><code>if (pApp != NULL &amp;&amp; !pApp-&gt;InitApplication())</code></p>\n</div>\n<p>当前行实际上调用了<code>g_theApp</code>的<code>InitApplication</code>函数，我们并没有提供此函数，因此只可能是<code>g_theApp</code>的父类部分提供的。<br>这个函数实际上也是虚函数，我们能够重写它，一般在我们希望做一些应用程序初始化的工作时重写。</p>\n<div class=\"note warning no-icon flat\"><p><code>if (!pThread-&gt;InitInstance())</code></p>\n</div>\n<p>终于又到了我们熟悉的部分了，<code>InitInstance</code>就是我们重写的函数，此时<code>pThread</code>指向<code>g_theApp</code>，这就是<code>多态</code>了。</p>\n<details class=\"folding-tag\" blue><summary> CMyWinApp::InitInstance </summary>\n              <div class='content'>\n              <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">virtual</span> BOOL <span class=\"title\">InitInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    CMyFrameWnd* frame = <span class=\"keyword\">new</span> CMyFrameWnd;</span><br><span class=\"line\">    frame-&gt;<span class=\"built_in\">Create</span>(<span class=\"literal\">nullptr</span>, <span class=\"string\">L&quot;MFCBase&quot;</span>);</span><br><span class=\"line\">    m_pMainWnd = frame;</span><br><span class=\"line\">    frame-&gt;<span class=\"built_in\">ShowWindow</span>(SW_SHOW);</span><br><span class=\"line\">    frame-&gt;<span class=\"built_in\">UpdateWindow</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> TRUE;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n              </div>\n            </details>\n<p>我们暂时略过具体代码，最终是通过<code>return TRUE</code>返回的；</p>\n<div class=\"note warning no-icon flat\"><p><code>nReturnCode = pThread-&gt;Run();</code></p>\n</div>\n<p>根据<code>AfxWinMain</code>中的代码的逻辑，我们会走到<code>Run</code>这个函数。</p>\n<hr>\n<h1 id=\"不可或缺的消息循环\"><a href=\"#不可或缺的消息循环\" class=\"headerlink\" title=\"不可或缺的消息循环\"></a>不可或缺的消息循环</h1><p>在直接使用<code>Win32API</code>开发界面程序时，我们都会编写消息循环以阻塞主线程，避免<code>WinMain</code>返回后终止进程。<br>MFC程序自然也不例外，而MFC的消息循环究竟编写在哪里呢？<br>其实读者只要在调试时步过<code>nReturnCode = pThread-&gt;Run();</code>，就会使得程序直接运行起来，不再处于中断状态，因而得知，<code>Run</code>成员函数封装了消息循环。</p>\n<h2 id=\"CWinApp-Run的源码分析\"><a href=\"#CWinApp-Run的源码分析\" class=\"headerlink\" title=\"CWinApp::Run的源码分析\"></a><code>CWinApp::Run</code>的源码分析</h2><details class=\"folding-tag\" blue><summary> CWinApp::Run </summary>\n              <div class='content'>\n              <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">CWinApp::Run</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (m_pMainWnd == <span class=\"literal\">NULL</span> &amp;&amp; <span class=\"built_in\">AfxOleGetUserCtrl</span>())</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// Not launched /Embedding or /Automation, but has no main window!</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">TRACE</span>(traceAppMsg, <span class=\"number\">0</span>, <span class=\"string\">&quot;Warning: m_pMainWnd is NULL in CWinApp::Run - quitting application.\\n&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">AfxPostQuitMessage</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> CWinThread::<span class=\"built_in\">Run</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n              </div>\n            </details>\n<div class=\"note warning no-icon flat\"><p><code>if (m_pMainWnd == NULL &amp;&amp; AfxOleGetUserCtrl())</code></p>\n</div>\n<p>我们忽略对<code>AfxOleGetUserCtrl</code>函数的调用，<code>m_pMainWnd</code>是不是有些眼熟？<br>我们在重写<code>InitInstance</code>时，使<code>m_pMainWnd</code>指向了<code>new</code>出来的<code>CMyFrameWnd</code>对象。<br>而我们在调用<code>Run</code>成员函数时，就是以<code>g_theApp</code>的身份进行调用的。<br>因此，在<code>Run</code>成员函数中访问<code>m_pMainWnd</code>，自然得到我们当时<code>new</code>出来的<code>CMyFrameWnd</code>对象。<br><emp>这也就是 g_theApp 全局对象的主窗口。</emp></p>\n<div class=\"note warning no-icon flat\"><p><code>return CWinThread::Run();</code></p>\n</div>\n<p>接下来我们调用<code>CWinApp</code>的父类<code>CWinThread</code>的<code>Run</code>成员函数</p>\n<details class=\"folding-tag\" blue><summary> CWinApp::Run 第一部分 </summary>\n              <div class='content'>\n              <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">CWinThread::Run</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">ASSERT_VALID</span>(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">\t_AFX_THREAD_STATE* pState = <span class=\"built_in\">AfxGetThreadState</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// for tracking the idle time state</span></span><br><span class=\"line\">\tBOOL bIdle = TRUE;</span><br><span class=\"line\">\tLONG lIdleCount = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// acquire and dispatch messages until a WM_QUIT message is received.</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (;;)        <span class=\"comment\">// 开始消息循环</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 如果没有消息(PeekMessage返回0)</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// phase1: check to see if we can do idle work</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (bIdle &amp;&amp;</span><br><span class=\"line\">\t\t\t!::<span class=\"built_in\">PeekMessage</span>(&amp;(pState-&gt;m_msgCur), <span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span>, PM_NOREMOVE))</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// call OnIdle while in bIdle state</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!<span class=\"built_in\">OnIdle</span>(lIdleCount++))      <span class=\"comment\">// 调用成员虚函数OnIdle，进入空闲处理</span></span><br><span class=\"line\">\t\t\t\tbIdle = FALSE; <span class=\"comment\">// assume &quot;no idle&quot; state</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">        ......</span><br></pre></td></tr></table></figure>\n              </div>\n            </details>\n<p>代码并不复杂，这里直接在代码中注释，可以自行阅读。</p>\n<div class=\"tip \"><p>在MFC中程序中调用<code>Win32API</code>时，通常都会指明调用的是全局作用域下的函数 :: 。</p>\n</div>\n<details class=\"folding-tag\" blue><summary> CWinApp::Run 第二部分 </summary>\n              <div class='content'>\n              <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">        ......</span><br><span class=\"line\"><span class=\"comment\">// phase2: pump messages while available</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">do</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// pump message, but quit on WM_QUIT</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!<span class=\"built_in\">PumpMessage</span>())</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"built_in\">ExitInstance</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// reset &quot;no idle&quot; state after pumping &quot;normal&quot; message</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">//if (IsIdleMessage(&amp;m_msgCur))</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">IsIdleMessage</span>(&amp;(pState-&gt;m_msgCur)))</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tbIdle = TRUE;</span><br><span class=\"line\">\t\t\t\tlIdleCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">while</span> (::<span class=\"built_in\">PeekMessage</span>(&amp;(pState-&gt;m_msgCur), <span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span>, PM_NOREMOVE));        <span class=\"comment\">// 如果连续有消息就继续处理</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n              </div>\n            </details>\n<p><code>if (!PumpMessage())</code><br>MFC在此函数中封装了对<code>GetMessage</code>、<code>TranslateMessage</code>、<code>DispatchMessage</code>函数的调用，读者感兴趣可以自行跟进，这里就不再分析了。</p>\n<p>一旦<code>PumpMessage</code>返回<code>FALSE</code>，就会调用虚成员函数<code>ExitInstance</code>并退出消息循环。<br>而<code>PumpMessage</code>返回<code>FALSE</code>的条件即是<code>GetMessage</code>获得<code>WM_QUIT</code>消息，程序结束。</p>\n<p>我们也可以重写<code>ExitInstance</code>，在程序结束前做必要的资源释放。</p>\n<p>从<code>Run</code>成员函数返回后，也会一路返回到<code>WinMain</code>，程序也就退出了。</p>\n<h1 id=\"基本流程\"><a href=\"#基本流程\" class=\"headerlink\" title=\"基本流程\"></a>基本流程</h1><ol>\n<li><p>首先，我们在编写MFC应用时，需要实例化一个类型为<code>CWinApp</code>的全局对象。</p>\n<ul>\n<li>如果需要重写初始化等成员虚函数，则需要创建继承自<code>CWinApp</code>的子类的对象(此处命名为<code>g_theApp</code>)。</li>\n</ul>\n</li>\n<li><p>在<code>g_theApp</code>被构造时，会使MFC定义的全局变量<strong>主模块状态</strong>和<strong>主模块线程状态</strong>的成员指向<code>g_theApp</code>地址。</p>\n</li>\n<li><p>程序进入<code>WinMain</code>函数，会通过全局变量<strong>主模块状态</strong>和<strong>主模块线程状态</strong>得到<code>g_theApp</code>地址，再以<code>g_theApp</code>的身份调用必要的成员虚函数。</p>\n<ul>\n<li>初始化</li>\n<li>消息循环</li>\n<li>退出</li>\n</ul>\n</li>\n</ol>\n<p>至此，我们基本上对MFC程序的启动流程有了一个大致的认知。</p>\n<p>而窗口的创建、消息的接收处理等部分，我们留到下一篇再叙。</p>\n",
            "tags": [
                "MFC",
                "没饭吃"
            ]
        },
        {
            "id": "http://yuyuaqwq.github.io/posts/7c79.html",
            "url": "http://yuyuaqwq.github.io/posts/7c79.html",
            "title": "【MFC】初识MFC",
            "date_published": "2022-10-04T11:33:52.000Z",
            "content_html": "<h1 id=\"mfc简述\"><a class=\"markdownIt-Anchor\" href=\"#mfc简述\">#</a> MFC 简述</h1>\n<p><strong>MFC (Microsoft Foundation Classes)，微软基础类库；</strong><br>\n是微软使用 <code>C++</code>  的特性，在 <code>Win32API</code>  基础上再次进行的封装。</p>\n<hr>\n<h1 id=\"mfc基本使用\"><a class=\"markdownIt-Anchor\" href=\"#mfc基本使用\">#</a> MFC 基本使用</h1>\n<p>MFC 只是一个 C++ 类库，我们只需要对 C++ 有一定了解，就能够理解 MFC 的工作机制。<br>\n而微软的宇宙第一 IDE <code>Visual Studio</code>  本身也替我们做好了许多工作，这里以 vs2022 为例，对 MFC 的安装与使用进行简单的说明。</p>\n<h2 id=\"安装\"><a class=\"markdownIt-Anchor\" href=\"#安装\">#</a> 安装</h2>\n<ol>\n<li>运行 <code>Visual Studio Installer</code>\n<ul>\n<li>\n<img src=\"/posts/7c79/1.png\" class=\"\" title=\"这是一张图片\">\n</li>\n</ul>\n</li>\n<li>点击 <code>修改</code></li>\n<li>选择 <code>单个组件</code> 选项卡</li>\n<li>搜索 <code>MFC</code> ，勾选需要的组件\n<ul>\n<li>\n<img src=\"/posts/7c79/2.png\" class=\"\" title=\"这是一张图片\">\n</li>\n</ul>\n</li>\n<li>点击 <code>修改</code> ，等待完成即可\n<ul>\n<li>我这里已经装过了，就不重新做演示了</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"新建项目\"><a class=\"markdownIt-Anchor\" href=\"#新建项目\">#</a> 新建项目</h2>\n<ol>\n<li>运行 <code>Visual Studio 2022</code></li>\n<li>点击 <code>创建新项目</code></li>\n<li>选择 <code>空项目</code></li>\n<li>项目名称随意，我这里写 <code>MFCTestProject</code></li>\n</ol>\n<h2 id=\"配置项目\"><a class=\"markdownIt-Anchor\" href=\"#配置项目\">#</a> 配置项目</h2>\n<p>由于是空项目，什么都没有，我们需要自行做一些必要的设置。</p>\n<ol>\n<li>右键 <code>MFCTestProject</code>  项目，选择 <code>属性</code></li>\n<li><code>属性页</code> 中选择 <code>高级</code> 选项卡</li>\n<li><code>MFC的使用</code> 选项，修改为 <code>在静态库中使用MFC</code>\n<ul>\n<li><code>在共享DLL中使用MFC</code>  调试时无法找到 MFC 的源码。</li>\n</ul>\n</li>\n<li><code>属性页</code> 中展开 <code>链接器</code> ，选择 <code>系统</code> 选项卡</li>\n<li><code>子系统</code> 选择 <code>窗口(/SUBSYSTEM:WINDOWS)</code></li>\n</ol>\n<h2 id=\"编写源代码\"><a class=\"markdownIt-Anchor\" href=\"#编写源代码\">#</a> 编写源代码</h2>\n<ol>\n<li>新建 <code>.cpp</code>  文件，文件名随意</li>\n<li>编写如下示例代码 <details class=\"folding-tag\" blue><summary> 示例 </summary>\n              <div class='content'>\n              <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;afxwin.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">CMyFrameWnd</span> :<span class=\"keyword\">public</span> CFrameWnd &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">CMyWinApp</span> :<span class=\"keyword\">public</span> CWinApp &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">CMyWinApp</span>() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> BOOL <span class=\"title\">InitInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        CMyFrameWnd* frame = <span class=\"keyword\">new</span> CMyFrameWnd;</span><br><span class=\"line\">        frame-&gt;<span class=\"built_in\">Create</span>(<span class=\"literal\">nullptr</span>, <span class=\"string\">L&quot;MFCBase&quot;</span>);</span><br><span class=\"line\">        m_pMainWnd = frame;</span><br><span class=\"line\">        frame-&gt;<span class=\"built_in\">ShowWindow</span>(SW_SHOW);</span><br><span class=\"line\">        frame-&gt;<span class=\"built_in\">UpdateWindow</span>();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> TRUE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">CMyWinApp g_theApp;</span><br></pre></td></tr></table></figure>\n              </div>\n            </details>\n</li>\n<li>F5 运行，编译运行正常会出现这样的窗口\n<ul>\n<li>\n<img src=\"/posts/7c79/3.png\" class=\"\" title=\"这是一张图片\">\n</li>\n</ul>\n</li>\n</ol>\n<p>至此，我们就已经建立了一个非常简单的 MFC 程序，并且它还能够运行。</p>\n<p>接下来我们简单对代码进行一些注释：</p>\n<div class=\"note warning no-icon flat\"><p><code>#include &lt;afxwin.h&gt;</code></p>\n</div>\n<p>类似 <code>Win32API</code>  开发时使用的 <code>#include &lt;windows.h&gt;</code></p>\n<div class=\"note warning no-icon flat\"><p><code>class CMyFrameWnd :public CFrameWnd {...</code></p>\n</div>\n<p>创建继承于 <code>CFrameWnd</code>  类的 <code>CMyFrameWnd</code>  类<br>\n <code>CFrameWnd</code>  是对窗口框架的封装</p>\n<div class=\"note warning no-icon flat\"><p><code>class CMyWinApp :public CWinApp {...</code></p>\n</div>\n<p>创建继承于 <code>CWinApp</code>  类的 <code>CMyWinApp</code>  类<br>\n <code>CWinApp</code>  是对应用程序执行流程的抽象封装</p>\n<div class=\"note warning no-icon flat\"><p><code>virtual BOOL InitInstance() {...</code></p>\n</div>\n<p>在 <code>CMyWinApp</code>  类中重写 <code>CWinApp</code>  类的 <code>InitInstance</code>  成员虚函数</p>\n<div class=\"note warning no-icon flat\"><p><code>CMyWinApp g_theApp;</code></p>\n</div>\n<p>基于 <code>CMyWinApp</code>  类实例化全局对象 <code>g_theApp</code></p>\n<div class=\"note purple icon-padding simple\"><i class=\"note-icon fas fa-fan\"></i><p>当然，这些代码也许会使你感到困惑，毕竟代码中甚至找不到你最熟悉的 main、WinMain，为什么它能够跑起来？</p>\n<p>我们将在下篇文章探索 MFC 的程序启动机制。</p>\n</div>\n<hr>\n",
            "tags": [
                "MFC",
                "没饭吃"
            ]
        },
        {
            "id": "http://yuyuaqwq.github.io/posts/c22c.html",
            "url": "http://yuyuaqwq.github.io/posts/c22c.html",
            "title": "【MFC】探索消息映射机制的实现原理",
            "date_published": "2022-10-04T05:07:21.000Z",
            "content_html": "<h1 id=\"消息机制简述\"><a href=\"#消息机制简述\" class=\"headerlink\" title=\"消息机制简述\"></a>消息机制简述</h1><p>我们知道，Windows的窗口是由<strong>消息</strong>驱动的；<br>Windows通过捕获鼠标、键盘等输入设备产生的动作，再生成对应的消息，并传递给相应的窗口所属的线程。</p>\n<div class=\"note purple icon-padding simple\"><i class=\"note-icon fas fa-fan\"></i><p>直接基于<code>Win32API</code>开发时，我们需要在注册窗口类时指定<strong>窗口过程函数</strong>，以告知Windows回调(传递消息)的入口。</p>\n</div>\n<hr>\n<h1 id=\"MFC的消息映射\"><a href=\"#MFC的消息映射\" class=\"headerlink\" title=\"MFC的消息映射\"></a>MFC的消息映射</h1><p>而MFC为我们提供了一种更为方便的机制，<emp>直接为一个消息与一个函数建立映射关系</emp>，在消息产生时，回调此函数，而不再需要我们去自行分发。</p>\n<details class=\"folding-tag\" blue><summary> 消息映射示例 </summary>\n              <div class='content'>\n              <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;afxwin.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">CMyFrameWnd</span> : <span class=\"keyword\">public</span> CFrameWnd &#123;</span><br><span class=\"line\">\t<span class=\"built_in\">DECLARE_MESSAGE_MAP</span>()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\">LRESULT <span class=\"title\">OnCreate</span><span class=\"params\">(WPARAM wParam, LPARAM lParam)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">AfxMessageBox</span>(<span class=\"string\">L&quot;Window Create!&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">BEGIN_MESSAGE_MAP</span>(CMyFrameWnd, CFrameWnd)</span><br><span class=\"line\">\t<span class=\"built_in\">ON_MESSAGE</span>(WM_CREATE, OnCreate)   <span class=\"comment\">// 将WM_CREATE与CMyFrameWnd类的成员函数OnCreate建立映射</span></span><br><span class=\"line\"><span class=\"built_in\">END_MESSAGE_MAP</span>()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">CMyWinApp</span> : <span class=\"keyword\">public</span> CWinApp &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">CMyWinApp</span>() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> BOOL <span class=\"title\">InitInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tCMyFrameWnd* frame = <span class=\"keyword\">new</span> CMyFrameWnd;</span><br><span class=\"line\">\t\tframe-&gt;<span class=\"built_in\">Create</span>(<span class=\"literal\">nullptr</span>, <span class=\"string\">L&quot;MFCBase&quot;</span>);</span><br><span class=\"line\">\t\tm_pMainWnd = frame;</span><br><span class=\"line\">\t\tframe-&gt;<span class=\"built_in\">ShowWindow</span>(SW_SHOW);</span><br><span class=\"line\">\t\tframe-&gt;<span class=\"built_in\">UpdateWindow</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> TRUE;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">CMyWinApp g_theApp;</span><br></pre></td></tr></table></figure>\n              </div>\n            </details>\n<h2 id=\"消息映射宏\"><a href=\"#消息映射宏\" class=\"headerlink\" title=\"消息映射宏\"></a>消息映射宏</h2><p>MFC的消息映射是通过几个<strong>宏函数</strong>来实现的，我们以上述代码为例，将宏展开，一探究竟。</p>\n<ul>\n<li>声明宏<br>  MFC的声明宏，就是在窗口类中声明两个受保护的成员函数。  <details class=\"folding-tag\" blue><summary> ECLARE_MESSAGE_MAP() </summary>\n              <div class='content'>\n              <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">const</span> AFX_MSGMAP* PASCAL <span class=\"title\">GetThisMessageMap</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">const</span> AFX_MSGMAP* <span class=\"title\">GetMessageMap</span><span class=\"params\">()</span> <span class=\"type\">const</span></span>;</span><br></pre></td></tr></table></figure>\n              </div>\n            </details></li>\n<li><p>定义宏<br>  定义则稍显复杂，由多个宏函数组成，实际上是在实现声明宏声明的成员函数。</p>\n  <details class=\"folding-tag\" blue><summary> BEGIN_MESSAGE_MAP() </summary>\n              <div class='content'>\n              <p><code>BEGIN_MESSAGE_MAP(CMyFrameWnd, CFrameWnd)</code><br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">PTM_WARNING_DISABLE</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">const</span> AFX_MSGMAP* <span class=\"title\">CMyFrameWnd::GetMessageMap</span><span class=\"params\">()</span> <span class=\"type\">const</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"built_in\">GetThisMessageMap</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">const</span> AFX_MSGMAP* PASCAL <span class=\"title\">CMyFrameWnd::GetThisMessageMap</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">typedef</span> CMyFrameWnd ThisClass;</span><br><span class=\"line\">\t<span class=\"keyword\">typedef</span> CFrameWnd TheBaseClass;</span><br><span class=\"line\">\t__pragma(<span class=\"built_in\">warning</span>(push))</span><br><span class=\"line\">\t__pragma(<span class=\"built_in\">warning</span>(disable: <span class=\"number\">4640</span>))</span><br><span class=\"line\">\t<span class=\"type\">static</span> <span class=\"type\">const</span> AFX_MSGMAP_ENTRY _messageEntries[] =</span><br><span class=\"line\">\t&#123;</span><br></pre></td></tr></table></figure></p>\n              </div>\n            </details>\n  <details class=\"folding-tag\" blue><summary> ON_MESSAGE() </summary>\n              <div class='content'>\n              <p><code>ON_MESSAGE(WM_CREATE, OnCreate)</code><br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 实际上是在为_messageEntries变量的初始化列表添加结构体元素</span></span><br><span class=\"line\">\t\t&#123; WM_CREATE, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, AfxSig_lwl, (AFX_PMSG)(AFX_PMSGW)(<span class=\"built_in\">static_cast</span>&lt;<span class=\"built_in\">LRESULT</span>(AFX_MSG_CALL CWnd::*)(WPARAM, LPARAM)&gt;(OnCreate))&#125;,</span><br></pre></td></tr></table></figure></p>\n              </div>\n            </details>\n  <details class=\"folding-tag\" blue><summary> END_MESSAGE_MAP() </summary>\n              <div class='content'>\n              <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t&#123; <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, AfxSig_end, (AFX_PMSG)<span class=\"number\">0</span> &#125;</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">\t__pragma(<span class=\"built_in\">warning</span>(pop))</span><br><span class=\"line\">\t<span class=\"type\">static</span> <span class=\"type\">const</span> AFX_MSGMAP messageMap =</span><br><span class=\"line\">\t&#123; &amp;TheBaseClass::GetThisMessageMap, &amp;_messageEntries[<span class=\"number\">0</span>] &#125;;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &amp;messageMap;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">PTM_WARNING_RESTORE</span><br></pre></td></tr></table></figure>\n              </div>\n            </details>\n</li>\n</ul>\n<ul>\n<li>整体展开<details class=\"folding-tag\" blue><summary> 消息映射示例-宏展开 </summary>\n              <div class='content'>\n              <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;afxwin.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">class</span> <span class=\"title class_\">CMyFrameWnd</span> :<span class=\"keyword\">public</span> CFrameWnd &#123;</span><br><span class=\"line\">  <span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">const</span> AFX_MSGMAP* PASCAL <span class=\"title\">GetThisMessageMap</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">const</span> AFX_MSGMAP* <span class=\"title\">GetMessageMap</span><span class=\"params\">()</span> <span class=\"type\">const</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">LRESULT <span class=\"title\">OnCreate</span><span class=\"params\">(WPARAM wParam, LPARAM lParam)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">AfxMessageBox</span>(<span class=\"string\">L&quot;Window Create!&quot;</span>);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\">PTM_WARNING_DISABLE</span></span><br><span class=\"line\"><span class=\"function\">  <span class=\"type\">const</span> AFX_MSGMAP* <span class=\"title\">CMyFrameWnd::GetMessageMap</span><span class=\"params\">()</span> <span class=\"type\">const</span></span></span><br><span class=\"line\"><span class=\"function\">  </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">GetThisMessageMap</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"type\">const</span> AFX_MSGMAP* PASCAL <span class=\"title\">CMyFrameWnd::GetThisMessageMap</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">  </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> CMyFrameWnd ThisClass;</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> CFrameWnd TheBaseClass;</span><br><span class=\"line\">    __pragma(<span class=\"built_in\">warning</span>(push))</span><br><span class=\"line\">    __pragma(<span class=\"built_in\">warning</span>(disable: <span class=\"number\">4640</span>))</span><br><span class=\"line\">    <span class=\"type\">static</span> <span class=\"type\">const</span> AFX_MSGMAP_ENTRY _messageEntries[] =</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      &#123; WM_CREATE, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, AfxSig_lwl, (AFX_PMSG)(AFX_PMSGW)(<span class=\"built_in\">static_cast</span>&lt;<span class=\"built_in\">LRESULT</span>(AFX_MSG_CALL CWnd::*)(WPARAM, LPARAM)&gt;(OnCreate))&#125;,</span><br><span class=\"line\">      &#123; <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, AfxSig_end, (AFX_PMSG)<span class=\"number\">0</span> &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    __pragma(<span class=\"built_in\">warning</span>(pop))</span><br><span class=\"line\">    <span class=\"type\">static</span> <span class=\"type\">const</span> AFX_MSGMAP messageMap =</span><br><span class=\"line\">    &#123; &amp;TheBaseClass::GetThisMessageMap, &amp;_messageEntries[<span class=\"number\">0</span>] &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &amp;messageMap;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  PTM_WARNING_RESTORE</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">CMyWinApp</span> :<span class=\"keyword\">public</span> CWinApp &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">CMyWinApp</span>() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> BOOL <span class=\"title\">InitInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tCMyFrameWnd* frame = <span class=\"keyword\">new</span> CMyFrameWnd;</span><br><span class=\"line\">\t\tframe-&gt;<span class=\"built_in\">Create</span>(<span class=\"literal\">nullptr</span>, <span class=\"string\">L&quot;MFCBase&quot;</span>);</span><br><span class=\"line\">\t\tm_pMainWnd = frame;</span><br><span class=\"line\">\t\tframe-&gt;<span class=\"built_in\">ShowWindow</span>(SW_SHOW);</span><br><span class=\"line\">\t\tframe-&gt;<span class=\"built_in\">UpdateWindow</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> TRUE;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">CMyWinApp g_theApp;</span><br></pre></td></tr></table></figure>\n              </div>\n            </details>\n</li>\n</ul>\n<div class=\"note purple icon-padding simple\"><i class=\"note-icon fas fa-fan\"></i><p>通过宏添加消息映射时，实际上是重写了<code>CFrameWnd</code>类的<code>GetMessageMap</code>函数；<br>而<code>GetMessageMap</code>函数初始化了一个名为<code>_messageEntries</code>和<code>messageMap</code>的<strong>静态局部变量</strong>，并将该变量的地址返回。<br>我们简单猜测，<code>CFrameWnd</code>类内部在调用<code>GetMessageMap</code>函数时，就得到了我们所设定的<strong>映射关系表</strong>；<br>基于此映射表，就可以在其<strong>窗口过程函数</strong>中，<emp>根据消息调用对应的成员函数</emp>。</p>\n</div>\n<hr>\n",
            "tags": [
                "MFC",
                "没饭吃"
            ]
        }
    ]
}