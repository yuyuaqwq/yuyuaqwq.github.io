<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>2.连接多台终端设备：同轴电缆和集线器</title>
      <link href="/posts/5255.html"/>
      <url>/posts/5255.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.通过网线直连的两台终端设备</title>
      <link href="/posts/7ee4.html"/>
      <url>/posts/7ee4.html</url>
      
        <content type="html"><![CDATA[<h2 id="连接它们"><a class="markdownIt-Anchor" href="#连接它们">#</a> 连接它们</h2><p>连接两台终端设备最简单的方式是什么？其一当然是直接通过一条网线来连接。</p><p>假设我们准备了两台 PC，并用铜交叉线连接了它们：</p><ul><li><img src="/posts/7ee4/1.png" class="" title="这是一张图片"></li></ul><p>仅是如此还是不够的，我们还需要为他们配置一下 IP 地址：</p><ul><li><img src="/posts/7ee4/2.png" class="" title="这是一张图片"></li></ul><h2 id="ping"><a class="markdownIt-Anchor" href="#ping">#</a> Ping</h2><p>相信你应该对 Ping 这个命令有所耳闻，其作用是探测本机与网络中另一主机之间是否可达 (大白话就是连接正不正常)，基于 ICMP 协议 (现在不清楚这些协议也没关系，后面会讲)。<br>如果配置正确，我们的两台设备应该是能够 Ping 通的。</p><p>配置完 IP 地址之后，我们尝试一下用 <code>192.168.1.10</code>  这台设备去 Ping <code>192.168.1.11</code> 。</p><ul><li><img src="/posts/7ee4/3.gif" class="" title="这是一张动图"></li></ul><p>可以看到它们之间是连通的！<br>在此之上我们就可以使用耳熟能详的 UDP、TCP 协议去交换数据了。</p><h2 id="mac"><a class="markdownIt-Anchor" href="#mac">#</a> MAC</h2><p>设备之间不是通过 IP 去识别设备身份的，而是使用一个叫 MAC 地址的东西：</p><blockquote><p>MAC 地址（英语：Media Access Control Address），直译为媒体访问控制地址，也称为局域网地址（LAN Address），以太网地址（Ethernet Address）或物理地址（Physical Address），它是一个用来确认网络设备位置的地址。在 OSI 模型中，第三层网络层负责 IP 地址，第二层数据链接层则负责 MAC 地址。MAC 地址用于在网络中唯一标示一个网卡，一台设备若有一或多个网卡，则每个网卡都需要并会有一个唯一的 MAC 地址。        – 摘自维基百科</p></blockquote><p>简而言之，在每一台终端设备的网卡中，都会存在 MAC 地址，该地址应当是在出厂时就确定的、全世界唯一的地址。</p><p>处于统一网段内的设备的网络通信的部分过程是这样的：</p><ul><li>PC0 期望将某个数据包发送给 PC1，就需要为这个数据包的目标 MAC 地址字段填写为 PC1 的 MAC 地址。</li><li>在我们的示例中，PC0 会通过这一个接口让数据包流向 PC1。</li><li>PC1 收到之后，检查一下这个数据包是不是发给它自己的 (即检查数据包中的目标 MAC 地址和本机网卡 MAC 地址是否匹配)，如果是的话就会接收并向上层转发，如果不是则丢弃，负责此工作的是位于 TCP/IP 分层模型中的<strong>数据链路层</strong>。</li></ul><p>我们查看一下 PC0 和 PC1 的 MAC 地址：</p><ul><li><img src="/posts/7ee4/4.png" class="" title="这是一张图片"></li><li><img src="/posts/7ee4/5.png" class="" title="这是一张图片"></li></ul><p>以上的 Physical Address 就是这两台设备的网卡对应的 MAC 地址了，但是现在又会有一个新的问题：PC0 如何得知 PC1 的 MAC 地址？我们在 Ping 时只填写了目标 IP，并未填写目标 MAC；<br>关于这个问题你可以先思考一下 and 查阅资料，不懂也没关系，后续我会再详细解答。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.VsCode环境配置</title>
      <link href="/posts/54a8.html"/>
      <url>/posts/54a8.html</url>
      
        <content type="html"><![CDATA[<h1 id="Visual-Studio-Code-安装"><a href="#Visual-Studio-Code-安装" class="headerlink" title="Visual Studio Code 安装"></a>Visual Studio Code 安装</h1><p>这一块应该没什么好细说的，到<a href="https://code.visualstudio.com/">官网</a>上下载就可以了。</p><h1 id="虚拟机-安装"><a href="#虚拟机-安装" class="headerlink" title="虚拟机 安装"></a>虚拟机 安装</h1><p>我个人的开发环境是，物理机<code>Windows</code> + 虚拟机<code>Ubuntu</code>，因此需要安装一个虚拟机应用。<br>可以看你个人选择自己喜好的虚拟机应用，例如<code>VMWare Workstation</code>或<code>VirtualBox</code>。<br>这里我使用的是<code>VMWare Workstation</code>。</p><h1 id="Ubuntu-安装"><a href="#Ubuntu-安装" class="headerlink" title="Ubuntu 安装"></a>Ubuntu 安装</h1><p>虚拟机上安装<code>Ubuntu</code>的话，网上的教程也很多，也不赘述了，我这里装的是桌面版的。</p><h1 id="配置VsCode的远程开发"><a href="#配置VsCode的远程开发" class="headerlink" title="配置VsCode的远程开发"></a>配置VsCode的远程开发</h1><p>我们需要在<code>Windows</code>上进行<code>Linux</code>下的开发，<code>VsCode</code>给我们提供了一个很好的方案，使用<code>SSH</code>进行远程开发。</p><h2 id="VsCode扩展"><a href="#VsCode扩展" class="headerlink" title="VsCode扩展"></a>VsCode扩展</h2><p>这是<code>VsCode</code>中，微软提供的一个扩展。<br>首先启动<code>VsCode</code>，选择<code>Extensions(Ctrl+Shift+X)</code>选项卡，搜索<code>Remote</code>。<br>安装<code>Remote - SSH</code>扩展：</p><ol><li><code>Remote - SSH</code></li><li><code>Remote Explorer</code><ul><li>会被自动安装</li></ul></li><li><code>Remote - SSH: Editing Configuration Files</code><ul><li>会被自动安装</li></ul></li></ol><h2 id="OpenSSH"><a href="#OpenSSH" class="headerlink" title="OpenSSH"></a>OpenSSH</h2><p>在<code>Windows</code>和<code>Ubuntu</code>中都需要安装。</p><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>在虚拟机中测试了一下，似乎<code>Windows 10</code>上已经预置了。</p><h3 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a>Ubuntu</h3><p><code>Ubuntu</code>下的安装相当简单：<br><code>sudo apt-get install openssh-server</code></p><p>以下命令启动<code>ssh 服务</code>：<br><code>sudo /etc/init.d/ssh start</code></p><p>以下命令查看<code>ssh 服务</code>是否启用：<br><code>ps -e|grep ssh</code></p><p>有进程<code>sshd</code>在运行就是ok了。</p><h3 id="配置免密登录"><a href="#配置免密登录" class="headerlink" title="配置免密登录"></a>配置免密登录</h3><p>我们需要让<code>Linux端的OpenSSH服务</code>识别我们的身份，以实现免密登录。</p><h4 id="生成密钥对"><a href="#生成密钥对" class="headerlink" title="生成密钥对"></a>生成密钥对</h4><p><code>Windows PowerShell</code>中输入以下命令：<br><code>ssh-keygen</code></p><p>随后第一个待输入：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file in which to save the key (C:\Users\yuyu/.ssh/id_rsa):</span><br></pre></td></tr></table></figure><br>直接回车。</p><p>第二个待输入，可以直接回车不设置密码，如果为了安全你也可以设置：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Created directory &#x27;C:\Users\yuyu/.ssh&#x27;.</span><br><span class="line">Enter passphrase (empty for no passphrase):</span><br></pre></td></tr></table></figure></p><p>接下来要求重复输入密码，忽略了密码就继续回车：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enter same passphrase again:</span><br></pre></td></tr></table></figure></p><p>完成生成：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+---[RSA 3072]----+</span><br><span class="line">|                .|</span><br><span class="line">|        . o o . o|</span><br><span class="line">|     . E +o= X .o|</span><br><span class="line">|    . = ++*+= X.o|</span><br><span class="line">|     o .S==o.o.B |</span><br><span class="line">|       ooB.. .o o|</span><br><span class="line">|        +oo    .=|</span><br><span class="line">|          .    oo|</span><br><span class="line">|              .  |</span><br><span class="line">+----[SHA256]-----+</span><br></pre></td></tr></table></figure></p><p>接下来在以下用户路径中即可找到生成的公钥和私钥文件：<br><code>C:\Users\yuyu\.ssh</code></p><p>其中<code>yuyu</code>替换成你自己的用户名。</p><h4 id="配置公钥"><a href="#配置公钥" class="headerlink" title="配置公钥"></a>配置公钥</h4><p>如果你是安装的桌面版<code>Ubuntu</code>，就可以很轻松的在<code>VMWare Workstation</code>中通过拖动来传输文件。</p><p>在<code>Ubuntu桌面</code>中打开文件浏览器，会显示在Home目录下(实际路径是<code>/Home/你的用户名</code>、<code>~</code>)，按下<code>Ctrl + H</code>，即可显示隐藏文件。<br>可以看到一个目录<code>.ssh</code>，进入。</p><p>将<code>Windows</code>下生成的公钥文件<code>id_rsa.pub</code>复制到Linux的<code>.ssh</code>目录下。</p><p>通过以下命令将公钥追加到<code>authorized_keys</code>文件中：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd ~/.ssh</span><br><span class="line">cat id_rsa.pub &gt;&gt; authorized_keys</span><br><span class="line">rm id_rsa.pub</span><br></pre></td></tr></table></figure></p><h2 id="VsCode远程连接"><a href="#VsCode远程连接" class="headerlink" title="VsCode远程连接"></a>VsCode远程连接</h2><h3 id="查看ip"><a href="#查看ip" class="headerlink" title="查看ip"></a>查看ip</h3><p><code>Linux终端</code>下输入：<br><code>hostname -I</code></p><p>记下此ip</p><h3 id="配置连接目标"><a href="#配置连接目标" class="headerlink" title="配置连接目标"></a>配置连接目标</h3><p>回到<code>VsCode</code>中，由于我们安装了扩展，侧边选项卡新增了一个图标(<code>Remote Explorer</code>)。</p><p>选择该选项卡，随后点击<code>齿轮</code>按钮。</p><ul><li><img src="/posts/54a8/1.png" class="" title="这是一张图片"></li></ul><p>选择第1项：</p><ul><li><img src="/posts/54a8/2.png" class="" title="这是一张图片"></li></ul><p>配置如下：</p><ul><li><img src="/posts/54a8/3.png" class="" title="这是一张图片"><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Read more about SSH config files: https://linux.die.net/man/5/ssh_config</span></span><br><span class="line"><span class="comment"># Host alias</span></span><br><span class="line"><span class="comment">#     HostName hostname</span></span><br><span class="line"><span class="comment">#     User user</span></span><br><span class="line"></span><br><span class="line"><span class="string">Host</span> <span class="string">Ubuntu</span></span><br><span class="line">    <span class="string">HostName</span> <span class="number">192.168</span><span class="number">.229</span><span class="number">.132</span></span><br><span class="line">    <span class="string">User</span> <span class="string">yuyu</span></span><br><span class="line">    <span class="string">Port</span> <span class="number">22</span></span><br><span class="line"><span class="comment">#    IdentityFile ~/.ssh/id_rsa</span></span><br></pre></td></tr></table></figure></li></ul><p>将ip和用户名(都是<code>linux</code>的)修改为你的，保存即可。</p><p>点击齿轮旁边的刷新按钮，即出现了你添加的主机，开始连接吧！</p><ul><li><img src="/posts/54a8/4.png" class="" title="这是一张图片"></li></ul><p>这里选择<code>Linux</code>。</p><ul><li><img src="/posts/54a8/5.png" class="" title="这是一张图片"></li></ul><p>继续。</p><ul><li><img src="/posts/54a8/6.png" class="" title="这是一张图片"></li></ul><p>由于我们配置了免密登录，此时我们成功连接了！</p><ul><li><img src="/posts/54a8/7.png" class="" title="这是一张图片"></li></ul><p>接下来可以打开一个文件夹了，这里我创建了一个project的目录来管理我的项目。</p><ul><li><img src="/posts/54a8/8.png" class="" title="这是一张图片"></li></ul><p>至此，我们的远程开发环境就已经配置完毕了。</p><h1 id="在VsCode中构建与调试项目"><a href="#在VsCode中构建与调试项目" class="headerlink" title="在VsCode中构建与调试项目"></a>在VsCode中构建与调试项目</h1><h2 id="CMake"><a href="#CMake" class="headerlink" title="CMake"></a>CMake</h2><p>先前我就纠结过是选择CMake还是XMake来管理项目工程，最后还是选择了CMake，因为用的人比较多吧，学习一下总不是坏事。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p><code>Linux终端</code>输入命令：<br><code>sudo apt install cmake</code></p><h3 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h3><p>这里推荐两篇文章：<br>1.<a href="https://subingwen.cn/cmake/CMake-primer/index.html">CMake 保姆级教程（上）</a><br>2.<a href="https://subingwen.cn/cmake/CMake-advanced/">CMake 保姆级教程（下）</a></p><p>能够快速上手CMake并了解到足够在当前阶段使用的知识。</p><h2 id="VsCode扩展-1"><a href="#VsCode扩展-1" class="headerlink" title="VsCode扩展"></a>VsCode扩展</h2><ol><li><code>C/C++</code> &amp; <code>C/C++ Extension Pack</code><ul><li>语法、浏览、调试等辅助扩展。</li></ul></li><li><code>C/C++ Themes</code><br>`   - 非必要，C++主题。</li><li><code>CMake</code> &amp; <code>CMake Tools</code><ul><li>cmake</li></ul></li><li><code>Native Debug</code><ul><li>调试辅助扩展。</li></ul></li><li><code>C/C++ Compile Run</code><ul><li>非必要，单文件运行扩展，按f6即可直接编译运行当前浏览的源文件。</li></ul></li><li><code>clangd</code><ul><li>这个和<code>C/C++</code>是差不多的作用，两个扩展是不能同时启用的(存在冲突)，我尝试了一下还是<code>C/C++</code>更好用一点。</li></ul></li><li><code>Catppuccin Noctis</code><ul><li>非必要，感觉还行的主题。</li></ul></li><li><code>Remote - SSH</code><ul><li>远程开发，已经安装了。</li></ul></li></ol><h2 id="Hello-world！"><a href="#Hello-world！" class="headerlink" title="Hello world！"></a>Hello world！</h2><p>好了，接下来是喜闻乐见的<code>Hello world</code>环节。<br>咱们来学习如何构建和调试项目。</p><p>我这里在<code>VsCode</code>的远程连接状态中打开目录：<br><code>/home/yuyu/project/hello_world</code></p><h3 id="编写源代码"><a href="#编写源代码" class="headerlink" title="编写源代码"></a>编写源代码</h3><p>新建源文件：</p><ul><li><img src="/posts/54a8/9.png" class="" title="这是一张图片"></li></ul><p>敲上代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="构建与调试"><a href="#构建与调试" class="headerlink" title="构建与调试"></a>构建与调试</h3><p>代码是写完了，接下来我们如何构建和调试呢？<br>我们这里用<code>CMake</code>做示例，尽管只有一个文件，杀鸡用牛刀的感觉，但我们真正开发项目自然是需要更加现代的项目管理方式的。</p><p>同目录下新建<code>CMakeLists.txt</code>文件，输入以下内容：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>.<span class="number">0</span>)</span><br><span class="line"><span class="keyword">project</span>(hello_world)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output path of the library</span></span><br><span class="line"><span class="keyword">set</span>(EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/bin)</span><br><span class="line"></span><br><span class="line"><span class="comment"># We need to enable debugging information.</span></span><br><span class="line"><span class="keyword">SET</span>(CMAKE_BUILD_TYPE <span class="string">&quot;Debug&quot;</span>) </span><br><span class="line"><span class="keyword">SET</span>(CMAKE_CXX_FLAGS_DEBUG <span class="string">&quot;$ENV&#123;CXXFLAGS&#125; -O0 -Wall -g2 -ggdb&quot;</span>)</span><br><span class="line"><span class="keyword">SET</span>(CMAKE_CXX_FLAGS_RELEASE <span class="string">&quot;$ENV&#123;CXXFLAGS&#125; -O3 -Wall&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># All original files in the current path.</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span> SRC_LIST)</span><br><span class="line"></span><br><span class="line"><span class="comment"># build</span></span><br><span class="line"><span class="keyword">add_executable</span>(hello_world <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br></pre></td></tr></table></figure></p><h4 id="构建方法一"><a href="#构建方法一" class="headerlink" title="构建方法一"></a>构建方法一</h4><p>在终端中输入：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">cmake ..</span><br><span class="line">make all</span><br></pre></td></tr></table></figure></p><h4 id="构建方法二"><a href="#构建方法二" class="headerlink" title="构建方法二"></a>构建方法二</h4><p>右键<code>CMakeLists.txt</code>文件<br>1.Configure All Projects<br>2.Build All Projects</p><p>顺利的话都能够看到出现了一个bin目录，目录中就有我们编译的文件了。</p><h4 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h4><p>菜单栏中选择<code>Run</code>-&gt;<code>Add Configuration</code>，在弹出的菜单中选择<code>GDB</code>：</p><ul><li><img src="/posts/54a8/10.png" class="" title="这是一张图片">将此处的<code>./bin/executable</code>修改成<code>$&#123;workspaceRoot&#125;/bin/hello_world</code></li><li><img src="/posts/54a8/11.png" class="" title="这是一张图片"></li></ul><p>回到<code>hello_world.cpp</code>，在第4行处按下<code>f9</code>设置断点，<code>f7</code>编译，<code>f5</code>运行。<br>成功断下！</p><ul><li><img src="/posts/54a8/12.png" class="" title="这是一张图片"></li></ul><h5 id="附加调试"><a href="#附加调试" class="headerlink" title="附加调试"></a>附加调试</h5><p>如果希望附加调试，则使用：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;request&quot;:&quot;attach&quot;,</span><br><span class="line">&quot;processId&quot;:&quot;$&#123;command:pickProcess&#125;&quot;,</span><br><span class="line">&quot;program&quot;: &quot;$&#123;workspaceRoot&#125;/bin/hello_world&quot;,</span><br></pre></td></tr></table></figure><br>附加可能会出现需要root权限的情况， 使用root用户登录可以解决此问题。</p><p>也可以添加多个配置，在调试选项卡的开始调试框中，可以切换使用哪个配置进行调试。</p><h5 id="F5自动构建"><a href="#F5自动构建" class="headerlink" title="F5自动构建"></a>F5自动构建</h5><p>菜单栏中选择<code>Terminal</code>-&gt;<code>配置任务</code>，在弹出的菜单中选择<code>CMake: build</code>：<br>会创建一个tasks.json<br>也可以自己创建，这里贴上我的：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tasks.json</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;tasks&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cmake&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;CMake: build&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;build&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;targets&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;all&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;group&quot;</span><span class="punctuation">:</span> <span class="string">&quot;build&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;problemMatcher&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;detail&quot;</span><span class="punctuation">:</span> <span class="string">&quot;CMake template build task&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2.0.0&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></p><ul><li>接下来在launch.json添加一行，注意和task的label保持一致：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;preLaunchTask&quot;:&quot;CMake: build&quot;</span><br></pre></td></tr></table></figure></li></ul><h5 id="完整配置示例"><a href="#完整配置示例" class="headerlink" title="完整配置示例"></a>完整配置示例</h5><ul><li>新版本vscode可能变动，这里我这里贴上新版本的配置：<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// launch.json</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// 使用 IntelliSense 了解相关属性。 </span></span><br><span class="line">    <span class="comment">// 悬停以查看现有属性的描述。</span></span><br><span class="line">    <span class="comment">// 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;(gdb) Launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppdbg&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;/bin/ynet_test&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;stopAtEntry&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;fileDirname&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;environment&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;externalConsole&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;MIMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gdb&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;setupCommands&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Enable pretty-printing for gdb&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-enable-pretty-printing&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;ignoreFailures&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">                <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Set Disassembly Flavor to Intel&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-gdb-set disassembly-flavor intel&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;ignoreFailures&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;preLaunchTask&quot;</span><span class="punctuation">:</span><span class="string">&quot;CMake: build&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="GCC升级至13-2"><a href="#GCC升级至13-2" class="headerlink" title="GCC升级至13.2"></a>GCC升级至13.2</h1><p>由于Ubuntu22.04自带的GCC版本是11的，这里因为个人需要需要升级成13，特意记录一下。</p><h2 id="下载GCC"><a href="#下载GCC" class="headerlink" title="下载GCC"></a>下载GCC</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://ftp.gnu.org/gnu/gcc/gcc-13.2.0/gcc-13.2.0.tar.gz</span><br></pre></td></tr></table></figure><h2 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar xf gcc-13.2.0.tar.gz</span><br></pre></td></tr></table></figure><h2 id="安装组件"><a href="#安装组件" class="headerlink" title="安装组件"></a>安装组件</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd gcc-13.2.0/</span><br><span class="line">./contrib/download_prerequisites</span><br></pre></td></tr></table></figure><h2 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h2><p>注意—prefix=/usr/local/gcc-13.2.0是为了指定安装目录，方便后续切换gcc版本。<br>这里指定路径会有其他问题，比如需要查看gcc -v还是11.4.0，自行解决 。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir build &amp;&amp; cd build</span><br><span class="line">../configure --prefix=/usr/local/gcc-13.2.0 -enable-checking=release -enable-languages=c,c++ -disable-multilib</span><br><span class="line">sudo make -j4</span><br></pre></td></tr></table></figure></p><h2 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make install</span><br></pre></td></tr></table></figure><h2 id="更新C-库"><a href="#更新C-库" class="headerlink" title="更新C++库"></a>更新C++库</h2><p>不更新的话编译出来的程序会无法运行。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:ubuntu-toolchain-r/test</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install --only-upgrade libstdc++6</span><br></pre></td></tr></table></figure></p><h2 id="查看更新结果"><a href="#查看更新结果" class="headerlink" title="查看更新结果"></a>查看更新结果</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strings /usr/lib/x86_64-linux-gnu/libstdc++.so.6 | grep GLIBCXX</span><br></pre></td></tr></table></figure><p>以下是新的C++库<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">GLIBCXX_3.4.31</span><br><span class="line">GLIBCXX_3.4.32</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://www.cnblogs.com/x_wukong/p/4475567.html">Linux上安装使用SSH(ubuntu&amp;&amp;redhat)</a></li><li><a href="https://zhuanlan.zhihu.com/p/68577071">VS Code Remote SSH配置</a></li><li><a href="https://blog.csdn.net/weixin_48617416/article/details/131729829">Linux系统ubuntu22.04安装最新版的gcc13.1.0编译器，支持c++20、23</a></li><li><a href="https://stackoverflow.com/questions/76974555/glibcxx-3-4-32-not-found-error-at-runtime-gcc-13-2-0">“`GLIBCXX_3.4.32’ not found” error at runtime. GCC 13.2.0</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux C++ 现代实践随记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0.前言</title>
      <link href="/posts/c23d.html"/>
      <url>/posts/c23d.html</url>
      
        <content type="html"><![CDATA[<p>好久没写博客了…</p><p>嗯… 因为某些原因，打算转 Linux 下做 C++ 开发，Windows 的东西就当成业余的兴趣去研究吧。</p><p>这个系列的文章就记录一下我在学习过程中的一些思考，想法，以及备忘吧，就这样吧。</p>]]></content>
      
      
      <categories>
          
          <category> Linux C++ 现代实践随记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【保护模式】2.基于段的保护</title>
      <link href="/posts/f54c.html"/>
      <url>/posts/f54c.html</url>
      
        <content type="html"><![CDATA[<h1 id="段寄存器的扩展"><a class="markdownIt-Anchor" href="#段寄存器的扩展">#</a> 段寄存器的扩展</h1><p>我们需要划分权限，让操作系统和应用处在不同的权限中，以保证系统安全；<br>并且决定基于段机制进行延展。</p><p>相较于实模式的 1MB 寻址 (2<sup>20)，保护模式下的寻址范围已经达到了 4GB (2</sup>32)，在汇编指令上可以直接书写 4 字节的内存地址。</p><p>此时，段寄存器的 16 位宽度已经显得有些相形见绌了。<br>为了扩展，段寄存器在保护模式下，不再直接存放段的基址，而是存放了<strong>索引</strong>。</p><h2 id="全局描述符表-global-descriptor-table"><a class="markdownIt-Anchor" href="#全局描述符表-global-descriptor-table">#</a> 全局描述符表 (Global Descriptor Table)</h2><p>具体是索引什么呢？<br>这里引入了一张表，叫做<strong>全局描述符表</strong>，其实就是在内存中存放的数组。<br>其元素叫做<strong>段描述符</strong>，在内存中顺序组织起来，也就是一张表。</p><ul><li>简称<strong> GDT</strong></li></ul><h2 id="段选择子"><a class="markdownIt-Anchor" href="#段选择子">#</a> 段选择子</h2><p>段寄存器由于有了新的用途，因此也有了新的名字，叫做<strong>段选择子</strong>。</p><blockquote><p>大概是意为用于选择段的寄存器吧</p></blockquote><h2 id="段描述符"><a class="markdownIt-Anchor" href="#段描述符">#</a> 段描述符</h2><p>那么说回段描述符，它究竟有什么作用呢？为什么会有这么一个东西呢？</p><blockquote><p>段描述符是 GDT 或 LDT (暂时忽略) 中的元素；<br>它为处理器提供诸如段基址，段大小，访问权限及状态等信息。</p></blockquote><ul><li>先来看英特尔白皮书上对段描述符的图示<ul><li></li></ul></li></ul><p>每个段描述符是 8 字节，由多个字段组成。<br>我们发现，字段的排列有些混乱，基址 (Base)、界限 (Limit) 甚至需要跨几个字段组合。</p><blockquote><p>据说是英特尔为了兼容，这里也不做探究。</p></blockquote><p>字段这么多，咱们先来看最熟悉的基址字段。<br>还记得 <strong>4. 段寄存器</strong> 小节中的 <strong>CPU 对内存的访问</strong> 那部分吗？<br><strong>在实模式下，cpu 访问任何在汇编指令中显式书写的地址，都会将地址视作偏移 (逻辑地址)，加上段基地址形成真正的物理地址。</strong></p><p>在这里也不例外，只不过段寄存器并不直接存放段基址了，而是存放用于了在 GDT 中选择段描述符的索引值。</p><h2 id="访问内存"><a class="markdownIt-Anchor" href="#访问内存">#</a> 访问内存</h2><p>至此，我们也能初步设想在保护模式下，CPU 是如何基于段访问内存的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov eax, dword ptr ds:[0x12345678]</span><br></pre></td></tr></table></figure><ol><li>汇编指令中的内存地址 (偏移，<strong>offset</strong>) 是<strong> 0x12345678</strong>；</li><li>汇编指令中指定使用的段寄存器是 <strong>ds</strong>；</li><li>访问 ds 段寄存器，得到<strong>索引 (index)</strong>；</li><li>访问<strong> GDT [index]</strong>，得到段描述符；</li><li>解析段描述符中的<strong> Base</strong> 字段；</li><li><strong>ds.Base</strong> + <strong>offset</strong> = <strong>最终的物理地址</strong>；</li><li>通过物理地址访问内存。</li></ol><h1 id="地址分类"><a class="markdownIt-Anchor" href="#地址分类">#</a> 地址分类</h1><p>至此我们基本了解了，保护模式下 CPU 如何基于段描述符进行寻址。<br>并且在上文，我列出了 CPU 将汇编指令中书写的地址转换为物理地址的猜想。</p><p>在保护模式下，实际寻址过程的各个阶段的地址也都是有命名的。<br>为了向下深入学习，先了解一下还是有必要的。</p><h2 id="逻辑地址相对地址"><a class="markdownIt-Anchor" href="#逻辑地址相对地址">#</a> 逻辑地址 / 相对地址</h2><p>百度百科的解释是：</p><blockquote><p>指在计算机体系结构中是指应用程序角度看到的内存单元（memory cell）、存储单元（storage element）、网络主机（network host）的地址。 逻辑地址往往不同于物理地址（physical address），通过地址翻译器（address translator）或映射函数可以把逻辑地址转化为物理地址。</p></blockquote><p>咱们简单一点，<strong>还是理解成在汇编指令中显式书写的地址。</strong></p><p>如上一节举例的汇编指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov eax, dword ptr ds:[0x12345678]</span><br></pre></td></tr></table></figure><p>我们在当时把它叫做偏移 (offset)，其实它应该叫做<strong>逻辑地址</strong>。</p><p>在实模式下，<strong>逻辑地址 + 段基地址 = 物理地址</strong>；<br>在保护模式下， <strong>逻辑地址 + 段基地址 = 线性地址</strong>。</p><h2 id="线性地址虚拟地址"><a class="markdownIt-Anchor" href="#线性地址虚拟地址">#</a> 线性地址 / 虚拟地址</h2><p>摘自百度百科：</p><blockquote><p>线性地址（Linear Address）是逻辑地址到物理地址变换之间的中间层。在分段部件中逻辑地址是段中的偏移地址，然后加上基地址就是线性地址。</p></blockquote><p>线性地址是在保护模式下出现的，通过<strong>页表</strong>将<strong>线性地址</strong>转换成<strong>物理地址</strong>。</p><ul><li><strong>在上节举例时，我们将 &quot;线性地址&quot; 称为 &quot;物理地址&quot;；</strong></li><li><strong>线性地址到物理地址的转换涉及到分页机制，在未学习分页机制之前，请暂时将笔记中所有 &quot;线性地址&quot; 视作 &quot;物理地址&quot;。</strong></li></ul><h2 id="物理地址"><a class="markdownIt-Anchor" href="#物理地址">#</a> 物理地址</h2><p>摘自百度百科：</p><blockquote><p>在存储器里以字节为单位存储信息，为正确地存放或取得信息，每一个字节单元给以一个唯一的存储器地址，称为物理地址（Physical Address），又叫实际地址或绝对地址。</p></blockquote><p>CPU 最终通过<strong>物理地址</strong>去访问<strong>真正的存储单元</strong>。</p><h1 id="段描述符缓存"><a class="markdownIt-Anchor" href="#段描述符缓存">#</a> 段描述符缓存</h1><h2 id="gdtr"><a class="markdownIt-Anchor" href="#gdtr">#</a> GDTR</h2><p>我们说到，既然 CPU 访问内存，需要先访问 GDT，那么 GDT 的地址又是从哪里来的呢？</p><p>CPU 提供了一个 48bit、名为<strong> GDTR</strong> 的寄存器。</p><blockquote><p>高 32bit 存放 GDT 的首地址（线性地址）；<br>低 16bit 存放 GDT 的界限，即整个 GDT 表的长度。</p></blockquote><ul><li>通过 windbg 调试 Windows XP，查看<strong> GDTR</strong> 的内容：<ul><li></li></ul><blockquote><p>关于 windbg 的使用，在内核的学习阶段是非常重要的，所学的知识都需要自己动手实验、验证；<br>如果有需要的话，我会考虑再找时间写一篇关于环境配置的文章。</p></blockquote></li></ul><p>在 windbg 下：<br>查询<strong> gdtr</strong>，即查询 GDT 的首地址；<br>查询<strong> gdtl</strong>，即查询 GDT 的界限。</p><p>CPU 每次访问<strong> GDT</strong> 时，都是从<strong> GDTR</strong> 中获取<strong>线性地址</strong>。</p><p>而 GDTR 的值，是由操作系统在初始化阶段填入的。</p><h2 id="不可见寄存器"><a class="markdownIt-Anchor" href="#不可见寄存器">#</a> 不可见寄存器</h2><p>解决了一个问题，当然又会出现新的问题。<br>通过引入<strong> GDT</strong>，我们解决了<strong>段寄存器</strong>宽度太小无法满足保护模式需求的问题。</p><p>但是每次访问内存，都要先查<strong> GDT</strong>，这是不是有点浪费 CPU 的性能了？</p><p>是的，内存访问对于 CPU 而言，是很慢的行为，为了避免这种性能浪费，引入了名为<strong>描述符缓存</strong>的寄存器。<br>实际上，<strong>描述符缓存</strong>是不可见的，它在保护模式下是属于<strong>段寄存器</strong>的一部分。</p><p>保护模式下的段寄存器，就分为了<strong>两个部分</strong>：</p><ul><li>段选择子<ul><li>原先的段寄存器，可见。</li></ul></li><li>描述符缓存<ul><li>对段寄存器进行扩展，不可见。</li></ul></li></ul><p>虽然它不可见，无法直接操作，但是是真实存在的。</p><h2 id="段寄存器"><a class="markdownIt-Anchor" href="#段寄存器">#</a> 段寄存器</h2><ul><li><strong>保护模式下，将段选择子与描述符缓存部分 合称为段寄存器</strong></li></ul><h3 id="加载段寄存器"><a class="markdownIt-Anchor" href="#加载段寄存器">#</a> 加载段寄存器</h3><p>在<strong>加载段选择子</strong>时，CPU 会通过我们给定的段选择子，查询 GDT，得到描述符。</p><p>解析描述符，将字段填入<strong>描述符缓存</strong>中。</p><p>未来每次发生内存访问，都不会去查询 GDT，而是直接从<strong>描述符缓存</strong>中获取字段。</p><p>那么，段选择子是由谁加载的呢？为什么我们平时没有见到过相关的代码呢？<br>我们可以在 windows 下打开随意 x64dbg、od 之类的调试器，拖入一个程序，就可以看到，段选择子是存在初始值的，而加载的工作是由操作系统负责的。<br>我们也应该明白，所谓的<strong>加载段选择子</strong>，实际上也是<strong>加载描述符缓存</strong>，合称为<strong>加载段寄存器</strong>。</p><h2 id="访问内存-2"><a class="markdownIt-Anchor" href="#访问内存-2">#</a> 访问内存</h2><p>至此，我们可以将上一节的设想进行改进：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov eax, dword ptr ds:[0x12345678]</span><br></pre></td></tr></table></figure><ol><li><strong>逻辑地址</strong>是<strong> 0x12345678</strong>；</li><li>汇编指令中指定使用的段寄存器是 <strong>ds</strong>；</li><li>从<strong>描述符缓存</strong>中取得<strong> Base</strong> 字段</li><li><strong>ds.Base</strong> + <strong>逻辑地址</strong> = <strong>线性地址</strong>；</li><li>通过<strong>线性地址</strong>访问内存。</li></ol><h1 id="访问控制"><a class="markdownIt-Anchor" href="#访问控制">#</a> 访问控制</h1><p>那么，说了这么久保护，究竟应该怎样才能做到所谓的保护呢？</p><p>在第 5 节我们简单提及了权限的建立，通过为不同的段设置权限级别，以<strong>控制不同程序对内存的访问</strong>。</p><h2 id="特权级划分"><a class="markdownIt-Anchor" href="#特权级划分">#</a> 特权级划分</h2><p>接下来咱们想一下，既然是权限，那自然是有高有低，就像身份一样，我是排长，你是士卒，那我的级别自然就比你高。</p><p>接下来我们尝试用两个数字表示两种权限级别：</p><ul><li>0<ul><li>最高权限级别，表示当前的 CPU 是以<strong>系统</strong>身份在跑的，操作系统运行在此级别下；</li></ul></li><li>3<ul><li>最低权限级别，表示当前的 CPU 是以<strong>用户</strong>身份在跑的，应用程序运行在此级别下。</li></ul></li></ul><h3 id="再次构思"><a class="markdownIt-Anchor" href="#再次构思">#</a> 再次构思</h3><table><thead><tr><th style="text-align:left">地址</th><th style="text-align:left">程序</th><th style="text-align:left">基地址 (Base)</th><th style="text-align:left">访问此段需要权限 (DPL)</th></tr></thead><tbody><tr><td style="text-align:left">0x00 ~ 0x3f</td><td style="text-align:left">提供给操作系统内核存放数据</td><td style="text-align:left">0x00</td><td style="text-align:left">0</td></tr><tr><td style="text-align:left">0x40 ~ 0x7f</td><td style="text-align:left">提供给操作系统内核存放代码</td><td style="text-align:left">0x40</td><td style="text-align:left">0</td></tr><tr><td style="text-align:left">0x80 ~ 0xcf</td><td style="text-align:left">提供给程序 A 存放数据</td><td style="text-align:left">0x80</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left">0xd0 ~ 0xff</td><td style="text-align:left">提供给程序 A 存放代码</td><td style="text-align:left">0xd0</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left">…</td><td style="text-align:left">…</td><td style="text-align:left">…</td><td style="text-align:left">…</td></tr></tbody></table><blockquote><p>内核是指操作系统驻留在内存中的最基本的部分。</p></blockquote><ul><li>同时，我们已经学习过段描述符了，<strong>段基址</strong>是放到段描述符中的，那么<strong>访问权限</strong>自然也可以放到段描述符中。</li></ul><h2 id="基本控制"><a class="markdownIt-Anchor" href="#基本控制">#</a> 基本控制</h2><p>假定我是 CPU，此刻我的 ip 指针指向了应用程序中的指令序列，并且我的<strong>当前身份是用户</strong>。<br>一旦我试图<strong>访问我不应该访问的内存</strong> (如提供给操作系统内核存放数据的段)，因为我没有那么高的特权，<strong>就应当受到制止。</strong></p><h3 id="表明当前程序的身份"><a class="markdownIt-Anchor" href="#表明当前程序的身份">#</a> 表明当前程序的身份</h3><p>既然我们知道，访问内存中的段增加了一项对权限的例行检查，那么自然就需要有一项能表示我们当前身份的东西了。</p><h3 id="dpl"><a class="markdownIt-Anchor" href="#dpl">#</a> DPL</h3><p>组成段描述符的字段之一，表明段描述符的特权级，访问该段应具备的权限。</p><ul><li>Descriptor Privilege Level，描述符特权级</li></ul><h3 id="rpl"><a class="markdownIt-Anchor" href="#rpl">#</a> RPL</h3><p>还记得我们之前学过的段选择子吗？当时我们只说了，段选择子用于从 GDT 中选择段描述符并加载，实际上，段选择子一共有 16bit，其中高 13bit，才是 GDT 的索引。</p><p>在段选择子中，低 3bit 是另作他用的，其中低 2bit，用于表示 CPU 加载段描述符时的请求权限。</p><ul><li><strong>即 RPL，Requested Privilege Level ，请求特权级</strong></li></ul><p><strong>意为发起访问请求时的特权级</strong></p><h3 id="cpl"><a class="markdownIt-Anchor" href="#cpl">#</a> CPL</h3><p>cs 段选择子与 ss 段选择子的 RPL 字段。</p><ul><li><strong>又称为 CPL，Current Privilege Level，当前特权级</strong></li></ul><h3 id="示例"><a class="markdownIt-Anchor" href="#示例">#</a> 示例</h3><ul><li>接下来我们通过使用机密文档来举个栗子，尝试理解它。</li></ul><table><thead><tr><th style="text-align:center">文档</th><th style="text-align:center">最低阅读准许级别</th></tr></thead><tbody><tr><td style="text-align:center">文档 A</td><td style="text-align:center">排长</td></tr><tr><td style="text-align:center">文档 B</td><td style="text-align:center">连长</td></tr></tbody></table><ul><li><p>首先，假定军官可以申请阅读机密文档，并且每个机密文档都有对应的权限要求；</p></li><li><p>又假定我是排长，想阅读排长级别才能阅读的机密文件，于是我写了一份申请报告 (请求)，上面写着 **“排长级别”<strong>，并且对审核人员说，我希望能阅读</strong>文档 A**，审核人员在查看了报告上的请求级别，再与文档 A 的级别进行比较，如果报告上的级别达到了文档 A 的阅读准许级别，审核人员则会批准，我就可以阅读了。</p></li><li><p>但是当我想阅读具有连长身份才能阅读的机密文档时，于是我依旧提交申请报告，填写 **“排长级别”<strong>，并告诉他我希望阅读</strong>文档 B**，负责审批的人一看，你这不对啊，你这申请报告上写的是排长级别，但你想阅读的文档是连长级别才能阅读的机密文档，拒绝也就是理所当然的事。</p></li></ul><blockquote><p>此处 以军官的身份与阅读机密文件进行比喻 仅出于个人认为易于理解的想法，无其他意义，我尊敬军人，热爱祖国。</p></blockquote><p><strong>既然有 RPL 了，那么为什么要多此一举，弄出来一个 CPL，这个 CPL 又是个什么东西呢？</strong></p><p>在上面我们强调的是<strong>请求</strong>，那么为什么要划分<strong>请求</strong>和<strong>当前</strong>呢？</p><p>就好比阅读机密文档，需要有足够的身份，才能拥有对应的权限。</p><ul><li>请求<ul><li>即我希望阅读的机密文档的级别；</li></ul></li><li>当前<ul><li>表示我现在的身份。</li></ul></li></ul><p>如果没有对<strong>当前身份</strong>的检查，那么即便我是排长，我也可以<strong>提交一个 &quot;连长级别&quot; 的申请报告</strong>。</p><ul><li><strong>只校验请求是不够的，更重要的是当前的身份</strong>。</li></ul><blockquote><p>程序的运行是依赖于 CPU 的，而 CPU 通过 CPL，辨认当前被 CPU 取指执行的程序的身份；通过 RPL，确定当前程序发起的请求时指定的特权级。</p></blockquote><p>可能有的同学又要发炎啦，啊那我直接看身份级别不就行了，为什么还要多此一举，弄出来一个请求级别。</p><h3 id="arpl"><a class="markdownIt-Anchor" href="#arpl">#</a> ARPL</h3><p>咱们再看一个例子，假设我有一个朋友，他是团长，在平时我抽不开身的时候，就干脆让他帮我递交<strong>申请报告</strong>，并且告诉他我想查看什么文档，让他替我带回文档。</p><p>而 RPL 的意义在于此，假设我想阅读<strong>文档 B</strong>，但是我转交给他的申请报告写的是 &quot;排长级别&quot;，就算他<strong>以团长的身份递交申请报告，因为申请报告中填写的级别不足，依旧会被拒绝</strong>。</p><p>这个时候新的问题又来了，如果我转交给他的是一个 &quot;连长级别&quot; 的申请报告呢？这个时候的检查工作就落在团长的身上，他必须<strong>先检查我的身份和我的申请报告</strong>，如果我的申请报告与我的身份存在问题，那么他就会将我递交的申请报告进行修改，虽然他依旧会原样传达我的话 (我想阅读<strong>文档 B</strong>)，但是审核人员可以通过查阅申请报告，以及团长传递的话，从而选择拒绝与否。</p><h4 id="检查工作"><a class="markdownIt-Anchor" href="#检查工作">#</a> 检查工作</h4><p>而这个检查与修改的过程就是 ARPL 指令所做的工作</p><ul><li><p>我们的<strong>应用 (连长)<strong> 委托</strong>操作系统 (团长)<strong> 访问指定的</strong>段 (机密文档)</strong>；</p></li><li><p>应用的<strong> RPL (申请报告)</strong>，以及应用的<strong> CPL (身份)</strong>，<strong>操作系统</strong>通过 ARPL 指令进行校验以及修改，以保证操作系统不会不小心替应用访问了不应该访问的段。</p></li><li><p>最后由<strong> cpu (审核员)<strong> 检查段的访问权限</strong> DPL (机密文档的阅读权限)</strong>；</p></li><li><p><strong>而 应用是如何委托操作系统 等内容，请在学习权限切换后，再次回来复习。</strong></p></li></ul><h1 id="权限检查"><a class="markdownIt-Anchor" href="#权限检查">#</a> 权限检查</h1><p>我们讲述了基于段机制的内存访问是如何受到控制的。</p><p>我想，各位看完之后依旧会存在不少疑惑，比如所谓的<strong>访问</strong>，对权限的检查，具体是发生在什么时候呢？</p><h2 id="段的分类"><a class="markdownIt-Anchor" href="#段的分类">#</a> 段的分类</h2><p>我们知道，由地址上连续的多个内存单元组织而成的内存区域，就可以将其称之为段。<br>为了减少错误的出现与降低开发难度，在实模式时，就已经开始将内存划分为多个段，并且根据用途为段进行了分类。</p><p>在前面的笔记我们粗略提及过段的分类，本篇再对保护模式下的段的分类进行讲述。</p><h2 id="实模式"><a class="markdownIt-Anchor" href="#实模式">#</a> 实模式</h2><p>在实模式下，段的分类更偏向于程序设计者自主安排，我不强求，你想怎么安排，就可以怎么安排，重要的是哪个段寄存器指向了那块内存区域。</p><p>如将 x8000 这个地址作为段的基址，我可以将其赋值给 cs，也可以将其赋值给 ds，取决于我如何使用它。</p><h2 id="保护模式"><a class="markdownIt-Anchor" href="#保护模式">#</a> 保护模式</h2><p>为何我会说实模式的段分类下是程序设计者的自主安排，难道保护模式就不是了吗？<br>实际上，对于应用程序设计者而言，确实是的。</p><p>你也许会想，实模式的段寄存器我可以随便加载，保护模式的段选择子就不可以了吗？</p><p>很遗憾，应用程序设计者确实没有这么大的权限，要不为何会着重<strong>保护</strong>二字呢？</p><h2 id="段描述符相关字段"><a class="markdownIt-Anchor" href="#段描述符相关字段">#</a> 段描述符相关字段</h2><p>咱们还是要看英特尔白皮书中对段描述符的解释，在往后的笔记中还会经常与它见面。</p><pre><code>- &#123;% asset_img 1.png 这是一张图片 %&#125;</code></pre><h3 id="s字段"><a class="markdownIt-Anchor" href="#s字段">#</a> S 字段</h3><ul><li>S 字段为 1<ul><li>当前段描述符描述的段是代码段或数据段</li></ul></li><li>S 字段为 0<ul><li>当前段描述符描述的段是系统段</li></ul></li></ul><h3 id="数据段"><a class="markdownIt-Anchor" href="#数据段">#</a> 数据段</h3><p>数据段是指用于存放数据的内存区域，向下还能再细分为<strong>只读数据段</strong>、<strong>栈段</strong>等，供 CPU 读或写。</p><h3 id="代码段"><a class="markdownIt-Anchor" href="#代码段">#</a> 代码段</h3><p>代码段是指用于存放指令序列的内存区域，供 CPU 执行。</p>]]></content>
      
      
      <categories>
          
          <category> Windows内核 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 保护模式 </tag>
            
            <tag> Windows内核 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【保护模式】1.初探保护模式与分段机制</title>
      <link href="/posts/4aaf.html"/>
      <url>/posts/4aaf.html</url>
      
        <content type="html"><![CDATA[<h1 id="保护模式"><a class="markdownIt-Anchor" href="#保护模式">#</a> 保护模式</h1><ul><li>保护模式是在硬件层面提供的 CPU 运行机制，是现代操作系统的根本。</li><li>没有保护模式，操作系统是没有安全性可言的。</li></ul><h2 id="何为保护"><a class="markdownIt-Anchor" href="#何为保护">#</a> 何为保护</h2><ul><li><p>指令是存放在内存中的</p></li><li><p>假定你的程序试图对操作系统的关键代码进行破坏：</p><ul><li><code>mov byte ptr ds:[kernel], 0x90</code></li></ul></li><li><p>操作系统应该如何制止？</p></li><li><p>也许这个时候有同学发炎了：</p><ul><li>“也许操作系统它能监控呢？”</li></ul></li><li><p>答案是，监控你程序的并不是操作系统，这种工作必须在硬件层完成</p><ul><li>很简单的道理，实际上运行指令的是 CPU，只有 CPU 知道当前 CPU 正在做什么事，操作系统是不可能知道的<ul><li>操作系统也是由 CPU 运行的指令序列。</li></ul></li><li>除非 CPU 提供了一种回调机制，运行任何指令都先运行操作系统的指令，但这是不现实的，对性能影响过于严重<ul><li>实现一套虚拟机也可以保证安全性，但是依旧存在性能问题，也不在本文讨论范围之内。</li></ul></li></ul></li></ul><hr><h2 id="模式之分"><a class="markdownIt-Anchor" href="#模式之分">#</a> 模式之分</h2><ul><li><p>我们得到了结论，保证 操作系统的安全性 这种机制，必须是硬件提供的。</p><ul><li>在早期，CPU 并未提供这种保护模式，为此才划分出了 “实模式” 与 “保护模式”</li><li>在保护模式出现时，为了兼容，因此也诞生了 “虚拟 8086 模式”，但已经不重要了，也不在本文讨论范围内。</li></ul></li><li><p><strong>在学习保护模式时也需要牢记，保护模式是硬件层的东西，切勿与操作系统混淆。</strong></p></li></ul><h1 id="物理内存"><a class="markdownIt-Anchor" href="#物理内存">#</a> 物理内存</h1><ul><li>我们都知道，我们可见的物理内存，其实就是<strong>连续的、对每一个单元进行了地址编号的很大的存储器。</strong></li></ul><table><thead><tr><th style="text-align:left">地址</th><th style="text-align:left">数据</th></tr></thead><tbody><tr><td style="text-align:left">0x00</td><td style="text-align:left">0xff</td></tr><tr><td style="text-align:left">0x01</td><td style="text-align:left">0x00</td></tr><tr><td style="text-align:left">…</td><td style="text-align:left">…</td></tr></tbody></table><p><em>表格仅为举例，与真实物理内存布局无关</em></p><ul><li><p>程序必须是存放在内存中，才能被 CPU<strong> 取指执行</strong>。</p></li><li><p>假定你是操作系统 (给你管理硬件资源)，那么多个程序又如何存放比较好呢？</p></li></ul><hr><h2 id="多个程序的安置"><a class="markdownIt-Anchor" href="#多个程序的安置">#</a> 多个程序的安置</h2><ul><li>可能有同学回答了：<ul><li>我<strong>顺序加载</strong>嘛，第一个程序从哪里占用到哪里，第二个程序从哪里占用到哪里</li></ul></li></ul><table><thead><tr><th style="text-align:left">地址</th><th style="text-align:left">程序</th></tr></thead><tbody><tr><td style="text-align:left">0x00 ~ 0x7f</td><td style="text-align:left">提供给程序 A</td></tr><tr><td style="text-align:left">0x80 ~ 0xff</td><td style="text-align:left">提供给程序 B</td></tr><tr><td style="text-align:left">…</td><td style="text-align:left">…</td></tr></tbody></table><ul><li><p>如表格所述，我们成功将两个程序分别放到了不同的位置。</p></li><li><p>这样子他们就互不干扰了，我们真是个小天才。</p></li></ul><h2 id="问题仍在"><a class="markdownIt-Anchor" href="#问题仍在">#</a> 问题仍在</h2><ul><li><p>很遗憾，这样子的程序，运行依旧存在困难</p><ul><li>在编写程序的时候，无法预知程序在运行时究竟会被加载到内存的哪个位置。</li><li>假设<strong> B</strong> 选择 <code>0x40</code>  这个地址存放一些数据，那不是正好破坏了<strong> A</strong> 的指令序列？</li></ul></li><li><p>为此，<strong>内存分段</strong>诞生了</p></li></ul><hr><h1 id="内存分段"><a class="markdownIt-Anchor" href="#内存分段">#</a> 内存分段</h1><ul><li><p>如果我们在编写程序的时候，任何使用内存的指令，填写的内存地址，都是一个<strong>偏移值</strong>，让 CPU 替我们去与<strong>基地址</strong>相加，最终得到真正的<strong>物理地址</strong>。</p></li><li><p>那么不管我们的程序被加载到内存的哪个位置，只要提供一个正确的<strong>基地址</strong>，就可以让多个程序互不干扰了！</p></li></ul><h2 id="示例"><a class="markdownIt-Anchor" href="#示例">#</a> 示例</h2><table><thead><tr><th style="text-align:left">地址</th><th style="text-align:left">程序</th><th style="text-align:left">基地址</th></tr></thead><tbody><tr><td style="text-align:left">0x00 ~ 0x7f</td><td style="text-align:left">提供给程序 A</td><td style="text-align:left">0x00</td></tr><tr><td style="text-align:left">0x80 ~ 0xff</td><td style="text-align:left">提供给程序 B</td><td style="text-align:left">0x80</td></tr><tr><td style="text-align:left">…</td><td style="text-align:left">…</td><td style="text-align:left">…</td></tr></tbody></table><ul><li><p>假设<strong> B</strong> 选择 <code>0x40</code>  这个地址存放一些数据，我们还会破坏<strong> A</strong> 的指令序列吗？</p></li><li><p>这样看上去，是不是像给<strong>内存分段</strong>了一样？</p><ul><li><code>0x00 ~ 0x7f</code>  看作一段，分给<strong>程序 A</strong></li><li><code>0x80 ~ 0xff</code>  看作一段，分给<strong>程序 B</strong></li></ul></li></ul><hr><p>实模式下的分段机制大抵如此。</p><h1 id="段寄存器"><a class="markdownIt-Anchor" href="#段寄存器">#</a> 段寄存器</h1><ul><li><p>想来各位读者对寄存器都有所了解，既然我们需要一个容器来存放<strong>段的基地址</strong>，寄存器自然是不错的选择。</p></li><li><p>但是通用寄存器本身数量也不够多，再想腾出来存放<strong>段基址</strong>，也是心有余而力不足了。</p></li><li><p>因此，理所当然的，就有了以<strong>段</strong>为名的<strong>段寄存器</strong>。</p></li></ul><h2 id="ds寄存器"><a class="markdownIt-Anchor" href="#ds寄存器">#</a> ds 寄存器</h2><ul><li>ds，即 data segment，意为数据段</li><li>咱们一看就知道，这个东西就是和<strong>数据</strong>、<strong>段</strong> 相关的。</li><li>它也十分简单，16 位的宽度，作用就是存放数据段的基址</li></ul><blockquote><p>注解</p><blockquote><p>实际在实模式下，物理地址的转换公式略微复杂一些<br> (ds &lt;&lt; 4) + address = 最终的物理地址</p></blockquote></blockquote><h3 id="结合先前的示例"><a class="markdownIt-Anchor" href="#结合先前的示例">#</a> 结合先前的示例</h3><table><thead><tr><th style="text-align:left">地址</th><th style="text-align:left">程序</th><th style="text-align:left">基地址</th></tr></thead><tbody><tr><td style="text-align:left">0x00 ~ 0x7f</td><td style="text-align:left">提供给程序 A</td><td style="text-align:left">0x00</td></tr><tr><td style="text-align:left">0x80 ~ 0xff</td><td style="text-align:left">提供给程序 B</td><td style="text-align:left">0x80</td></tr><tr><td style="text-align:left">…</td><td style="text-align:left">…</td><td style="text-align:left">…</td></tr></tbody></table><ul><li>我们选择让<strong> B</strong> 在 <code>0x40</code>  这个位置存放一些数据</li><li>而现在我们有了 ds 寄存器，只要在程序运行前初始化 ds 寄存器，就可以做到不破坏<strong> A</strong> 的程序了。</li></ul><h2 id="根据段的用途进行划分"><a class="markdownIt-Anchor" href="#根据段的用途进行划分">#</a> 根据段的用途进行划分</h2><ul><li>但是这样子明显我们还需要小心翼翼，毕竟虽然不会破坏其他程序了，但不代表不会破坏自己的指令序列啊！</li><li><strong>代码</strong>和<strong>数据</strong>都放在一个段里，是不是不便管理？</li><li>如果我们对代码和数据再做进一步的<strong>划分</strong>，是不是更好？</li></ul><table><thead><tr><th style="text-align:left">地址</th><th style="text-align:left">程序</th><th style="text-align:left">基地址</th></tr></thead><tbody><tr><td style="text-align:left">0x00 ~ 0x3f</td><td style="text-align:left">提供给程序 A 存放数据</td><td style="text-align:left">0x00</td></tr><tr><td style="text-align:left">0x40 ~ 0x7f</td><td style="text-align:left">提供给程序 A 存放代码</td><td style="text-align:left">0x40</td></tr><tr><td style="text-align:left">0x80 ~ 0xcf</td><td style="text-align:left">提供给程序 B 存放数据</td><td style="text-align:left">0x80</td></tr><tr><td style="text-align:left">0xd0 ~ 0xff</td><td style="text-align:left">提供给程序 B 存放代码</td><td style="text-align:left">0xd0</td></tr><tr><td style="text-align:left">…</td><td style="text-align:left">…</td><td style="text-align:left">…</td></tr></tbody></table><ul><li><p>为此，自然是可以存在更多的段寄存器</p><ul><li>cs(code segment)</li><li>ss(stack segment)</li><li>ds(data segment)</li><li>…</li></ul></li><li><p>还是先前的问题，程序<strong> B</strong> 试图在 <code>0x40</code>  这个地址存放数据，我们只需要让 cpu 知道，<strong>数据段基址</strong>是 <code>0x80</code></p><ul><li><code>0x80 + 0x40 = 0xc0</code></li></ul></li><li><p>我们只需要划分好各个段，就可以很好的让程序工作了！</p></li></ul><h2 id="cpu对内存的访问"><a class="markdownIt-Anchor" href="#cpu对内存的访问">#</a> CPU 对内存的访问</h2><ul><li>为此，cpu 也被设计为，在<strong>访问任何汇编指令中显式书写的内存地址时</strong>，都会先根据<strong>用途</strong>选择<strong>段寄存器</strong>，得到<strong>段基地址</strong>，<strong>指令中的地址</strong>视作<strong>偏移 (逻辑地址)</strong>，<strong>运算后</strong>得到<strong>真正的物理地址</strong>，再进行<strong>访问</strong>。</li></ul><blockquote><p>注解</p><blockquote><p>读写内存，可以划分为对数据段的访问<br>执行指令，可以划分为对代码段的访问<br>…</p></blockquote></blockquote><h1 id="初探基于段的保护"><a class="markdownIt-Anchor" href="#初探基于段的保护">#</a> 初探基于段的保护</h1><ul><li><p>在实模式下，对于任何存在于内存中的指令序列，cpu 是<strong>一视同仁</strong>的，ip 指哪它跑哪，埋头苦干。</p></li><li><p>操作系统将我们的程序加载到内存，使得 cs:ip 指向我们程序的入口点之后，<strong>我们想干什么，就不是操作系统能说了算了</strong>。</p><ul><li>当然我们也可以反手来一波背刺，<strong>捅死操作系统</strong>。</li></ul></li></ul><h2 id="尝试分段"><a class="markdownIt-Anchor" href="#尝试分段">#</a> 尝试分段</h2><ul><li><p>你可能想到了，啊，我们先前不是才讲过，分段不就好了吗？</p></li><li><p>其实所谓的分段，也是建立在大家都<strong>规规矩矩</strong>，<strong>和睦相处</strong>的情况下，才能最大程度上避免 &quot;不小心&quot; 出现的问题。</p><ul><li>简单地说，全看编写程序的人自觉不自觉。</li><li>既然操作系统能<strong>修改 cs、ds 段寄存器</strong>，我们有何不可呢？</li></ul></li></ul><h2 id="权限的建立"><a class="markdownIt-Anchor" href="#权限的建立">#</a> 权限的建立</h2><ul><li><p>首先，咱们既然要保证<strong>安全</strong>，那自然就要划分哪些是应用能做的，哪些是应用不能做的。</p></li><li><p>其次，总归要有程序去管理软硬件的，操作系统的不受限制也理所应当了。</p></li></ul><h3 id="权限划分"><a class="markdownIt-Anchor" href="#权限划分">#</a> 权限划分</h3><ul><li><p>既然有了<strong>不能做</strong>和<strong>能做</strong>之分，并且还有了 &quot;区别对待&quot;，<strong>权限</strong>自然也就建立起来了。</p></li><li><p>至此，咱们初步确定了<strong>权限</strong>的划分。</p><ul><li>常规应用，拥有<strong>部分权限</strong>；</li><li>操作系统，拥有<strong>所有权限</strong>。</li></ul></li></ul><h2 id="段机制的延展"><a class="markdownIt-Anchor" href="#段机制的延展">#</a> 段机制的延展</h2><ul><li><p>咱们最先想到的，最不能让应用去乱搞的是什么呢？</p></li><li><p>首先就是不能让应用去破坏咱们的操作系统，咱们首先要把自己<strong>保护</strong>起来。</p><ul><li><strong>如果应用能随意修改操作系统的指令序列，那么所谓的保护将毫无意义</strong>。</li></ul></li></ul><h3 id="初步构想"><a class="markdownIt-Anchor" href="#初步构想">#</a> 初步构想</h3><ul><li><p>我们可以沿用实模式下存在的段机制，为段设立权限。</p><ul><li>应用的指令序列处在一个<strong>权限受限</strong>的段中，<strong>不允许访问除自己段内的任何内存。</strong></li></ul></li><li><p>而操作系统就处在拥有<strong>最高特权</strong>的段中，<strong>掌有生杀大权</strong>。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Windows内核 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 保护模式 </tag>
            
            <tag> Windows内核 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Git】远程仓库登录</title>
      <link href="/posts/91e5.html"/>
      <url>/posts/91e5.html</url>
      
        <content type="html"><![CDATA[<h2 id="github身份验证"><a class="markdownIt-Anchor" href="#github身份验证">#</a> Github 身份验证</h2><p>Github 通过 SSH 登录，通过提前在 Github 上设置公钥，以及本地存储的私钥，使得 Github 能够验证身份的合法性。</p><h2 id="配置用户名和邮箱"><a class="markdownIt-Anchor" href="#配置用户名和邮箱">#</a> 配置用户名和邮箱</h2><ul><li><code>git config --global user.name &quot;&lt;用户名&gt;&quot;</code></li><li><code>git config --global user.email &quot;&lt;邮箱地址&gt;&quot;</code></li></ul><h2 id="查看配置"><a class="markdownIt-Anchor" href="#查看配置">#</a> 查看配置</h2><ul><li><code>git config --list</code></li></ul><h2 id="密钥"><a class="markdownIt-Anchor" href="#密钥">#</a> 密钥</h2><p>生成密钥对：</p><ul><li><code>ssh-keygen -t rsa -C &quot;&lt;邮箱地址|用户名|...&gt;&quot;</code></li></ul><p>放置在～/.ssh 目录中</p><ul><li>config 文件指定有效的密钥文件</li><li>Windows 下可以在 Git Bash 中查看路径</li></ul><p>默认公钥文件</p><ul><li>id_rsa.pub</li></ul><p>默认私钥文件</p><ul><li>id_rsa</li></ul><p>打开公钥文件，将其复制。</p><h2 id="设置公钥"><a class="markdownIt-Anchor" href="#设置公钥">#</a> 设置公钥</h2><ol><li>打开 Github</li><li>在个人设置 -&gt; SSH and GPG keys -&gt; SSH keys 中，添加刚刚复制的公钥。</li></ol><h2 id="验证登录"><a class="markdownIt-Anchor" href="#验证登录">#</a> 验证登录</h2><ul><li><code>ssh -T git@github.com</code></li></ul><p>出现 “Hi xxxx! …” 表示配置完成</p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> 版本管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【C/C++逆向】AMD64架构下MSVC编译器的调用约定与栈帧分析</title>
      <link href="/posts/75b5.html"/>
      <url>/posts/75b5.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【密码学】PKI体系：谁来保证我的通信安全？</title>
      <link href="/posts/5d13.html"/>
      <url>/posts/5d13.html</url>
      
        <content type="html"><![CDATA[<h1 id="PKI概述"><a href="#PKI概述" class="headerlink" title="PKI概述"></a>PKI概述</h1><p><strong>Public Key Infrastructure，即公钥基础设施。</strong></p><p>以下摘自百度百科：</p><blockquote><p>公钥基础设施是一个包括硬件、软件、人员、策略和规程的集合，用来实现基于公钥密码体制的密钥和证书的产生、管理、存储、分发和撤销等功能。<br>PKI体系是计算机软硬件、权威机构及应用系统的结合。它为实施电子商务、电子政务、办公自动化等提供了基本的安全服务，从而使那些彼此不认识或距离很远的用户能通过信任链安全地交流。</p></blockquote><p>当然，要是光看定义能看懂的话，想必各位也不会见到这一篇文章了，贴出定义只是个人习惯，咱们往下看。</p><h1 id="明文与密文"><a href="#明文与密文" class="headerlink" title="明文与密文"></a>明文与密文</h1><p>首先咱们要知道，咱们能够阅读理解的东西是<code>明文</code>，比如远在天边的网友给你发的一条qq消息，你看到的时候它就是明文，这样你才能看得懂你的网友想和你说些什么。</p><p>当然，你看得懂，别人也看得懂，中文嘛，大家都学过。<br>你想着，我要是不想赤裸裸的让别人窥探我的聊天内容是吧，咱们多少还是希望能有些隐私的。</p><p><strong>加密</strong>自然而然的出现了。</p><p>我们通过某种方法对明文原本的信息进行可逆的改变，别人只要不知道我们是如何改变的，就无法还原，只有我们才能够还原为明文。<br>加密后无法直接理解的信息，我们就叫做<code>密文</code>。</p><h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><h2 id="密钥"><a href="#密钥" class="headerlink" title="密钥"></a>密钥</h2><p>通常也是一组数据，就像现实世界的钥匙，是<strong>加锁/解锁</strong>的关键。</p><h2 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h2><p>首先创建一把<strong>密钥</strong>。</p><p>通过这把密钥可以加密明文；<br>对密文的解密也需要<strong>同样的一把密钥</strong>。<br><em>如同常见的钥匙和锁一般，加锁和解锁都是同一把钥匙。</em></p><blockquote><p>缺陷：在公共的网络环境中，密钥难以安全传递。</p></blockquote><h2 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h2><p>创建两把密钥，一把公钥，一把私钥，<strong>这两把密钥是对应关系</strong>。<br>公钥是公开的，任何人都可以获得。<br>私钥是私有的，只有创建者持有。</p><p><strong><em>公钥加密的东西，只有对应的私钥能够解密；</em></strong><br><strong><em>私钥加密的东西，只有对应的公钥能够解密。</em></strong></p><p><em>相对对称加密而言，不存在密钥无法安全传递的问题。</em></p><blockquote><p>缺陷：基本上基于数学难题，加密速度十分缓慢。</p></blockquote><h2 id="信息摘要"><a href="#信息摘要" class="headerlink" title="信息摘要"></a>信息摘要</h2><p><strong>数据的指纹，具有不可逆的性质。</strong></p><p>一般输出的指纹数据长度都是固定的，便于传输。<br>通常可以用于验证数据是否被篡改。<br><strong><em>数据被篡改一位，都会导致计算出来的信息摘要不同。</em></strong></p><h1 id="安全通信"><a href="#安全通信" class="headerlink" title="安全通信"></a>安全通信</h1><p>有了上述基础，你能否在公共网络中构建安全通信信道呢？<br>我们来尝试一下。</p><h2 id="基本框架：非对称加密"><a href="#基本框架：非对称加密" class="headerlink" title="基本框架：非对称加密"></a>基本框架：非对称加密</h2><p>当然，我们的数据不能在公网上裸奔，因此首先就需要对明文进行加密。</p><p>但此时我们难以解决密钥安全传输的问题，故需要引入<code>非对称加密</code>。<br><em>你可能会想到，如果我把密钥也加密呢？那如何解密加密后的密钥呢？是不是也需要一把新的密钥？这把密钥如何传输呢？</em><br><em>往复下去也不会有变化，并没有改变无法安全传输密钥的根本问题。</em></p><h3 id="通信过程"><a href="#通信过程" class="headerlink" title="通信过程"></a>通信过程</h3><ol><li><p>假设A、B需要通信，各自创建私钥与公钥，并且交换公钥；</p><ul><li>公钥是可以公开的，任何人都可以持有。</li></ul></li><li><p>A向B发送消息之前，使用B的公钥加密，再发送给B；</p><ul><li>密文只有B能够解密，因为只有B持有对应的私钥。</li></ul></li><li><p>B向A发送消息也是如此，使用A的公钥加密，再发送给A。</p></li></ol><h3 id="第一个问题：计算效率"><a href="#第一个问题：计算效率" class="headerlink" title="第一个问题：计算效率"></a>第一个问题：计算效率</h3><p>在基础中提及到，非对称加密的计算缓慢，假设传输的数据较多，那么需要消耗大量的时间进行计算。</p><h2 id="性能提高：引入对称加密"><a href="#性能提高：引入对称加密" class="headerlink" title="性能提高：引入对称加密"></a>性能提高：引入对称加密</h2><p>此时，对称加密计算效率高的特性能够完美弥补这个缺陷，故我们还是需要引入<code>对称加密</code>：<br><em>加密方案基本上都会首先基于流行的<code>加密算法</code>，只有这种经过全世界密码学家考验的加密算法才是可靠的。</em></p><h3 id="通信过程改进"><a href="#通信过程改进" class="headerlink" title="通信过程改进"></a>通信过程改进</h3><ol><li>A、B交换公钥；</li><li>A生成本次通信的密钥，使用B的公钥加密，再将加密后的密钥发送给B；</li><li>B生成本次通信的密钥，使用A的公钥加密，再将加密后的密钥发送给A；<ul><li>此步并不一定需要，可以共用一把对称加密密钥。</li></ul></li><li>各自用私钥解密密钥，往后的通信都使用这把密钥加密/解密。</li></ol><h3 id="第二个问题：中间人攻击"><a href="#第二个问题：中间人攻击" class="headerlink" title="第二个问题：中间人攻击"></a>第二个问题：中间人攻击</h3><ol><li>A、B交换公钥；<ul><li>假设A、B交换公钥的通信信道被C窃听了，C也生成了自己的公钥与私钥对，将A、B的公钥保存起来，并将信道上的A、B的公钥替换为C的公钥发给对方；</li><li>A收到的是C的公钥，B收到的也是C的公钥。</li></ul></li><li>A、B交换密钥；<ul><li>A使用C的公钥加密密钥，发往B；<ul><li>依旧被C劫持，C通过私钥解密，得到原始密钥，再将其通过B的公钥加密，替换后发往B。</li></ul></li><li>B收到B的公钥加密的密钥，用B的私钥解密，得到密钥。</li><li>B发往A同理。</li></ul></li></ol><p>这个过程中，A和B看似正常安全的通信，实际上自以为隐私的通信信道早已被C看得干干净净。</p><ul><li>对于A而言，<strong>C伪造身份为B与A通信</strong>；</li><li>对于B而言，<strong>C伪造身份为A与B通信</strong>。</li></ul><h2 id="避免篡改：数据指纹"><a href="#避免篡改：数据指纹" class="headerlink" title="避免篡改：数据指纹"></a>避免篡改：数据指纹</h2><p>你可能会想到，既然信息摘要可以避免数据被篡改，那么能不能在发送公钥的时候顺带发送信息摘要来避免中间人伪造身份？</p><p>实际上是不行的，因为<strong>中间人完全可以重新使用相同的信息摘要算法重新计算被替换的公钥，得到新的指纹，将信息摘要也替换。</strong><br><em>而接收者无法辨别信息摘要是否已被替换。</em></p><h2 id="验明身份：数字证书"><a href="#验明身份：数字证书" class="headerlink" title="验明身份：数字证书"></a>验明身份：数字证书</h2><p>首先想一下，现实世界咱们是如何证明你是你呢？<br>多数情况下都是亮出身份证，对吧，我们有国家颁发的身份证。<br>因为是国家颁发的，有<code>权威性</code>和<code>公信力</code>，大家伙都相信和认可。</p><p>在公网上证明你是你的话，也得拿出证据说话，随便说说我是不认的，谁知道你是不是中间人那个坏蛋呢？</p><p>因此，证书自然就出现了。</p><hr><h3 id="证书"><a href="#证书" class="headerlink" title="证书"></a>证书</h3><p>证书类似”身份证”，用于证明某个人(公司)的身份，如：</p><p>所有者：ABC, www.abc.com<br>公钥：xxxxxx<br>颁发CA机构：XXX<br>…</p><hr><p>证书当中记录了一些必要的信息，当然，就简简单单的在证书里写我是XXX，那肯定也不行，因为一点可信度都没有，中间人也可以给你发这么一串数据，说他也是XXX，你是信还是不信呢？</p><p>因此引入证书也不可避免的产生了一个问题：<strong>证书也能被替换</strong>。</p><h2 id="拒绝伪造：数字签名"><a href="#拒绝伪造：数字签名" class="headerlink" title="拒绝伪造：数字签名"></a>拒绝伪造：数字签名</h2><p>上面我们提到过，私钥加密的东西，只有公钥才能解密。<br>咋一看好像没什么鸡蛋饼用，我这私钥加密，所有人都能解密，这有个啥用啊？<br>实际上，这也是验证身份的核心关键：<code>不可抵赖性</code>。</p><p>如果我们将这个特性应用到证书上呢？</p><p>A的私钥只有A持有，那么A用私钥加密的A证书，只有用A的公钥才能正确解密。<br>B想要判断A的身份，只需要用A的公钥解密A证书，如果能够正确解密的话，那么这个证书就一定是A的，别人无法伪造的东西，A自然无法抵赖，也就验明了A的身份。</p><p>我们就把经过公钥加密的证书叫做<code>数字证书</code>。</p><p>而用私钥加密数据的过程就叫做<code>数字签名</code><br><strong>数字签名具备不可抵赖性</strong>。</p><p>咋一看好像已经完结撒花了，实际上还是无法真正避免中间人攻击。<br>因为A的公钥需要在公网上传播，就存在被C偷天换日，替换为C的公钥的可能。</p><p>B以为拿到的是A的公钥，实际上还是C的公钥，因此C用C的私钥伪造数字证书再发给B，B当然能够正确解密，这也给了B一个错觉：和我通信的A的身份没有问题。<br>所以A和B见面后：</p><blockquote><p>B：就是你，A！你为什么要骂我？我要和你绝交！<br>A：？？？？啥啊，我说啥了！<br>B：还想抵赖？我都能用你的公钥解开你的数字证书！</p></blockquote><h2 id="无奈之举：本地预装"><a href="#无奈之举：本地预装" class="headerlink" title="无奈之举：本地预装"></a>无奈之举：本地预装</h2><p>哪里都有C这个小人，咱们实在是没法子了，干脆直接在本地计算机中预先存放公钥吧，这样C就没有替换公钥的机会了。</p><p>但是这样又会出现其他的问题：</p><ul><li>如何提前预装需要与其通信的对象的公钥？这就跟如何安全交换对称加密密钥是一个难度了，属于物理层面的难题。</li></ul><h2 id="最终解法：权威机构"><a href="#最终解法：权威机构" class="headerlink" title="最终解法：权威机构"></a>最终解法：权威机构</h2><p>人们怎么能被C这个小人打败呢？于是，这么一套验证体系出现了：<br><strong>在本地计算机中预装<code>权威机构CA</code>颁发的<code>数字证书</code>，通过CA的数字证书来验证经过了公网的数字证书是否可信，避免中间人攻击。</strong></p><h3 id="CA证书授权中心"><a href="#CA证书授权中心" class="headerlink" title="CA证书授权中心"></a>CA证书授权中心</h3><p><strong><code>CA证书授权(CertificateAuthority)中心</code>是数字证书发行的唯一机构。</strong></p><p>CA机构持有自己的公钥与私钥</p><ul><li>公钥是公开的，会包含在<strong>数字证书</strong>内，预置到操作系统/浏览器中。<ul><li>即CA机构会生成一份自己的明文证书(里面的公钥就是公开的公钥)，然后自己用私钥<strong>签名</strong>(又或者是交给其他CA机构去签名)，自签发的数字证书就应该是根证书，不管是自签发还是其他CA机构签发的，最后都会得到<strong>数字证书</strong>。</li></ul></li><li>私钥由CA机构自行保存。<ul><li>这样子就保证了数字签名的可靠，因为别人是无法得到CA机构的私钥的，也就无法伪造该CA机构所签发的数字证书。</li></ul></li></ul><h2 id="签发数字证书"><a href="#签发数字证书" class="headerlink" title="签发数字证书"></a>签发数字证书</h2><p>B假定是服务器，他如果想和客户端建立安全信道，得到客户端的信任，就需要先向CA机构申请数字证书。</p><ul><li>B提交证书；</li><li>CA机构对证书进行签名，得到数字证书，交回给B。</li></ul><p>签发后的数字证书包含了：<strong>证书内容</strong>、<strong>摘要算法</strong>、<strong>加密摘要信息</strong> 三部分。</p><p>CA机构使用摘要算法对证书内容进行计算，得到摘要信息，再对摘要信息使用私钥进行加密。<br><em>为什么不直接加密证书内容？因为加密摘要信息可以减少计算量，同样也可以保证数字证书不被篡改。</em></p><p>客户端收到B的数字证书时，就会先使用预装的CA数字证书(包含了CA的公钥)对加密摘要信息进行解密，同时用摘要算法对证书内容进行计算，得到摘要信息。<br>最后比较解密后的摘要信息与计算得出的摘要信息，相同则表示数据并未被篡改。</p><p>看到这里想必有些读者就迷糊了：<br><strong><em>CA机构颁发的数字证书和服务器的数字证书到底是不是一回事呢？</em></strong><br>可以说是一回事，他们是逐层签发的关系。<br>我先信任我计算机中的数字证书，而服务器发过来的数字证书又是我所信任的数字证书对应的私钥(CA机构持有)签发的(通过我所信任的数字证书进行验证)，故我再信任服务器发过来的数字证书。</p><p><strong><em>可为什么预装的是数字证书，而不是直接是公钥呢？</em></strong><br>有更多的信息需要存放，因此将其封装是更好的选择。</p><p><strong><em>为什么是服务器申请数字证书，客户端不需要吗？</em></strong><br>首先数字证书通常需要向权威机构申请，并且是需要钱的；<br>其次也很难为全世界所有计算机都分配数字证书；<br>最后通常也无需验证客户端的身份，因为服务器所服务的对象绝大多数应用场景下并不特指某个客户端(不管你是正常用户还是坏蛋，我都一视同仁)，只需要客户端认证服务器的身份就足够了。</p><h1 id="验证过程"><a href="#验证过程" class="headerlink" title="验证过程"></a>验证过程</h1><h2 id="签名："><a href="#签名：" class="headerlink" title="签名："></a>签名：</h2><ol><li>A生成证书(填好个人信息)，发给CA机构。</li><li>CA机构通过散列函数对明文证书进行计算，得到明文证书的信息摘要。</li><li>CA机构通过持有的私钥加密信息摘要，其结果即<strong>数字签名</strong>。</li><li>将明文证书以及数字签名打包，即得到<strong>数字证书</strong>，再发给申请者A。</li></ol><h2 id="验签："><a href="#验签：" class="headerlink" title="验签："></a>验签：</h2><ol><li>B收到A发来的<strong>数字证书</strong>，包含了明文证书与CA机构签发的<strong>数字签名</strong>。</li><li>B通过本地预置的CA机构<strong>数字证书</strong>中的公钥，对<strong>数字签名</strong>进行解密，得到信息摘要</li><li>B通过散列函数对明文证书进行计算，得到明文证书的信息摘要。</li><li>比较计算明文证书得到的信息摘要与解密<strong>数字签名</strong>得到的信息摘要，不同则表示明文证书被篡改了。</li></ol><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><ul><li><p>CA是有能力进行中间人攻击的，因为CA持有大家伙本地计算机预置公钥的私钥。</p><ul><li>CA叫做CA的意义就在这里，CA机构必须是权威公信的，不能做出这种行为，否则将会失去大家伙的信任。</li></ul></li><li><p><strong>数字签名并非只能用于签名明文证书得到数字证书，可以用于签名任何数据防止篡改。</strong></p></li></ul><h1 id="证书信任链"><a href="#证书信任链" class="headerlink" title="证书信任链"></a>证书信任链</h1><p>如公司ABC的数字证书，就是由A机构签发的，需要用A机构的数字证书来验签；<br>而A机构的数字证书又是B机构签发的，需要用B机构的数字证书来验签；<br>这样就形成了信任链。</p><p><strong>信任过程就是逐层向上的验签，直到根证书(Root，即自签名的证书)为止；</strong><br><strong><em>对根证书只能无条件信任。</em></strong></p><h1 id="WindowsPE文件数字签名简述"><a href="#WindowsPE文件数字签名简述" class="headerlink" title="WindowsPE文件数字签名简述"></a>WindowsPE文件数字签名简述</h1><p>Windows的PE文件如果存在数字签名，那么在其安全目录中，即包含了数字证书，再将PE文件散列值进行数字签名(由PE文件数字证书的所有者签名)，同样也包含在内。<br>首先通过本地预置数字证书证明PE文件中数字证书的可靠性，再通过PE文件中的数字证书的公钥解密(验签)数字签名，得到正确的散列值，再计算PE文件的散列值进行比较。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><blockquote><p><a href="https://blog.csdn.net/sky8336/article/details/113696551">https://blog.csdn.net/sky8336/article/details/113696551</a><br><a href="https://zhuanlan.zhihu.com/p/43789231">https://zhuanlan.zhihu.com/p/43789231</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 密码学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码学 </tag>
            
            <tag> PKI </tag>
            
            <tag> 证书 </tag>
            
            <tag> 签名 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【动手写ToyLang】6-虚拟机设计</title>
      <link href="/posts/819.html"/>
      <url>/posts/819.html</url>
      
        <content type="html"><![CDATA[<h1 id="所谓解释器"><a class="markdownIt-Anchor" href="#所谓解释器">#</a> 所谓 &quot;解释器&quot;</h1><p>我们除了能对遵循 ToyLang 语法的源文件编译之外，还要能够执行编译的结果。<br>若编译结果需要由其他程序负责执行，该程序便可称之为解释器。</p><ul><li>如先前提及的 AST 解释器。</li></ul><p>百度百科上对解释器的定义也较为模糊：</p><blockquote><p>解释器（英语：Interpreter），又译为直译器，是一种电脑程序，能够把高级编程语言一行一行直接转译运行。解释器不会一次把整个程序转译出来，只像一位 “中间人”，每次运行程序时都要先转成另一种语言再作运行，因此解释器的程序运行速度比较缓慢。它每转译一行程序叙述就立刻运行，然后再转译下一行，再运行，如此不停地进行下去。</p></blockquote><p>按照百度百科的定义，一行一行动态执行高级编程语言的程序，才能算解释器。<br>但是以现在常见的编程语言，如 Python、Java 等也在某些情况下会被定义为解释型语言来看，已经与 &quot;解释器&quot; 的定义相违背了。<br>因为 Python 和 Java 并不是逐行解释源代码的，实际上得以 &quot;解释&quot; 的是字节码，而执行字节码的程序又被称为 &quot;虚拟机&quot;。</p><p>我的个人理解是，“解释器”、&quot;解释型语言&quot; 等名词的诞生，或许是为了与在当时已成体系的本地编译型语言进行区分，不过历史是否如此我也不好追溯了。</p><p>因此，不必过度纠结 &quot;解释器&quot; 和 &quot;虚拟机&quot;，可以简单理解成解释器是一种笼统的统称，虚拟机是一种具体的实现，AST 解释器则是另一种实现，最终目标都是为了使得源代码得以以某种方式运行起来。</p><h1 id="虚拟机简述"><a class="markdownIt-Anchor" href="#虚拟机简述">#</a> 虚拟机简述</h1><p>想必各位读者读者也经常见过<strong>虚拟机</strong>这个词。</p><p>咱们的 ToyLang 不选择直接解释 AST，而是设计虚拟机以执行编译结果。</p><blockquote><p>虚拟机在不同场景下，所代指的东西存在差异，此处仅解释在编译原理中虚拟机的定义。</p></blockquote><p><em>实际上，虚拟机的开发应该是在更靠后一些的章节中讲述，在编写指令生成时顺带完成虚拟机。</em><br><em>不过虚拟机的编写并不复杂，并且相对独立，因此就提前将其设计好，代码生成时以我们所设计的虚拟机为准去生成代码，有需要再对虚拟机进行修改与补充。</em></p><p>我们并不选择生成本地代码 (与机器相关的机器指令)，而是生成一种被称为 <code>字节码</code> 的编译产物。</p><p>如果读者曾经学习过 <code>Java</code> ，应该或多或少听过这种说法：</p><blockquote><p>Java 并不直接生成 <code>机器指令</code> ，而是生成 <code>字节码</code> ，交给 <code>JVM</code>  去执行。</p></blockquote><p>以我个人的理解看来， <code>机器指令</code> 和 <code>字节码</code> 并没有特别多的区别，只不过负责执行的对象不一样：</p><ul><li>一个是直接由硬件执行</li><li>一个是模拟了硬件执行指令的流程的程序，自己设计了一套指令集。</li></ul><p>是的，我们所做的也与 <code>Java</code>  类似，我们也会设计 ToyLang 所生成的字节码，以及执行字节码的虚拟机。<br>当然这个虚拟机你要叫什么都可以，我在这里就把它叫成 <code>TVM(Toy Virtual Machine)</code> ，</p><h1 id="tvm"><a class="markdownIt-Anchor" href="#tvm">#</a> TVM</h1><p>我们的 <code>TVM</code>  设计十分简单，只有十几条指令，但也足够我们使用了。</p><p>为了实现更加简单， <code>TVM</code>  被设计为基于栈的虚拟机。</p><h2 id="指令集设计"><a class="markdownIt-Anchor" href="#指令集设计">#</a> 指令集设计</h2><h3 id="指令结构"><a class="markdownIt-Anchor" href="#指令结构">#</a> 指令结构</h3><table><thead><tr><th style="text-align:left">字段</th><th style="text-align:left">长度</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">Reserved</td><td style="text-align:left">1bit</td><td style="text-align:left">保留位</td></tr><tr><td style="text-align:left">Opcode</td><td style="text-align:left">7bit</td><td style="text-align:left">操作码</td></tr><tr><td style="text-align:left">Immediate</td><td style="text-align:left">4byte</td><td style="text-align:left">立即数，可选</td></tr></tbody></table><h3 id="opcode"><a class="markdownIt-Anchor" href="#opcode">#</a> Opcode</h3><p>Opcode，即操作码，是指令的一部分，在虚拟机的指令解码器在会根据指令的 Opcode 来进行不同的操作。<br>以下是 TVM 指令集的 Opcode 表：</p><table><thead><tr><th style="text-align:left">助记符</th><th style="text-align:left">编码</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">stop</td><td style="text-align:left">0x00</td><td style="text-align:left">停止虚拟机</td></tr><tr><td style="text-align:left">nop</td><td style="text-align:left">0x01</td><td style="text-align:left">空指令</td></tr><tr><td style="text-align:left">pushk</td><td style="text-align:left">0x02</td><td style="text-align:left">将常量推入栈顶</td></tr><tr><td style="text-align:left">pushv</td><td style="text-align:left">0x03</td><td style="text-align:left">将变量推入栈顶</td></tr><tr><td style="text-align:left">pop</td><td style="text-align:left">0x04</td><td style="text-align:left">弹出栈顶值并抛弃</td></tr><tr><td style="text-align:left">popv</td><td style="text-align:left">0x05</td><td style="text-align:left">弹出栈顶值并保存到变量中</td></tr><tr><td style="text-align:left">add</td><td style="text-align:left">0x06</td><td style="text-align:left">依次弹出栈顶的值，stack2 + stack1，压入结果</td></tr><tr><td style="text-align:left">sub</td><td style="text-align:left">0x07</td><td style="text-align:left">依次弹出栈顶的值，stack2 - stack1，压入结果</td></tr><tr><td style="text-align:left">mul</td><td style="text-align:left">0x08</td><td style="text-align:left">依次弹出栈顶的值，stack2 * stack1，压入结果</td></tr><tr><td style="text-align:left">div</td><td style="text-align:left">0x09</td><td style="text-align:left">依次弹出栈顶的值，stack2 /stack1，压入结果</td></tr><tr><td style="text-align:left">call</td><td style="text-align:left">0x0a</td><td style="text-align:left">函数调用</td></tr><tr><td style="text-align:left">ret</td><td style="text-align:left">0x0b</td><td style="text-align:left">函数调用返回</td></tr><tr><td style="text-align:left">ne</td><td style="text-align:left">0x0c</td><td style="text-align:left">不等于比较</td></tr><tr><td style="text-align:left">eq</td><td style="text-align:left">0x0d</td><td style="text-align:left">等于比较</td></tr><tr><td style="text-align:left">lt</td><td style="text-align:left">0x0e</td><td style="text-align:left">小于比较</td></tr><tr><td style="text-align:left">le</td><td style="text-align:left">0x0f</td><td style="text-align:left">小于等于比较</td></tr><tr><td style="text-align:left">gt</td><td style="text-align:left">0x10</td><td style="text-align:left">大于比较</td></tr><tr><td style="text-align:left">ge</td><td style="text-align:left">0x11</td><td style="text-align:left">大于等于比较</td></tr><tr><td style="text-align:left">jcf</td><td style="text-align:left">0x12</td><td style="text-align:left">条件为否则跳转</td></tr><tr><td style="text-align:left">jmp</td><td style="text-align:left">0x13</td><td style="text-align:left">无条件跳转</td></tr></tbody></table><h3 id="toylang-源码-最终转换为-虚拟机指令的简单示例"><a class="markdownIt-Anchor" href="#toylang-源码-最终转换为-虚拟机指令的简单示例">#</a> ToyLang 源码 最终转换为 虚拟机指令的简单示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">if a == 1 &#123;</span><br><span class="line">    print(&quot;a==1&quot;);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">    print(&quot;a!=1&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pushv a</span><br><span class="line">pushk 1</span><br><span class="line">eq</span><br><span class="line">jcf .else</span><br><span class="line">...</span><br><span class="line">jmp .end</span><br><span class="line">...</span><br><span class="line">.end:</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编译原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译原理 </tag>
            
            <tag> 动手写ToyLang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【保护模式】x64下定位随机页表基址的思路</title>
      <link href="/posts/41fe.html"/>
      <url>/posts/41fe.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言">#</a> 前言</h1><p><em>昨天在看周哥讲 x64 内核的时候，得知了 windows10 的某个版本开始，页表基址不再固定了。</em><br><em>今天晚上突然有了个思路，就动手把他敲出来了，这种思路是不是已经烂大街了我也不确定，就当发出来学习交流吧。</em></p><h1 id="随机页表基址原理"><a class="markdownIt-Anchor" href="#随机页表基址原理">#</a> 随机页表基址原理</h1><p>这里用 x86 的 10-10-12 分页举例吧，比较好理解，理解了 x64 的也差不多的</p><p>启用了保护模式和分页机制后，咱就不能直接访问物理地址了，都会被 MMU 当作虚拟地址进行转换。</p><p>但是 cr3 存的又是物理地址，不能直接操作页表了，那咋办呢？</p><p>聪明的前辈们，选择在页目录表中选择一项 (共 1024 项，每一项 4 字节)，使其存储的物理地址与页目录表的基址 (cr3) 相同，这样子就可以构造一个访问页表的虚拟地址了，大概就是<strong>让 cpu 在地址转换的过程中绕圈圈</strong>。</p><ul><li>画个图吧</li><li><img src="/posts/41fe/1.png" class="" title="这是一张图片"></li></ul><h2 id="定位思路"><a class="markdownIt-Anchor" href="#定位思路">#</a> 定位思路</h2><ul><li>x64 也必然是随机选择 PXT 的其中一项 PXE 来存储 PXT 的物理地址，实现的随机页表基址</li><li>那么就可以通过<strong>构造所有可能指向 PXT 的虚拟地址 (共 512 项)</strong>，转换为物理地址，再与 cr3 比较，最终得到正确的 PXT 基址。</li><li>只要知道了存储 PXT 的物理地址的 PXE 的 PXI，构造 PPT/PDT/PTT 基址都很简单了</li></ul><h1 id="实现"><a class="markdownIt-Anchor" href="#实现">#</a> 实现</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PVOID <span class="title">GetPXTBase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">UINT64 cr3 = __readcr3();</span><br><span class="line"><span class="built_in">KdPrint</span>((<span class="string">&quot;yuyu:cr3:%p\n&quot;</span>, cr3));</span><br><span class="line"><span class="keyword">for</span> (UINT64 i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++) &#123;</span><br><span class="line"><span class="comment">// 通过PXI构造虚拟地址</span></span><br><span class="line">PVOID pxtBase = (PVOID)(<span class="number">0xffff000000000000</span> | (i &lt;&lt; <span class="number">12</span>) | (i &lt;&lt; <span class="number">21</span>) | (i &lt;&lt; <span class="number">30</span>) | (i &lt;&lt; <span class="number">39</span>));</span><br><span class="line">PHYSICAL_ADDRESS physical = <span class="built_in">MmGetPhysicalAddress</span>(pxtBase);</span><br><span class="line"><span class="built_in">KdPrint</span>((<span class="string">&quot;yuyu:i:%d 物理:%p 虚拟:%p\n&quot;</span>, i, physical.QuadPart, pxtBase));</span><br><span class="line"><span class="keyword">if</span> (cr3 == physical.QuadPart) &#123;</span><br><span class="line"><span class="keyword">return</span> pxtBase;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><img src="/posts/41fe/2.png" class="" title="这是一张图片"></li></ul><h1 id="结尾"><a class="markdownIt-Anchor" href="#结尾">#</a> 结尾</h1><p>理解有限，如有错误，还请指正</p><h1 id="2022514补充"><a class="markdownIt-Anchor" href="#2022514补充">#</a> 2022/5/14 补充</h1><ul><li>其实除开这个之外，我先想到的是另一个思路，即<strong>构造所有可能存储 PXT 的物理地址的 PXE 的虚拟地址</strong>。<ul><li>依旧是 512 项，探测地址是否可访问，读取 8 字节；</li><li>将其当作 PXE，取出物理页面基址，再与 cr3 进行比较。</li></ul></li><li>但是这种方法有概率出现问题，即存放的数据可能正好与 cr3 相同，但所在页面并不是 PXT。<ul><li>因此我就没有写出来，不过我想了一下，还是贴出来了，也算是一种思路嘛。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Windows内核 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 保护模式 </tag>
            
            <tag> Windows内核 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【动手写ToyLang】5.四则表达式解析与运算</title>
      <link href="/posts/329c.html"/>
      <url>/posts/329c.html</url>
      
        <content type="html"><![CDATA[<h1 id="准备冻手"><a class="markdownIt-Anchor" href="#准备冻手">#</a> 准备冻手</h1><p>理论讲那么多，想必大家也犯困了，马上就到冻手环节了，本节我们会实现一个支持括号的四则表达式编译器 &amp; AST 解释器，用以验证我们所学习的知识。</p><h1 id="ebnf文法"><a class="markdownIt-Anchor" href="#ebnf文法">#</a> EBNF 文法</h1><p>这里把本节代码所参考的 EBNF 文法贴上。</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">exp</span> = addexp</span><br><span class="line">addexp = mulexp &#123;oper2 mulexp&#125;</span><br><span class="line">oper2 = <span class="string">&#x27;+&#x27;</span> | <span class="string">&#x27;-&#x27;</span></span><br><span class="line">mulexp = parenexp &#123;oper1 parenexp&#125;</span><br><span class="line">oper1 = <span class="string">&#x27;*&#x27;</span> | <span class="string">&#x27;/&#x27;</span></span><br><span class="line">parenexp = <span class="string">&#x27;(&#x27;</span> addexp <span class="string">&#x27;)&#x27;</span> | numexp</span><br><span class="line">numexp = number</span><br></pre></td></tr></table></figure><p>我们在上节文法的基础上稍作修改，支持了括号。</p><h1 id="ast"><a class="markdownIt-Anchor" href="#ast">#</a> AST</h1><p>在编写语法分析器之前，我们需要先定义好每个 AST 节点 (符号) 的结构。</p><details class="folding-tag" blue><summary> \ToyLang\ast\exp.h </summary>              <div class='content'>              <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> AST_EXP_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AST_EXP_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lexer/token.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> toylang &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">ExpType</span> &#123;</span><br><span class="line">    kAdd,</span><br><span class="line">    kMul,</span><br><span class="line">    kNum,</span><br><span class="line">    kParen,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表达式抽象基类</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Exp</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ExpType <span class="title">GetType</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加法表达式节点</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MulExp</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AddExp</span> : <span class="keyword">public</span> Exp &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ExpType <span class="title">GetType</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">AddExp</span>(std::unique_ptr&lt;MulExp&gt; t_leftMulExp, <span class="type">const</span> std::vector&lt;TokenType&gt;&amp; t_operList, std::vector&lt;std::unique_ptr&lt;MulExp&gt;&gt;&amp;&amp; t_mulExpList);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::unique_ptr&lt;MulExp&gt; leftMulExp;</span><br><span class="line">    std::vector&lt;TokenType&gt; operList;</span><br><span class="line">    std::vector&lt;std::unique_ptr&lt;MulExp&gt;&gt; mulExpList;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 乘法表达式类</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ParenExp</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MulExp</span> : <span class="keyword">public</span> Exp &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ExpType <span class="title">GetType</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MulExp</span>(std::unique_ptr&lt;ParenExp&gt; t_leftParenExp, <span class="type">const</span> std::vector&lt;TokenType&gt;&amp; t_operList, std::vector&lt;std::unique_ptr&lt;ParenExp&gt;&gt;&amp;&amp; t_parenExpList);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::unique_ptr&lt;ParenExp&gt; leftParenExp;</span><br><span class="line">    std::vector&lt;TokenType&gt; operList;</span><br><span class="line">    std::vector&lt;std::unique_ptr&lt;ParenExp&gt;&gt; parenExpList;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 括号表达式类</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ParenExp</span> : <span class="keyword">public</span> Exp &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ExpType <span class="title">GetType</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ParenExp</span>(std::unique_ptr&lt;Exp&gt; texp);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::unique_ptr&lt;Exp&gt; exp;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数值表达式类</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">NumExp</span> : <span class="keyword">public</span> Exp &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ExpType <span class="title">GetType</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">    <span class="built_in">NumExp</span>(<span class="type">int</span> t_num);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace ast</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// AST_EXP_H_</span></span></span><br></pre></td></tr></table></figure>              </div>            </details><p>我们创建了四个类用于描述 AST 节点：<br> <code>Exp</code>  是抽象基类，只是为了让我们的实现更加优雅，实际描述节点的是下列四个类；<br> <code>AddExp</code> 、 <code>MulExp</code> 、 <code>ParenExp</code> 、 <code>NumExp</code>  皆继承自 <code>Exp</code> ，各自表示三个终结符节点和一个非终结符节点。</p><p>其中，派生类的成员变量存储了节点的连接关系与值。<br>暂时看不懂也没关系，你可以先拷贝代码，理解的关键在于语法分析器。</p><p>接下来是 AST 节点的实现，就是类的构造与析构，并没有什么特别的代码，大致浏览下即可。</p><details class="folding-tag" blue><summary> \ToyLang\ast\exp.cpp </summary>              <div class='content'>              <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;exp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> toylang &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::unique_ptr;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">ExpType <span class="title">AddExp::GetType</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ExpType::kAdd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AddExp::<span class="built_in">AddExp</span>(unique_ptr&lt;MulExp&gt; t_leftMulExp, <span class="type">const</span> std::vector&lt;TokenType&gt;&amp; t_operList, std::vector&lt;unique_ptr&lt;MulExp&gt;&gt;&amp;&amp; t_mulExpList) :</span><br><span class="line">    <span class="built_in">leftMulExp</span>(std::<span class="built_in">move</span>(t_leftMulExp)), <span class="built_in">operList</span>(t_operList), <span class="built_in">mulExpList</span>(std::<span class="built_in">move</span>(t_mulExpList)) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">ExpType <span class="title">MulExp::GetType</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ExpType::kMul;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MulExp::<span class="built_in">MulExp</span>(unique_ptr&lt;ParenExp&gt; t_leftParenExp, <span class="type">const</span> std::vector&lt;TokenType&gt;&amp; t_operList, std::vector&lt;unique_ptr&lt;ParenExp&gt;&gt;&amp;&amp; t_parenExoList) :</span><br><span class="line">    <span class="built_in">leftParenExp</span>(std::<span class="built_in">move</span>(t_leftParenExp)), <span class="built_in">operList</span>(t_operList), <span class="built_in">parenExpList</span>(std::<span class="built_in">move</span>(t_parenExoList)) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">ExpType <span class="title">ParenExp::GetType</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ExpType::kParen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ParenExp::<span class="built_in">ParenExp</span>(unique_ptr&lt;Exp&gt; t_exp) : <span class="built_in">exp</span>(std::<span class="built_in">move</span>(t_exp)) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">ExpType <span class="title">NumExp::GetType</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ExpType::kNum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NumExp::<span class="built_in">NumExp</span>(<span class="type">int</span> t_num) : <span class="built_in">num</span>(t_num) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace ast</span></span><br></pre></td></tr></table></figure>              </div>            </details><h1 id="parser"><a class="markdownIt-Anchor" href="#parser">#</a> Parser</h1><p>我们在第 2 节已经实现了一个词法分析器，接下来我们继续完成语法分析器。</p><p>以下是头文件，接下来我们把重心放到实现上。</p><details class="folding-tag" blue><summary> \ToyLang\parser\parser.h </summary>              <div class='content'>              <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PARSER_PARSER_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PARSER_PARSER_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lexer/lexer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ast/exp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> toylang &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 语法分析时发生的异常</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ParserException</span> : <span class="keyword">public</span> std::exception &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ParserException</span>(<span class="type">const</span> <span class="type">char</span>* t_msg);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parser</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Parser</span>(Lexer* t_lexer);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::unique_ptr&lt;Exp&gt; <span class="title">ParseExp</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;AddExp&gt; <span class="title">ParseAddExp</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;MulExp&gt; <span class="title">ParseMulExp</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;ParenExp&gt; <span class="title">ParseParenExp</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;NumExp&gt; <span class="title">ParseNumExp</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Lexer* m_lexer;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace parser</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// PARSER_PARSER_H_</span></span></span><br></pre></td></tr></table></figure>              </div>            </details><h2 id="解析exp"><a class="markdownIt-Anchor" href="#解析exp">#</a> 解析 <code>exp</code></h2><p>首先我们知道，我们所编写的是四则表达式运算器，那么接收到的用户输入就是一个表达式，即非终结符 <code>exp</code> ，因此，解析就是从 <code>exp</code>  开始层层下降的。</p><details class="folding-tag" blue><summary> \ToyLang\parser\parser.cpp </summary>              <div class='content'>              <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;Exp&gt; <span class="title">Parser::ParseExp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> exp = <span class="built_in">ParseAddExp</span>();</span><br><span class="line">    <span class="keyword">if</span> (!m_lexer-&gt;<span class="built_in">LookAHead</span>().<span class="built_in">Is</span>(TokenType::kEof)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">ParserException</span>(<span class="string">&quot;Incomplete parsing&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> exp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><p>代码非常简单，根据 EBNF 描述的文法来看， <code>exp</code>  由一个 <code>addexp</code>  组成；<br>因此我们调用 <code>ParseAddExp</code>  去解析 <code>addexp</code> ，返回一个 <code>AddExp</code>  类对象，返回就表示解析完成了。</p><p>接下来我们前瞻一个 token，看看是不是已经将所有 token 都吃完了，还有可用 token 就表示输入串有错误，抛出一个异常即可。</p><p>最后直接返回 <code>AddExp</code>  对象，到这里你可能有些疑惑，我们解析的不是 <code>exp</code>  吗？为什么不是返回一个 <code>Exp</code>  对象，而是返回一个 <code>AddExp</code>  对象？<br>因为实际上 EBNF 文法描述上， <code>exp</code>  就只由 <code>addexp</code>  组成，它们基本上可以看作是等价的，为了省事，我就直接让 <code>AddExp</code>  对象成为 AST 的根节点。</p><p>而我们实际上没有实现描述非终结符 <code>exp</code>  的类， <code>Exp</code>  并不是描述 <code>exp</code>  的类，只是看起来很像。<br> <code>Exp</code>  是我们另外定义的基类，基类指针自然可以指向派生类对象。</p><h2 id="解析addexp"><a class="markdownIt-Anchor" href="#解析addexp">#</a> 解析 <code>addexp</code></h2><p>接下来我们需要解析 <code>addexp</code> ，对应的类自然就是 <code>AddExp</code> ，返回它的实例化对象。</p><details class="folding-tag" blue><summary> \ToyLang\parser\parser.cpp </summary>              <div class='content'>              <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;AddExp&gt; <span class="title">Parser::ParseAddExp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> leftMulExp = <span class="built_in">ParseMulExp</span>();    <span class="comment">// 解析左边的mulexp，保存解析的结果</span></span><br><span class="line"></span><br><span class="line">    std::vector&lt;TokenType&gt; operList;</span><br><span class="line">    std::vector&lt;unique_ptr&lt;MulExp&gt;&gt; mulExpList;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 循环解析右边的mulexp</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// 前瞻一下，如果后面已经不是加法符号或者减法符号了，就可以返回了。</span></span><br><span class="line">        <span class="keyword">auto</span> token = m_lexer-&gt;<span class="built_in">LookAHead</span>();</span><br><span class="line">        <span class="keyword">if</span> (!token.<span class="built_in">Is</span>(TokenType::kOpAdd) &amp;&amp; !token.<span class="built_in">Is</span>(TokenType::kOpSub)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 吃掉刚刚前瞻的运算符号</span></span><br><span class="line">        m_lexer-&gt;<span class="built_in">NextToken</span>();</span><br><span class="line">        operList.<span class="built_in">push_back</span>(token.type);   <span class="comment">// 保存符号，因为连接两个mulexp的符号可能是加法，也可能是减法，保存起来供解释时使用</span></span><br><span class="line">        mulExpList.<span class="built_in">push_back</span>(<span class="built_in">ParseMulExp</span>());    <span class="comment">// 解析并保存右侧mulexp</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构造AddExp对象并返回</span></span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;AddExp&gt;(std::<span class="built_in">move</span>(leftMulExp), operList, std::<span class="built_in">move</span>(mulExpList));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><p>依旧是按照 EBNF 文法来解析。</p><p>我们先解析最左边的一个 <code>mulexp</code>  非终结符，接下来就可能是多对 <code>oper2</code>  和 <code>mulexp</code>  了，因此用一个循环来解析，分别保存到 <code>vector</code>  容器中。</p><h2 id="解析mulexp"><a class="markdownIt-Anchor" href="#解析mulexp">#</a> 解析 <code>mulexp</code></h2><p>接下来解析 <code>mulexp</code> ，对应的类是 <code>MulExp</code> ，返回它的实例化对象。</p><details class="folding-tag" blue><summary> \ToyLang\parser\parser.cpp </summary>              <div class='content'>              <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> leftParenExp = <span class="built_in">ParseParenExp</span>();</span><br><span class="line"></span><br><span class="line">std::vector&lt;TokenType&gt; operList;</span><br><span class="line">std::vector&lt;unique_ptr&lt;ParenExp&gt;&gt; parenExpList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">auto</span> token = m_lexer-&gt;<span class="built_in">LookAHead</span>();</span><br><span class="line">    <span class="keyword">if</span> (!token.<span class="built_in">Is</span>(TokenType::kOpMul) &amp;&amp; !token.<span class="built_in">Is</span>(TokenType::kOpDiv)) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m_lexer-&gt;<span class="built_in">NextToken</span>();</span><br><span class="line">    operList.<span class="built_in">push_back</span>(token.type);</span><br><span class="line">    parenExpList.<span class="built_in">push_back</span>(<span class="built_in">ParseParenExp</span>());</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;MulExp&gt;(std::<span class="built_in">move</span>(leftParenExp), operList, std::<span class="built_in">move</span>(parenExpList));</span><br></pre></td></tr></table></figure>              </div>            </details><p>由于 <code>addexp</code>  和 <code>mulexp</code>  的结构基本相同，他们的解析过程也一般无二。</p><h2 id="解析parenexp"><a class="markdownIt-Anchor" href="#解析parenexp">#</a> 解析 <code>parenexp</code></h2><details class="folding-tag" blue><summary> \ToyLang\parser\parser.cpp </summary>              <div class='content'>              <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;ParenExp&gt; <span class="title">Parser::ParseParenExp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> token = m_lexer-&gt;<span class="built_in">LookAHead</span>();</span><br><span class="line">    <span class="keyword">if</span> (!token.<span class="built_in">Is</span>(TokenType::kSepLParen)) &#123;        <span class="comment">// (</span></span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;ParenExp&gt;(<span class="built_in">ParseNumExp</span>());   <span class="comment">// 不是以`(`开头的子表达式，直接当成numexp解析。</span></span><br><span class="line">    &#125;</span><br><span class="line">    m_lexer-&gt;<span class="built_in">NextToken</span>();</span><br><span class="line">    <span class="keyword">auto</span> exp = <span class="built_in">ParseAddExp</span>();   <span class="comment">// 解析一个addexp</span></span><br><span class="line">    m_lexer-&gt;<span class="built_in">MatchToken</span>(TokenType::kSepRParen);        <span class="comment">// )</span></span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;ParenExp&gt;(std::<span class="built_in">move</span>(exp));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><p>解析 <code>parenexp</code>  的代码也比较简单，根据 EBNF 所描述的文法，要么就是以 <code>(</code> 开始的子表达式，要么就是数值表达式。</p><h2 id="解析numexp"><a class="markdownIt-Anchor" href="#解析numexp">#</a> 解析 <code>numexp</code></h2><details class="folding-tag" blue><summary> \ToyLang\parser\parser.cpp </summary>              <div class='content'>              <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;NumExp&gt; <span class="title">Parser::ParseNumExp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> token = m_lexer-&gt;<span class="built_in">MatchToken</span>(TokenType::kNumber);   <span class="comment">// 直接匹配一个NumberToken</span></span><br><span class="line">    <span class="type">int</span> num = <span class="built_in">atoi</span>(token.str.<span class="built_in">c_str</span>());    <span class="comment">// 字符串转整数</span></span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;NumExp&gt;(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><p><code>numexp</code>  的解析是最简单的，直接从词法分析器那边匹配一个 <code>Number</code>  类型的 token，就能拿到其字符串。</p><p>至此，语法分析告一段落。</p><h1 id="interpreter"><a class="markdownIt-Anchor" href="#interpreter">#</a> Interpreter</h1><p>经过语法分析阶段，如果一切顺利，我们就将输入串转换成了 AST，接下来我们编写一个解释器，解释这颗树，得到结果。</p><details class="folding-tag" blue><summary> \ToyLang\interpreter\interpreter.h </summary>              <div class='content'>              <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> INTERPRETER_INTERPRETER_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INTERPRETER_INTERPRETER_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ast/exp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> interpreter &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Interpreter</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">InterpretExp</span><span class="params">(Exp* exp)</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">InterpretAddExp</span><span class="params">(AddExp* exp)</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">InterpretMulExp</span><span class="params">(MulExp* exp)</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">InterpretParenExp</span><span class="params">(ParenExp* exp)</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">InterpretNumberExp</span><span class="params">(NumExp* exp)</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace interpreter</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// INTERPRETER_INTERPRETER_H</span></span></span><br></pre></td></tr></table></figure>              </div>            </details><p>头文件也很简单，就是定义了一个解释器类，其成员函数负责解释不同类型的 AST 节点。</p><details class="folding-tag" blue><summary> \ToyLang\interpreter\interpreter.cpp </summary>              <div class='content'>              <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;interpreter.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> interpreter &#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Interpreter::InterpretExp</span><span class="params">(Exp* exp)</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">InterpretAddExp</span>(<span class="built_in">static_cast</span>&lt;AddExp*&gt;(exp));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Interpreter::InterpretAddExp</span><span class="params">(AddExp* exp)</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="built_in">InterpretMulExp</span>(exp-&gt;leftMulExp.<span class="built_in">get</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; exp-&gt;operList.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (exp-&gt;operList[i] == TokenType::kOpAdd) &#123;</span><br><span class="line">            res += <span class="built_in">InterpretMulExp</span>(exp-&gt;mulExpList[i].<span class="built_in">get</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            res -= <span class="built_in">InterpretMulExp</span>(exp-&gt;mulExpList[i].<span class="built_in">get</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Interpreter::InterpretMulExp</span><span class="params">(MulExp* exp)</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="built_in">InterpretParenExp</span>(exp-&gt;leftParenExp.<span class="built_in">get</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; exp-&gt;operList.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (exp-&gt;operList[i] == TokenType::kOpMul) &#123;</span><br><span class="line">            res *= <span class="built_in">InterpretParenExp</span>(exp-&gt;parenExpList[i].<span class="built_in">get</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            res /= <span class="built_in">InterpretParenExp</span>(exp-&gt;parenExpList[i].<span class="built_in">get</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Interpreter::InterpretParenExp</span><span class="params">(ParenExp* exp)</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (exp-&gt;exp-&gt;<span class="built_in">GetType</span>() == ExpType::kNum) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">InterpretNumberExp</span>(<span class="built_in">static_cast</span>&lt;NumExp*&gt;(exp-&gt;exp.<span class="built_in">get</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">InterpretAddExp</span>(<span class="built_in">static_cast</span>&lt;AddExp*&gt;(exp-&gt;exp.<span class="built_in">get</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Interpreter::InterpretNumberExp</span><span class="params">(NumExp* exp)</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> exp-&gt;num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace interpreter</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>              </div>            </details><p>实现代码能看到些许上述语法分析的代码的影子，实际上就是树的深度优先遍历并向上返回运算结果。<br>只要理解了语法分析，解释的过程也很好理解。<br><em>如果你需要考虑四则运算的性能，甚至可以在语法分析阶段就返回数值结果，而不是构造 AST 树。</em></p><h1 id="完整测试"><a class="markdownIt-Anchor" href="#完整测试">#</a> 完整测试</h1><details class="folding-tag" blue><summary> \ToyLang\entry.cpp </summary>              <div class='content'>              <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lexer/lexer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;parser/parser.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;interpreter/interpreter.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> lexer;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> parser;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> interpreter;</span><br><span class="line"></span><br><span class="line">    Lexer lexer&#123; <span class="string">&quot;1 + 33 - 0 * (33 / 999) + 123&quot;</span> &#125;;</span><br><span class="line">    <span class="function">Parser <span class="title">parser</span><span class="params">(&amp;lexer)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> exp = parser.<span class="built_in">ParseExp</span>();</span><br><span class="line"></span><br><span class="line">    Interpreter inter;</span><br><span class="line">    <span class="type">int</span> res = inter.<span class="built_in">InterpretExp</span>(exp.<span class="built_in">get</span>());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><h1 id="完整代码"><a class="markdownIt-Anchor" href="#完整代码">#</a> 完整代码</h1><p>我将本节完整代码放到了 github 上，你可以将其克隆下来亲自调试运行，鉴于 vs 强大的调试能力，你可以一步一步观察 AST 树的构造过程，加深理解。</p><ul><li><a href="https://github.com/yuyuaqwq/ToyLang/tree/5.arithmetic">https://github.com/yuyuaqwq/ToyLang/tree/5.arithmetic</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编译原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译原理 </tag>
            
            <tag> 动手写ToyLang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【动手写ToyLang】4.递归下降</title>
      <link href="/posts/f573.html"/>
      <url>/posts/f573.html</url>
      
        <content type="html"><![CDATA[<h1 id="递归下降"><a class="markdownIt-Anchor" href="#递归下降">#</a> 递归下降</h1><p>先前用于描述的加减运算表达式的文法，实际上并不能直接通过递归下降分析法来解析。</p><p>说了这么多，递归下降到底是个什么玩意呢？<br>接下来我们通过以下能够应用递归下降进行解析的文法来解析输入串，了解其解析过程，读者大概就明白了。</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">block</span> = <span class="string">&#x27;&#123;&#x27;</span> &#123;stat&#125; <span class="string">&#x27;&#125;&#x27;</span></span><br><span class="line">stat = assignExp <span class="string">&#x27;;&#x27;</span></span><br><span class="line">assignExp = ident <span class="string">&#x27;=&#x27;</span> value</span><br><span class="line">value = number | string</span><br></pre></td></tr></table></figure><p><code>&#123;stat&#125;</code>  表示重复 <code>stat</code> ，此处表示可以有 0~n 个 <code>stat</code> 。<br>其中， <code>ident</code>  是标识符， <code>number</code> 、 <code>string</code>  是字面量，我们都会放到词法分析中去解析，故不在此列出其文法。</p><p>首先，假设 <code>block</code>  输入串为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    a = 1;</span><br><span class="line">    b = &quot;qwq&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是解析的伪代码：</p><h2 id="解析block"><a class="markdownIt-Anchor" href="#解析block">#</a> 解析 <code>block</code></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func ParseBlock(inStr) &#123;</span><br><span class="line">    inStr.match(&#x27;&#123;&#x27;);</span><br><span class="line">    while in.is(&#x27;&#125;&#x27;) == false &#123;</span><br><span class="line">        ParseStat(in);</span><br><span class="line">    &#125;</span><br><span class="line">    inStr.match(&#x27;&#125;&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先从输入串中匹配 <code>&#123;</code> 字符；<br>由于语句是可选的，因此需要检查紧接着的符号是否为 <code>&#125;</code>  字符，不是的话就可以匹配 <code>stat</code>  了；<br> <code>stat</code>  是一个非终结符，需要继续展开，此处交给 <code>ParseStat</code>  进一步解析；<br> <code>ParseStat</code>  返回后，表示一条语句的解析完成了，但语句可能存在多条，因此循环进行；<br>最后匹配一个 <code>&#125;</code>  字符；<br> <code>block</code>  解析完成。</p><p>抽象语法树如下：</p><ul><li><img src="/posts/f573/1.png" class="" title="这是一张图片"></li></ul><p><em>为什么这里没有添加 <code>&#123;</code>  和  <code>&#125;</code>  节点呢？</em><br><em>因为树构建完成后，我们自然可以知道这个节点是 block，在词法阶段的两个符号于语法树而言并无关紧要。</em></p><h2 id="解析stat"><a class="markdownIt-Anchor" href="#解析stat">#</a> 解析 <code>stat</code></h2><p>关于 <code>stat</code>  的解析，在 <code>ParseStat</code>  函数中完成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func ParseStat(inStr) &#123;</span><br><span class="line">    ParseAssignExp(inStr);</span><br><span class="line">    inStr.match(&#x27;;&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><img src="/posts/f573/2.png" class="" title="这是一张图片"></li></ul><h2 id="解析assignexp"><a class="markdownIt-Anchor" href="#解析assignexp">#</a> 解析 <code>assignExp</code></h2><p>接下来是 <code>assignExp</code> ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func ParseAssignExp(inStr) &#123;</span><br><span class="line">    inStr.match(kIdent);</span><br><span class="line">    inStr.match(&#x27;=&#x27;);</span><br><span class="line">    ParseValue(inStr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><img src="/posts/f573/3.png" class="" title="这是一张图片"></li></ul><p><em>这里同样没有将符号 <code>=</code>  作为节点添加。</em></p><h2 id="解析value"><a class="markdownIt-Anchor" href="#解析value">#</a> 解析 <code>Value</code></h2><p>最后完成关于 <code>Value</code>  的解析：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func ParseValue(inStr) &#123;</span><br><span class="line">    inStr in.is(kNumber) &#123;</span><br><span class="line">        in.match(kNumber);</span><br><span class="line">        ret;</span><br><span class="line">    &#125;</span><br><span class="line">    inStr.match(kString);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><img src="/posts/f573/4.png" class="" title="这是一张图片"></li></ul><h2 id="关键描述文法"><a class="markdownIt-Anchor" href="#关键描述文法">#</a> 关键：描述文法</h2><p><strong>这种自顶逐层向下解析，以构造语法树的分析法，就叫做递归下降。</strong><br><em>虽然笔者并没有在伪代码中添加构造树的节点相关的代码，但不妨碍读者理解递归下降。</em></p><p>你会发现，只要我们描述好了文法，用递归下降来解析输入串是一件非常简单的事情。</p><h2 id="无限递进"><a class="markdownIt-Anchor" href="#无限递进">#</a> 无限递进</h2><p>还记得我在上一篇文章中所描述的文法吗？</p><p>如果直接编写解析代码，就会形成无限递进：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func ParseExp(inStr) &#123;</span><br><span class="line">    ParseExp(inStr);</span><br><span class="line">    if inStr.is(&#x27;+&#x27;) &#123;</span><br><span class="line">        inStr.match(&#x27;+&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        inStr.match(&#x27;-&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">    ParseNumber(inStr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="左递归"><a class="markdownIt-Anchor" href="#左递归">#</a> 左递归</h1><p><strong>如果非终结符 <code>r</code>  被直接或间接推导后，其结果最左边又出现非终结符 <code>r</code>  的情况，便称之为左递归。</strong></p><p>理想解析情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">exp = exp + number</span><br><span class="line">-&gt; exp = number + number</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>代码解析情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">exp = exp + number</span><br><span class="line">-&gt; exp = exp + number + number</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="消除左递归"><a class="markdownIt-Anchor" href="#消除左递归">#</a> 消除左递归</h2><p>为此，我们需要改写文法，以避免出现左递归。</p><h2 id="四则表达式文法"><a class="markdownIt-Anchor" href="#四则表达式文法">#</a> 四则表达式文法</h2><p>首先，我们用 EBNF 描述更加完整的四则表达式文法：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">exp</span> = addexp</span><br><span class="line">addexp = addexp oper2 mulexp | mulexp</span><br><span class="line">oper2 = <span class="string">&#x27;+&#x27;</span> | <span class="string">&#x27;-&#x27;</span></span><br><span class="line">mulexp = mulexp oper1 number | number</span><br><span class="line">oper1 = <span class="string">&#x27;*&#x27;</span> | <span class="string">&#x27;/&#x27;</span></span><br></pre></td></tr></table></figure><p><em>关于 <code>number</code>  的产生式就不再列出，实际上我们会在词法分析阶段将 <code>number</code>  解析为 <code>token</code> 。</em></p><p>我们现在很容易就能看出，在该文法中，左式为 <code>addexp</code>  和 <code>mulexp</code>  的产生式都存在左递归的问题。</p><p>如何消除呢？<br>首先观察产生式 <code>addexp = addexp oper2 mulexp | mulexp</code> <br> 我们会发现这么一条规律：</p><ul><li><code>addexp</code>  的推导产生的句型，必然是 <code>mulexp &#123;oper2 mulexp&#125;</code></li></ul><p>于是我们可以重写文法为：</p><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">addexp ::= mulexp addexp<span class="string">&#x27;</span></span><br><span class="line"><span class="string">addexp&#x27;</span> ::= oper2 addexp<span class="string">&#x27; | ε</span></span><br></pre></td></tr></table></figure><p>教学时消除左递归时经常用于举例的 BNF 文法；<br>其中 <code>ε</code>  表示空。<br><em>事实上关于 BNF 的格式规范，网上许多文章的写法似乎都不尽相同，在这里笔者也不做深究了。</em></p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">addexp</span> = mulexp &#123;oper2 mulexp&#125;</span><br></pre></td></tr></table></figure><p>使用 EBNF 描述的文法，通过 <code>&#123;&#125;</code>  做了简化。</p><p><em>事实上，我们如果直接按照第一种文法编写解析代码，最终构成的语法树会存在结合律的问题。</em><br><em>如果使用第二种文法，以多叉树的形式存储其节点，则会更加简单，因此本系列文章采用第二种文法。</em></p><h1 id="构造语法树"><a class="markdownIt-Anchor" href="#构造语法树">#</a> 构造语法树</h1><p>接下来我们尝试基于此文法与表达式 <code>1 + 5 * 6</code> ，构造其抽象语法树。</p><p>以下是完整文法：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">exp</span> = addexp</span><br><span class="line">addexp = mulexp &#123;oper2 mulexp&#125;</span><br><span class="line">oper2 = <span class="string">&#x27;+&#x27;</span> | <span class="string">&#x27;-&#x27;</span></span><br><span class="line">mulexp = number &#123;oper1 number&#125;</span><br><span class="line">oper1 = <span class="string">&#x27;*&#x27;</span> | <span class="string">&#x27;/&#x27;</span></span><br></pre></td></tr></table></figure><p>以下是解析过程：</p><ul><li><img src="/posts/f573/5.png" class="" title="这是一张图片"></li><li><img src="/posts/f573/6.png" class="" title="这是一张图片"></li><li><img src="/posts/f573/7.png" class="" title="这是一张图片"></li><li><img src="/posts/f573/8.png" class="" title="这是一张图片"></li><li><img src="/posts/f573/9.png" class="" title="这是一张图片"></li></ul><p>读者不妨尝试自己编写一些表达式，然后画一画解析图，找找感觉。<br>也可以尝试自己在脑中遍历这颗语法树，看看能否能够正确计算出结果。</p><h1 id="参考文献"><a class="markdownIt-Anchor" href="#参考文献">#</a> 参考文献</h1><blockquote><p><em>[1] 消除左递归.<a href="https://blog.csdn.net/qq2071114140/article/details/102787831">https://blog.csdn.net/qq2071114140/article/details/102787831</a></em></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编译原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译原理 </tag>
            
            <tag> 动手写ToyLang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【动手写ToyLang】3.语法分析</title>
      <link href="/posts/1571.html"/>
      <url>/posts/1571.html</url>
      
        <content type="html"><![CDATA[<h1 id="语法分析"><a class="markdownIt-Anchor" href="#语法分析">#</a> 语法分析</h1><p>按照传统的编译原理教材讲述的编译器结构， <code>词法分析阶段</code> 之后，便是 <code>语法分析阶段</code> 。</p><p>以下摘自百度百科：</p><blockquote><p><em>语法分析是编译过程的一个逻辑阶段。语法分析的任务是在词法分析的基础上将单词序列组合成各类语法短语，如 “程序”，“语句”，“表达式” 等等。语法分析程序判断源程序在结构上是否正确。源程序的结构由上下文无关文法描述。语法分析程序可以用 YACC 等工具自动生成。</em></p></blockquote><p><strong>简而言之，语法分析即要求完成对输入串是否能符合语言文法规定的检查。</strong><br><em>关于文法的定义，参照下文。</em></p><h2 id="语法分析器"><a class="markdownIt-Anchor" href="#语法分析器">#</a> 语法分析器</h2><p>我们需要实现的是语法分析器。<br><strong>语法分析器的主要工作就是接收词法分析器输出的 Token，产出抽象语法树。</strong></p><p><em>本意我是不想讲太多学科中严谨定义的内容，一个是不好懂，容易劝退；一个是我个人的理解也有限。</em><br><em>所以本系列文章就只简单提及我认为的 ToyLang 开发过程中必要的东西。</em></p><h1 id="文法"><a class="markdownIt-Anchor" href="#文法">#</a> 文法</h1><p>这里还是请出百度百科：</p><blockquote><p><em>文法是一个汉语词汇，读音为 wén fǎ ，即文章的书写法规，一般用来指以文字、词语、短句、句子的编排而组成的完整语句和文章的合理性组织。</em></p></blockquote><p>学习编译原理的过程中，确实会有许多概念难以理解。</p><p>我们先简单理解成，<strong>文法就是描述如何将 token 组织成语法树的规则。</strong></p><p>我们的语言自然也需要存在文法，比如 if 语句必须按照下列文法来解析：</p><ul><li><code>if</code>   <code>exp</code>   <code>block</code></li></ul><p>当然，现在我们还是将重心放到四则表达式的解析上。</p><h2 id="上下文无关文法"><a class="markdownIt-Anchor" href="#上下文无关文法">#</a> 上下文无关文法</h2><p><strong>在推导产生式时，正在进行的非终结符展开与前后已经展开的终结符不存在关联的文法。</strong><br>可以先继续向下看。</p><h1 id="ebnf"><a class="markdownIt-Anchor" href="#ebnf">#</a> EBNF</h1><p>我们选择通过 <code>EBNF</code>  来描述 <code>ToyLang</code>  的文法。</p><p>EBNF 是什么呢？</p><blockquote><p><em>扩展巴科斯 - 瑙尔范式 (Extended Backus–Naur Form,EBNF) 是一种用于描述计算机编程语言等正式语言的与上下文无关语法的元语法 (metasyntax) 符号表示法。简而言之，它是一种描述语言的语言。它是基本巴科斯范式 (BNF) 元语法符号表示法的一种扩展。</em></p></blockquote><p>只看描述通常很难理解新事物，咱们尝试一下用 EBNF 描述四则运算表达式的文法。</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">exp</span> = exp <span class="string">&#x27;+&#x27;</span> number | exp <span class="string">&#x27;-&#x27;</span> number | number</span><br><span class="line">number = digit &#123;digit&#125;</span><br><span class="line">digit = <span class="string">&#x27;0&#x27;</span> | <span class="string">&#x27;1&#x27;</span> | <span class="string">&#x27;2&#x27;</span> | <span class="string">&#x27;3&#x27;</span> | <span class="string">&#x27;4&#x27;</span> | <span class="string">&#x27;5&#x27;</span> | <span class="string">&#x27;6&#x27;</span> | <span class="string">&#x27;7&#x27;</span> | <span class="string">&#x27;8&#x27;</span> | <span class="string">&#x27;9&#x27;</span></span><br></pre></td></tr></table></figure><p>为了便于理解，这里只描述了加法与减法。</p><h2 id="基本规则"><a class="markdownIt-Anchor" href="#基本规则">#</a> 基本规则</h2><p>读者或许没看明白，没关系，笔者简单讲解一下：</p><ul><li>在 <code>=</code>  左边的，我们称为 <code>左式</code> ；</li><li>在 <code>=</code>  右边的，我们称为 <code>右式</code> ；</li><li>这样一行式子，我们称为 <code>产生式</code> 。</li></ul><h2 id="非终结符"><a class="markdownIt-Anchor" href="#非终结符">#</a> 非终结符</h2><p><strong>是某条产生式的左式，可以用其右式代换。</strong><br>如 <code>exp</code> ， <code>number</code> ， <code>digit</code> 。</p><h2 id="终结符"><a class="markdownIt-Anchor" href="#终结符">#</a> 终结符</h2><p><strong>无法被再被代换的符号。</strong><br>如 <code>+</code> 、 <code>-</code> 、 <code>0</code> 、 <code>1</code> …。</p><blockquote><p><em>关于更多 EBNF 的语法规则，请参阅相关资料。</em></p></blockquote><h1 id="自顶向下"><a class="markdownIt-Anchor" href="#自顶向下">#</a> 自顶向下</h1><p><strong>已知 <code>输入串</code> 为某条产生式的左式，扫描输入串以不断展开其非终结符，直至只剩下终结符。</strong><br><strong>这个展开的过程我们叫做推导，这属于自顶向下解析的思想。</strong></p><h2 id="尝试解析"><a class="markdownIt-Anchor" href="#尝试解析">#</a> 尝试解析</h2><p>我们先来看第一行产生式：<br> <code>exp = exp '+' number | exp '-' number | number</code> <br> 它描述了 <code>表达式</code> 可以由：</p><ul><li><code>表达式+数字</code> 组成；</li><li>也可以由 <code>表达式-数字</code> 组成；</li><li>也可以只由 <code>数字</code> 组成。</li></ul><p><em>其中， <code>|</code>  表示或的意思，如果读者学习过正则表达式，应当很容易理解。</em></p><p>假设我们需要解析的 <code>exp</code>  非终结符输入串为 <code>1 + 2</code> ，解析过程如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">exp -&gt; exp &#x27;+&#x27; number</span><br><span class="line">        -&gt; number &#x27;+&#x27; &#x27;number&#x27;</span><br><span class="line">            -&gt; &#x27;1&#x27; &#x27;+&#x27; &#x27;number&#x27;</span><br><span class="line">                -&gt; &#x27;1&#x27; &#x27;+&#x27; &#x27;2&#x27;</span><br></pre></td></tr></table></figure><p>就是在重复将右式中的非终结符展开的过程。<br><em>这里为了节约篇幅，笔者没有将从 number 推导成 digit，再推导成数字的推导过程记录下来，读者明白这一点即可。</em></p><p>再尝试一下解析 <code>exp</code>  非终结符输入串 <code>1</code>   <code>+</code>   <code>2</code>   <code>-</code>   <code>3</code> :</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">exp -&gt; exp &#x27;-&#x27; number</span><br><span class="line">        -&gt; exp &#x27;+&#x27; number &#x27;-&#x27; number</span><br><span class="line">            -&gt; number &#x27;+&#x27; number &#x27;-&#x27; number</span><br><span class="line">                -&gt; &#x27;1&#x27; &#x27;+&#x27; number &#x27;-&#x27; number</span><br><span class="line">                    -&gt; &#x27;1&#x27; &#x27;+&#x27; &#x27;2&#x27; &#x27;-&#x27; number</span><br><span class="line">                        -&gt; &#x27;1&#x27; &#x27;+&#x27; &#x27;2&#x27; &#x27;-&#x27; &#x27;3&#x27;</span><br></pre></td></tr></table></figure><p>当然，这个推导过程我们忽略了很多细节，并不能直接编写代码实现。</p><h1 id="尾声"><a class="markdownIt-Anchor" href="#尾声">#</a> 尾声</h1><p>在下一篇文章，我们会通过 EBNF 来描述完整的四则表达式的文法，并讲解 <code>递归下降</code> 分析法。</p><h1 id="参考文献"><a class="markdownIt-Anchor" href="#参考文献">#</a> 参考文献</h1><blockquote><p><em>[1] 扩展巴科斯范式 (EBNF) 简介.<a href="https://blog.csdn.net/lin_strong/article/details/78583543">https://blog.csdn.net/lin_strong/article/details/78583543</a></em><br><em> [2] 应该如何理解「上下文无关文法」？.<a href="https://www.zhihu.com/question/21833944">https://www.zhihu.com/question/21833944</a></em><br><em> 其他网络上较为零散的资料，无法一一列举，十分抱歉。</em></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编译原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译原理 </tag>
            
            <tag> 动手写ToyLang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【动手写ToyLang】2.词法分析</title>
      <link href="/posts/aca7.html"/>
      <url>/posts/aca7.html</url>
      
        <content type="html"><![CDATA[<h1 id="词法分析"><a class="markdownIt-Anchor" href="#词法分析">#</a> 词法分析</h1><p>词法分析是整个编译器结构中最简单的一个阶段，所以放轻松，咱们往下看。</p><p>那么，词法分析是什么呢？<br>我们知道，程序开发者编写的源代码，也就是编译器最初能够接收到的输入，即连续的字符序列。</p><p><strong>词法分析存在的意义，就是提前将源代码切分成能被后续编译程序直接使用的单词序列。</strong></p><ul><li>如源代码中的变量标识，关键字，字符串字面量，数值字面量等…</li></ul><p>我们上一节课所展示的算术表达式， <code>3 + 2</code> ，也是先将其分成 <code>3</code>   <code>+</code>   <code>2</code>  三个节点，才能用于构成抽象语法树。</p><p><strong>词法分析器产出的单词序列，我们将其称为 <code>Token</code> 。</strong></p><hr><h1 id="输入四则运算表达式产出token"><a class="markdownIt-Anchor" href="#输入四则运算表达式产出token">#</a> 输入四则运算表达式，产出 <code>Token</code></h1><p>我们既然需要将四则运算表达式转成 <code>Token</code> ，也就需要知道其单词序列的规则，当然，关于这一点，我们早已烂熟于心了。<br>以下是我通过正则表达式描述的 <code>Token</code>  匹配规则 (以我们将要开发的词法分析器为准)。</p><table><thead><tr><th style="text-align:left">TokenType</th><th style="text-align:left">Regex</th></tr></thead><tbody><tr><td style="text-align:left">Eof</td><td style="text-align:left">\0</td></tr><tr><td style="text-align:left">Number</td><td style="text-align:left">\d+</td></tr><tr><td style="text-align:left">OpAdd</td><td style="text-align:left">+</td></tr><tr><td style="text-align:left">OpSub</td><td style="text-align:left">-</td></tr><tr><td style="text-align:left">OpMul</td><td style="text-align:left">*</td></tr><tr><td style="text-align:left">OpDiv</td><td style="text-align:left">/</td></tr><tr><td style="text-align:left">SepLParen</td><td style="text-align:left">(</td></tr><tr><td style="text-align:left">SepRParen</td><td style="text-align:left">)</td></tr></tbody></table><p><em>此处笔者忽略了运算符在正则表达式中需要转义的情况，做一个参考即可。</em></p><h1 id="lexer"><a class="markdownIt-Anchor" href="#lexer">#</a> Lexer</h1><p>Lexer，即词法分析器。<br>接下来我们编写代码实现 Lexer。</p><h2 id="token"><a class="markdownIt-Anchor" href="#token">#</a> Token</h2><details class="folding-tag" blue><summary> \ToyLang\lexer\token.h </summary>              <div class='content'>              <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> LEXER_TOKEN_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEXER_TOKEN_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> toylang &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// token类型常量</span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">TokenType</span> &#123;</span><br><span class="line">kNil = <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">kEof,</span><br><span class="line">kNumber,</span><br><span class="line"></span><br><span class="line">kOpAdd,    <span class="comment">// +</span></span><br><span class="line">kOpSub,    <span class="comment">// -</span></span><br><span class="line">kOpMul,    <span class="comment">// *</span></span><br><span class="line">kOpDiv,    <span class="comment">// /</span></span><br><span class="line"></span><br><span class="line">kSepLPar,  <span class="comment">// (</span></span><br><span class="line">kSepRPar,  <span class="comment">// )</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 描述token的结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Token</span> &#123;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Is</span><span class="params">(TokenType t_type)</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> line;<span class="comment">// 行号</span></span><br><span class="line">TokenType type;<span class="comment">// token类型</span></span><br><span class="line">std::string str;<span class="comment">// 保存必要的信息</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace lexer</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// LEXER_TOKEN_H_</span></span></span><br></pre></td></tr></table></figure>              </div>            </details><details class="folding-tag" blue><summary> \ToyLang\lexer\token.cpp </summary>              <div class='content'>              <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;token.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> lexer &#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Token::Is</span><span class="params">(TokenType t_type)</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t_type == type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace lexer</span></span><br></pre></td></tr></table></figure>              </div>            </details><p>token 这部分十分简单，不赘述了。</p><h2 id="lexer-2"><a class="markdownIt-Anchor" href="#lexer-2">#</a> Lexer</h2><details class="folding-tag" blue><summary> \ToyLang\lexer\lexer.h </summary>              <div class='content'>              <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> LEXER_LEXER_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEXER_LEXER_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;lexer/token.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> lexer &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 词法分析时发生的异常</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LexerException</span> : <span class="keyword">public</span> std::exception &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">LexerException</span>(<span class="type">const</span> <span class="type">char</span>* t_msg);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 词法分析器类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Lexer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Lexer</span>(<span class="type">const</span> <span class="type">char</span>* t_src);</span><br><span class="line">~<span class="built_in">Lexer</span>() <span class="keyword">noexcept</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">NextChar</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SkipChar</span><span class="params">(<span class="type">int</span> count)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">Token <span class="title">LookAHead</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">Token <span class="title">NextToken</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">Token <span class="title">MatchToken</span><span class="params">(TokenType type)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">std::string m_src;</span><br><span class="line"><span class="type">size_t</span> m_idx;</span><br><span class="line">Token m_save;</span><br><span class="line"><span class="type">int</span> m_line;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace lexer</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// LEXER_LEXER_H_</span></span></span><br></pre></td></tr></table></figure>              </div>            </details><details class="folding-tag" blue><summary> \ToyLang\lexer\lexer.cpp </summary>              <div class='content'>              <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lexer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> toylang &#123;</span><br><span class="line"></span><br><span class="line">LexerException::<span class="built_in">LexerException</span>(<span class="type">const</span> <span class="type">char</span>* t_msg) : std::<span class="built_in">exception</span>(t_msg) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Lexer::<span class="built_in">Lexer</span>(<span class="type">const</span> <span class="type">char</span>* t_src) : m_src&#123; t_src &#125;, m_line&#123; <span class="number">0</span> &#125;, m_idx&#123; <span class="number">0</span> &#125;, m_save&#123; <span class="number">0</span>, TokenType::kNil &#125; &#123;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Lexer::~<span class="built_in">Lexer</span>() <span class="keyword">noexcept</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取下一字符</span></span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">Lexer::NextChar</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_idx &lt; m_src.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> m_src[m_idx++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 跳过指定字符数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Lexer::SkipChar</span><span class="params">(<span class="type">int</span> count)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    m_idx += count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前瞻下一Token</span></span><br><span class="line"><span class="function">Token <span class="title">Lexer::LookAHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_save.type == TokenType::kNil) &#123;        <span class="comment">// 如果没有前瞻过</span></span><br><span class="line">        m_save = <span class="built_in">NextToken</span>();       <span class="comment">// 获取</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m_save;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取下一Token</span></span><br><span class="line"><span class="function">Token <span class="title">Lexer::NextToken</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Token token;</span><br><span class="line">    <span class="keyword">if</span> (!m_save.<span class="built_in">Is</span>(TokenType::kNil)) &#123;        <span class="comment">// 如果有前瞻保存的token</span></span><br><span class="line">        <span class="comment">// 返回前瞻的结果</span></span><br><span class="line">        token = m_save;</span><br><span class="line">        m_save.type = TokenType::kNil;</span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 跳过空格</span></span><br><span class="line">    <span class="keyword">while</span> ((c = <span class="built_in">NextChar</span>()) &amp;&amp; c == <span class="string">&#x27; &#x27;</span>);</span><br><span class="line"></span><br><span class="line">    token.line = m_line;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        token.type = TokenType::kEof;</span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据字符返回对应类型的Token</span></span><br><span class="line">    <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">        token.type = TokenType::kOpAdd;</span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">        token.type = TokenType::kOpSub;</span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">        token.type = TokenType::kOpMul;</span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">        token.type = TokenType::kOpDiv;</span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">        token.type = TokenType::kSepLParen;</span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">        token.type = TokenType::kSepRParen;</span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (c &gt;= <span class="string">&#x27;0&#x27;</span> || c &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        token.type = TokenType::kNumber;</span><br><span class="line">        token.str.<span class="built_in">push_back</span>(c);</span><br><span class="line">        <span class="keyword">while</span> (c = <span class="built_in">NextChar</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">                token.str.<span class="built_in">push_back</span>(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">SkipChar</span>(<span class="number">-1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">LexerException</span>(<span class="string">&quot;cannot parse token&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配下一Token</span></span><br><span class="line"><span class="function">Token <span class="title">Lexer::MatchToken</span><span class="params">(TokenType type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> token = <span class="built_in">NextToken</span>();</span><br><span class="line">    <span class="keyword">if</span> (token.<span class="built_in">Is</span>(type)) &#123;</span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">LexerException</span>(<span class="string">&quot;cannot match token&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace lexer</span></span><br></pre></td></tr></table></figure>              </div>            </details><p>我们封装了一个词法分析器类；<br> <code>Lexer::LookAHead</code>  前瞻一个 Token。<br> <code>Lexer::NextToken</code>  是关键成员函数，用于扫描字符序列，匹配一个完整的 Token 并返回，如果前瞻过则返回前瞻的结果。<br> <code>Lexer::MatchToken</code>  要求下一 token 为指定类型，否则会抛出异常。</p><h1 id="测试成果"><a class="markdownIt-Anchor" href="#测试成果">#</a> 测试成果</h1><p>接下来，我们编写测试代码，用于测试新鲜出炉的词法分析器。<br>用于测试的表达式是： <code>1 + 33 - 0 * (33 / 999) - 123</code></p><details class="folding-tag" blue><summary> \entry.cpp </summary>              <div class='content'>              <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lexer/lexer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> toylang;</span><br><span class="line"></span><br><span class="line">    Lexer lexer&#123; <span class="string">&quot;1 + 33 - 0 * (33 / 999) - 123&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">auto</span> token = lexer.<span class="built_in">NextToken</span>();</span><br><span class="line">        <span class="keyword">if</span> (token.<span class="built_in">Is</span>(TokenType::kEof)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (token.type) &#123;</span><br><span class="line">        <span class="keyword">case</span> TokenType::kNumber:&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, token.str.<span class="built_in">c_str</span>()); <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> TokenType::kOpAdd: &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;+\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> TokenType::kOpDiv: &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;/\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> TokenType::kOpMul: &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;*\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> TokenType::kOpSub: &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;-\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> TokenType::kSepLParen: &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;(\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> TokenType::kSepRParen: &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;)\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>              </div>            </details><details class="folding-tag" blue><summary> 打印结果 </summary>              <div class='content'>              <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">+</span><br><span class="line">33</span><br><span class="line">-</span><br><span class="line">0</span><br><span class="line">*</span><br><span class="line">(</span><br><span class="line">33</span><br><span class="line">/</span><br><span class="line">999</span><br><span class="line">)</span><br><span class="line">-</span><br><span class="line">123</span><br></pre></td></tr></table></figure>              </div>            </details>]]></content>
      
      
      <categories>
          
          <category> 编译原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译原理 </tag>
            
            <tag> 动手写ToyLang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【动手写ToyLang】1.从四则运算表达式开始</title>
      <link href="/posts/56ac.html"/>
      <url>/posts/56ac.html</url>
      
        <content type="html"><![CDATA[<h1 id="由此开始"><a class="markdownIt-Anchor" href="#由此开始">#</a> 由此开始</h1><p>如果你曾经接触过《编译原理》的话，不知道是否与我有着同样的困惑呢？</p><p>各种不近人情的名词，公式乱飞，这让我学习起来格外痛苦。</p><p>我在阅读过不少文章、书籍，并且尝试敲下一些代码之后，才逐渐理解了一些较为关键的东西。</p><p><em>实际上，当我真正完成了对四则运算表达式的解析的那一刻，我才真切感受到了编译原理的优雅与美妙之处，这大概就是由人类智慧的伟大之处吧 (偏得有点远了)。</em></p><p><strong>因此，我才会选择先从四则运算表达式开始，将其逐步扩展成为一门 <code>通用编程语言</code> ，也能让读者每一节都能感受到学习有所反馈的喜悦。</strong></p><hr><h1 id="初尝构思"><a class="markdownIt-Anchor" href="#初尝构思">#</a> 初尝构思</h1><p><strong>现在，我来尝试给你出一道题吧，请你用你所熟悉的语言，编写一个模块：</strong></p><ol><li>输入符合四则运算表达式规范的字符串 (可以假定只有整数，不存在括号)；</li><li>输出整型结果；</li><li>要求关键逻辑由自己实现，不可借由库、语言本身提供的功能。</li></ol><p>你能实现吗？</p><p>是否觉得脑子有些空白，难以组织成较为优雅的实现思路呢？</p><pre><code>如果你现在就能想到很棒的解法，那至少你要比我厉害多了。</code></pre><p>我曾经因为某些需求做过尝试，虽然最后写出来了，但是具体实现也非常丑陋，这里就不献丑了。</p><p>但是我可以给你大致描述一下我当初的思路：</p><ul><li><p>首先，查找字符串中优先级较高的运算符  <code>*</code>   <code>/</code> ，再前 / 后瞻运算符前后的数字，这个子串也能形成一个表达式；</p></li><li><p>算出结果后，在原表达式中，用结果替换掉子串 (刚刚被计算的表达式)，再继续查找。</p></li><li><p>完成后再从头开始查找优先级更低一级的运算符 <code>+</code>   <code>-</code> ，直到运算完成。</p></li></ul><p><strong>当然，我们不会用这么低效的方法，也不会要求现在就给出实现。</strong></p><p><strong>现在提出这个问题，并不是为了为难你，只是为了让你记住眼下的感觉，当你学完本系列文章后，再回来看看，这一道题，是否真的有那么难呢？</strong></p><hr><h1 id="抽象语法树"><a class="markdownIt-Anchor" href="#抽象语法树">#</a> 抽象语法树</h1><p>咱们先来看百度百科对 <code>抽象语法树</code> 的定义：</p><blockquote><p><em>在计算机科学中，抽象语法树（Abstract Syntax Tree，AST），或简称<a href="https://baike.baidu.com/item/%E8%AF%AD%E6%B3%95%E6%A0%91/7031301?fromModule=lemma_inlink">语法树</a>（Syntax tree），是<a href="https://baike.baidu.com/item/%E6%BA%90%E4%BB%A3%E7%A0%81?fromModule=lemma_inlink">源代码</a><a href="https://baike.baidu.com/item/%E8%AF%AD%E6%B3%95?fromModule=lemma_inlink">语法</a>结构的一种抽象表示。它以树状的形式表现<a href="https://baike.baidu.com/item/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80?fromModule=lemma_inlink">编程语言</a>的语法结构，树上的每个节点都表示源代码中的一种结构。</em></p></blockquote><p>嗯… 不愧是名字就带着抽象的东西，连说明都这么抽象。</p><p>咱们先不整那么多虚头巴脑的，干就完了。</p><h2 id="构造四则运算表达式的ast"><a class="markdownIt-Anchor" href="#构造四则运算表达式的ast">#</a> 构造四则运算表达式的 AST</h2><p><code>3 + 2</code></p><p>这个是大家熟悉的算术表达式，实际上，我们的大脑是如何计算这个表达式的呢？当然需要遵循某些规则：</p><ol><li>先乘除</li><li>再加减</li><li>从左往右结合</li></ol><p>那我们自然是需要先<strong>左往右找</strong>在表达式中找到 <code>*</code> 、 <code>/</code>  两种符号，好消息是，没有，嘿嘿。</p><p>接下来继续<strong>左往右找</strong> <code>+</code> 、 <code>-</code> ，找到之后将其取出，这也是我们需要计算的子表达式。</p><p>我们将其分成三部分，分别是：</p><ul><li>左边的数字  <code>3</code></li><li>加法运算符  <code>+</code></li><li>右边的数字  <code>2</code></li></ul><p>人脑的表达式计算模型，可以归纳成这么一颗树型结构：</p><ul><li><img src="/posts/56ac/1.png" class="" title="这是一张图片"></li></ul><p>遍历树与我们的计算过程极度相似：</p><ol><li>根节点，是加法，表明需要将左子节点与右子节点相加；</li><li><code>3 + 2</code> ，返回结果  <code>5</code> ；</li><li>遍历结束；</li></ol><ul><li><img src="/posts/56ac/2.png" class="" title="这是一张图片"></li></ul><h3 id="多运算符与结合律"><a class="markdownIt-Anchor" href="#多运算符与结合律">#</a> 多运算符与结合律</h3><p>那么，当一个表达式中，存在多个运算符时，应该如何构造语法树呢？<br>接下来我们构造表达式  <code>3 - 2 + 4</code>  的树。</p><p><strong>首先我们应该注意的一点是，需要先被执行运算 (优先级更高) 的子表达式，其节点的相对深度更深：</strong></p><ul><li><img src="/posts/56ac/3.png" class="" title="这是一张图片"></li></ul><p>还是先来遍历这颗树：</p><ol><li>根节点，是加法，表明需要将左子节点与右子节点相加；<ol><li>左子节点是减法，表明需要用左子节点减去右子节点，需要继续向下展开；</li><li><code>3 - 2</code> ，返回结果  <code>1</code> ；</li></ol></li><li><code>1 + 4</code> ，返回结果  <code>5</code> ；</li><li>遍历结束；</li></ol><p><strong>因此，遍历的过程也符合我们所要求的 <code>左结合律</code> 。</strong></p><ul><li>由左边的运算符开始，向右结合。</li><li>同优先级下，我们需要优先计算左边的运算符组成的子表达式，</li></ul><p>接下来我再给你画一下另一种情况，你也就明白了。</p><ul><li><img src="/posts/56ac/4.png" class="" title="这是一张图片"></li></ul><p>你可以尝试一下遍历这棵树，会发现先被执行的一定是加法，这并不符合我们的从一开始就要求的 <code>左结合律</code> 。<br>在部分情况下，由于结合律的错误，就会产出错误的结果：</p><ul><li>如我们本次求解的表达式，通过遍历此树得出的结果为 <code>-3</code> 。</li></ul><h2 id="目标根据语法规则生成ast"><a class="markdownIt-Anchor" href="#目标根据语法规则生成ast">#</a> 目标：根据语法规则生成 AST</h2><p>我不说你大概也已经猜到了，其实我们上面所构造的树，在当前的应用场景下，就叫做 <code>抽象语法树</code> 。</p><p><em><strong>遍历抽象语法树并计算的过程，与我们人脑对表达式的计算的过程是十分相似的。</strong></em></p><p><strong>也就是说，我们只需要构造出这么一颗抽象语法树，就已经基本上完成了编译工作的一大半。</strong><br><strong>此时，若需要执行编译产生的结果，只需要遍历我们所生成 AST 即可。</strong></p><p>如下图：</p><ul><li><img src="/posts/56ac/5.png" class="" title="这是一张图片"></li></ul><p>在遍历的过程中，我们就能够正确的完成对加法表达式的加法运算，再完成对赋值表达式的赋值运算。</p><hr><h1 id="ast解释器"><a class="markdownIt-Anchor" href="#ast解释器">#</a> AST 解释器</h1><p>最后，笔者向读者展示了有关 &quot;解释器&quot; 的东西，是的，即便你难以置信。<br>遍历这棵树的过程，就可以叫做解释；<br>如果我们写出代码实现遍历树的过程，即是 <code>AST解释器</code> 。</p><p>当然，解释器是一种比较广泛的概念，即便到后面我们基于 AST 生成了字节码，交给虚拟机执行，我们的程序也依然可以称之为解释器，只不过解释的对象从 AST 换成了字节码。</p><p>我个人觉得，当初造这个词的人只是为了区分所谓的 &quot;编译型语言&quot; 和 &quot;解释型语言&quot;。<br>以下是百度百科对解释器的定义：</p><blockquote><p><em>解释器（<a href="https://baike.baidu.com/item/%E8%8B%B1%E8%AF%AD/109997?fromModule=lemma_inlink">英语</a>：Interpreter），又译为直译器，是一种电脑程序，能够把高级<a href="https://baike.baidu.com/item/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80?fromModule=lemma_inlink">编程语言</a>一行一行直接转译运行。解释器不会一次把整个程序转译出来，只像一位 “中间人”，每次运行程序时都要先转成另一种语言再作运行，因此解释器的程序运行速度比较缓慢。它每转译一行程序叙述就立刻运行，然后再转译下一行，再运行，如此不停地进行下去。</em></p></blockquote><ul><li><em>此处关于 <code>每转译一行程序叙述就立刻运行</code> 的说明也不尽然，至少现在很多被称为 <code>解释器</code> 的程序，并非如此 (如 Python 解释器、Java 解释器等)。</em></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编译原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译原理 </tag>
            
            <tag> 动手写ToyLang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【动手写ToyLang】0.前言</title>
      <link href="/posts/c4d3.html"/>
      <url>/posts/c4d3.html</url>
      
        <content type="html"><![CDATA[<h1 id="关于"><a class="markdownIt-Anchor" href="#关于">#</a> 关于</h1><p><strong>本系列文章会手把手教你打造一门<emp>玩具</emp>通用编程语言。</strong></p><p>计算机本身就是一门需要动手的学科，在对基本原理有一定程度的理解之后，自己动手实践才是学习的最好捷径，为此制造 &quot;玩具&quot;，并不丢人。</p><p>我对《编译原理》这门学科的学习程度也十分有限，因此本系列文章的读者不仅仅是你们，也包括我，写下的这篇文章也是支撑我继续动手实践的动力。<br>学完本系列文章之后，基本上可以对编译原理有所认知，再继续往下学习也就不会那么困难了。</p><p><em>我会尽可能保证文章内容的准确，若还是难以避免的出现了错误，望批评指正，感激不尽。</em></p><hr><h1 id="准备工作"><a class="markdownIt-Anchor" href="#准备工作">#</a> 准备工作</h1><h2 id="开发语言"><a class="markdownIt-Anchor" href="#开发语言">#</a> 开发语言</h2><p>这里笔者选用个人较为常用的 C++ 作为开发语言，风格尽量以《Google C++ Style Guide》为准，在我个人能力范围内尽量写得 &quot;现代 C++&quot; 一点。</p><p>另外，笔者对 C++ 的理解也较为浅薄，代码写得不好，还请理解。</p><h2 id="开发环境"><a class="markdownIt-Anchor" href="#开发环境">#</a> 开发环境</h2><p>笔者基本上只在 <code>Windows</code>  下进行开发工作，因此选择自然是 <code>Visual Studio</code> ，读者可以自由选择自己喜欢的开发环境。</p><h1 id="项目地址"><a class="markdownIt-Anchor" href="#项目地址">#</a> 项目地址</h1><p>最后，笔者已经将完整的项目代码放到了 <code>github</code>  上，另外每一学习阶段的代码会以分支的形式推送，供读者参考学习。</p><ul><li><a href="https://github.com/yuyuaqwq/ToyLang">https://github.com/yuyuaqwq/ToyLang</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编译原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译原理 </tag>
            
            <tag> 动手写ToyLang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Proxifier】基本配置与使用</title>
      <link href="/posts/5e1f.html"/>
      <url>/posts/5e1f.html</url>
      
        <content type="html"><![CDATA[<h1 id="proxifier"><a class="markdownIt-Anchor" href="#proxifier">#</a> Proxifier</h1><p><strong>Proxifier 是为其他不支持指定代理服务器的应用进行强制代理的工具。</strong><br><em>其原理 (大致) 是在内核层面通过驱动过滤的形式实现的网络控制。</em></p><h1 id="下载"><a class="markdownIt-Anchor" href="#下载">#</a> 下载</h1><ul><li>官方网站<br><a href="http://www.proxifier.com/"> http://www.proxifier.com/</a></li></ul><p>应用本身是收费的，有能力请支持正版软件。</p><h1 id="配置与使用"><a class="markdownIt-Anchor" href="#配置与使用">#</a> 配置与使用</h1><h2 id="准备工作"><a class="markdownIt-Anchor" href="#准备工作">#</a> 准备工作</h2><p>这里使用 <code>Fiddler</code>  这个软件来担任代理服务器的工作。</p><p>启动 Fiddler 后，请先关闭 Windows 系统代理</p><ul><li>我们需要使用浏览器来测试强制代理，但是 Fiddler 会自动开启系统代理。</li><li>并且浏览器默认会使用系统代理。</li></ul><h2 id="启动界面"><a class="markdownIt-Anchor" href="#启动界面">#</a> 启动界面</h2><ul><li></li></ul><h2 id="配置代理服务器"><a class="markdownIt-Anchor" href="#配置代理服务器">#</a> 配置代理服务器</h2><p>工具栏 -&gt; Profile -&gt; Proxy Servers…</p><ul><li></li></ul><p>添加代理服务器</p><ul><li></li><li></li></ul><p>选择否</p><ul><li></li></ul><p>点击 OK</p><ul><li></li></ul><p>依然选择否</p><ul><li></li></ul><h2 id="配置代理规则"><a class="markdownIt-Anchor" href="#配置代理规则">#</a> 配置代理规则</h2><p>工具栏 -&gt; Profile -&gt; Proxification Rules…</p><ul><li></li></ul><p>添加代理规则，保持与我一致即可。<br>添加了一条代理规则 chrome 并启用。</p><ul><li></li><li></li></ul><p>这里说明一下选项：<br>Direct：</p><ul><li>Proxifier 放行此规则的流量<br> Block:</li><li>Proxifier 拦截此规则的流量<br> Proxy HTTPS 127.0.0.1:</li><li>这里的选项是我们先前设置的代理服务器</li><li>Proxifier 代理此规则的流量</li></ul><p>点击 OK，继续。</p><h2 id="配置域名解析"><a class="markdownIt-Anchor" href="#配置域名解析">#</a> 配置域名解析</h2><p>工具栏 -&gt; Profile -&gt; Name Rusolution…</p><ul><li></li></ul><p>指定通过代理解析域名。</p><ul><li></li></ul><p>基本上大功告成。</p><h2 id="访问测试"><a class="markdownIt-Anchor" href="#访问测试">#</a> 访问测试</h2><p>接下来通过浏览器访问网页，Fiddler 中就会看到来自 Proxifier 进程的流量。</p><ul><li></li></ul><h1 id="仍有缺陷"><a class="markdownIt-Anchor" href="#仍有缺陷">#</a> 仍有缺陷</h1><p>我们通过 <code>Proxifier</code>  配合 <code>Fiddler</code> ，能实现对应用 http/https 流量的强制抓包 / 解密。<br>但是需要注意的是， <code>Fiddler</code>  的原理是在操作系统中安装证书，以实现中间人攻击；<br>某些情况下，通过此方法抓包，应用如果无法正常上网，说明应用可能并不信任操作系统的证书，而是自己有一套证书。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【Proxifier】基本配置与使用</title>
      <link href="/posts/5e1f.html"/>
      <url>/posts/5e1f.html</url>
      
        <content type="html"><![CDATA[<h1 id="proxifier"><a class="markdownIt-Anchor" href="#proxifier">#</a> Proxifier</h1><p><strong>Proxifier 是为其他不支持指定代理服务器的应用进行强制代理的工具。</strong><br><em>其原理 (大致) 是在内核层面通过驱动过滤的形式实现的网络控制。</em></p><h1 id="下载"><a class="markdownIt-Anchor" href="#下载">#</a> 下载</h1><ul><li>官方网站<br><a href="http://www.proxifier.com/"> http://www.proxifier.com/</a></li></ul><p>应用本身是收费的，有能力请支持正版软件。</p><h1 id="配置与使用"><a class="markdownIt-Anchor" href="#配置与使用">#</a> 配置与使用</h1><h2 id="准备工作"><a class="markdownIt-Anchor" href="#准备工作">#</a> 准备工作</h2><p>这里使用 <code>Fiddler</code>  这个软件来担任代理服务器的工作。</p><p>启动 Fiddler 后，请先关闭 Windows 系统代理</p><ul><li>我们需要使用浏览器来测试强制代理，但是 Fiddler 会自动开启系统代理。</li><li>并且浏览器默认会使用系统代理。</li></ul><h2 id="启动界面"><a class="markdownIt-Anchor" href="#启动界面">#</a> 启动界面</h2><ul><li><img src="/posts/5e1f/1.png" class="" title="这是一张图片"></li></ul><h2 id="配置代理服务器"><a class="markdownIt-Anchor" href="#配置代理服务器">#</a> 配置代理服务器</h2><p>工具栏 -&gt; Profile -&gt; Proxy Servers…</p><ul><li><img src="/posts/5e1f/2.png" class="" title="这是一张图片"></li></ul><p>添加代理服务器</p><ul><li><img src="/posts/5e1f/3.png" class="" title="这是一张图片"></li><li><img src="/posts/5e1f/4.png" class="" title="这是一张图片"></li></ul><p>选择否</p><ul><li><img src="/posts/5e1f/5.png" class="" title="这是一张图片"></li></ul><p>点击 OK</p><ul><li><img src="/posts/5e1f/6.png" class="" title="这是一张图片"></li></ul><p>依然选择否</p><ul><li><img src="/posts/5e1f/7.png" class="" title="这是一张图片"></li></ul><h2 id="配置代理规则"><a class="markdownIt-Anchor" href="#配置代理规则">#</a> 配置代理规则</h2><p>工具栏 -&gt; Profile -&gt; Proxification Rules…</p><ul><li></li></ul><p>添加代理规则，保持与我一致即可。<br>添加了一条代理规则 chrome 并启用。</p><ul><li><img src="/posts/5e1f/9.png" class="" title="这是一张图片"></li><li><img src="/posts/5e1f/10.png" class="" title="这是一张图片"></li></ul><p>这里说明一下选项：<br>Direct：</p><ul><li>Proxifier 放行此规则的流量</li></ul><p>Block:</p><ul><li>Proxifier 拦截此规则的流量</li></ul><p>Proxy HTTPS 127.0.0.1:</p><ul><li>这里的选项是我们先前设置的代理服务器</li><li>Proxifier 代理此规则的流量</li></ul><p>点击 OK，继续。</p><h2 id="配置域名解析"><a class="markdownIt-Anchor" href="#配置域名解析">#</a> 配置域名解析</h2><p>工具栏 -&gt; Profile -&gt; Name Rusolution…</p><ul><li><img src="/posts/5e1f/11.png" class="" title="这是一张图片"></li></ul><p>指定通过代理解析域名。</p><ul><li><img src="/posts/5e1f/12.png" class="" title="这是一张图片"></li></ul><p>基本上大功告成。</p><h2 id="访问测试"><a class="markdownIt-Anchor" href="#访问测试">#</a> 访问测试</h2><p>接下来通过浏览器访问网页，Fiddler 中就会看到来自 Proxifier 进程的流量。</p><ul><li><img src="/posts/5e1f/13.png" class="" title="这是一张图片"></li></ul><h1 id="fiddler抓取应用配置示例"><a class="markdownIt-Anchor" href="#fiddler抓取应用配置示例">#</a> Fiddler 抓取应用配置示例</h1><ol><li>我们需要将目标端口为 <code>80</code>  和 <code>443</code>  的请求转发到 <code>Fiddler</code>  创建的代理服务器中。</li><li>将 <code>Fiddler.exe</code>  设为过滤项，(因为 <code>Fiddler</code>  再次转发请求时，又会被 <code>Proxifier</code>  捕获，因此要将其过滤)，通过右边的 <code>↑</code>   <code>↓</code> 按钮调整其优先级为最高。</li><li>这里另外示范了过滤 <code>Chrome.exe</code>  浏览器的情况，使浏览器的请求也不会被转发。</li></ol><ul><li><img src="/posts/5e1f/14.png" class="" title="这是一张图片"></li></ul><h1 id="仍有缺陷"><a class="markdownIt-Anchor" href="#仍有缺陷">#</a> 仍有缺陷</h1><p>我们通过 <code>Proxifier</code>  配合 <code>Fiddler</code> ，能实现对应用 http/https 流量的强制抓包 / 解密。<br>但是需要注意的是， <code>Fiddler</code>  的原理是在操作系统中安装证书，以实现中间人攻击；<br>某些情况下，通过此方法抓包，应用如果无法正常上网，说明应用可能并不信任操作系统的证书，而是自己有一套证书用于校验。</p>]]></content>
      
      
      <categories>
          
          <category> 网络分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络分析 </tag>
            
            <tag> Proxifier </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MFC】视图与文档</title>
      <link href="/posts/842e.html"/>
      <url>/posts/842e.html</url>
      
        <content type="html"><![CDATA[<h1 id="视图"><a class="markdownIt-Anchor" href="#视图">#</a> 视图</h1><h2 id="视图窗口简述"><a class="markdownIt-Anchor" href="#视图窗口简述">#</a> 视图窗口简述</h2><p>在 MFC 的设计中，图形的显示的这部分工作，交由 <code>视图窗口</code> 负责。<br>框架窗口则担容器之任，成为菜单、标题栏、视图窗口等窗口的容身之所，通常不直接在其客户区中绘制。</p><emp>视图窗口就被设计为一个没有标题栏，只有客户区的窗口，通常覆盖在框架窗口的客户区上。</emp><h2 id="cview"><a class="markdownIt-Anchor" href="#cview">#</a> CView</h2><p>在 MFC 中，视图窗口对应的类即 <code>CView</code> ，继承自 <code>CWnd</code> ；</p><h3 id="cviewondraw"><a class="markdownIt-Anchor" href="#cviewondraw">#</a> CView::OnDraw</h3><p><code>CView</code>  中声明了一个纯虚函数 <code>CView::OnDraw</code> ，因此继承必须重写这个函数，用于处理绘制消息；<br>这个函数是由 <code>CView::OnPanit</code>  调用的。</p><h2 id="使用视图窗口"><a class="markdownIt-Anchor" href="#使用视图窗口">#</a> 使用视图窗口</h2><details class="folding-tag" blue><summary> 代码示例 </summary>              <div class='content'>              <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;afxwin.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;afxext.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CMyView</span> : <span class="keyword">public</span> CView &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnDraw</span><span class="params">(CDC* pDC)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMyView::OnDraw</span><span class="params">(CDC* pDC)</span> </span>&#123;</span><br><span class="line">    pDC-&gt;<span class="built_in">TextOut</span>(<span class="number">100</span>, <span class="number">100</span>, <span class="string">L&quot;CMyView::OnDraw&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CMyFrameWnd</span> : <span class="keyword">public</span> CFrameWnd &#123;</span><br><span class="line">    <span class="built_in">DECLARE_MESSAGE_MAP</span>()</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">afx_msg <span class="type">int</span> AFX_MSG_CALL <span class="title">OnCreate</span><span class="params">(LPCREATESTRUCT)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">BEGIN_MESSAGE_MAP</span>(CMyFrameWnd, CFrameWnd)</span><br><span class="line">    <span class="built_in">ON_WM_CREATE</span>()</span><br><span class="line"><span class="built_in">END_MESSAGE_MAP</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> AFX_MSG_CALL <span class="title">CMyFrameWnd::OnCreate</span><span class="params">(LPCREATESTRUCT pCS)</span> </span>&#123;</span><br><span class="line">    CMyView* pView = <span class="keyword">new</span> CMyView;</span><br><span class="line">    pView-&gt;<span class="built_in">Create</span>(<span class="literal">nullptr</span>, <span class="string">L&quot;MFCView&quot;</span>, WS_CHILD | WS_VISIBLE | WS_BORDER,</span><br><span class="line">        CRect&#123;&#125;, <span class="keyword">this</span>, AFX_IDW_PANE_FIRST);     <span class="comment">// AFX_IDW_PANE_FIRST及以上的id创建出来的视图窗口，边框将与客户区重叠，不使用我们传递的CRect对象</span></span><br><span class="line">    m_pViewActive = pView;</span><br><span class="line">    <span class="keyword">return</span> CFrameWnd::<span class="built_in">OnCreate</span>(pCS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CMyWinApp</span> :<span class="keyword">public</span> CWinApp &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CMyWinApp</span>();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> BOOL <span class="title">InitInstance</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">CMyWinApp::<span class="built_in">CMyWinApp</span>() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">CMyWinApp::InitInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CMyFrameWnd* frame = <span class="keyword">new</span> CMyFrameWnd;</span><br><span class="line">    frame-&gt;<span class="built_in">Create</span>(<span class="literal">nullptr</span>, <span class="string">L&quot;MFCBase&quot;</span>);</span><br><span class="line">    m_pMainWnd = frame;</span><br><span class="line">    frame-&gt;<span class="built_in">ShowWindow</span>(SW_SHOW);</span><br><span class="line">    frame-&gt;<span class="built_in">UpdateWindow</span>();</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CMyWinApp g_theApp;</span><br></pre></td></tr></table></figure>              </div>            </details><p>老朋友了，相信读者阅读起来不会有什么困难，我们为框架窗口的客户区覆盖上了一个视图窗口。</p><hr><h1 id="文档"><a class="markdownIt-Anchor" href="#文档">#</a> 文档</h1><h2 id="文档简述"><a class="markdownIt-Anchor" href="#文档简述">#</a> 文档简述</h2><p>在 MFC 中，将数据的管理交给 <code>文档</code> 负责，再与负责显示数据的 <code>视图</code> 进行数据交互。</p><h2 id="cdocument"><a class="markdownIt-Anchor" href="#cdocument">#</a> CDocument</h2><p>MFC 提供的文档类。</p><p>一个文档可以同时与多个视图窗口交互</p><ul><li>内部维护了一个链表，连接所有与当前文档对象交互的视图对象。</li></ul><p>一个视图窗口只能与一个文档交互</p><ul><li>内部由一个成员变量指向交互的文档对象。</li></ul><h2 id="使用文档"><a class="markdownIt-Anchor" href="#使用文档">#</a> 使用文档</h2><details class="folding-tag" blue><summary> 代码示例 </summary>              <div class='content'>              <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;afxwin.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;afxext.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;resource.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CMyDoc</span> : <span class="keyword">public</span> CDocument &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CMyView</span> : <span class="keyword">public</span> CView &#123;</span><br><span class="line">    <span class="built_in">DECLARE_DYNCREATE</span>(CMyView);</span><br><span class="line">    <span class="built_in">DECLARE_MESSAGE_MAP</span>()</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> AFX_MSG_CALL <span class="title">OnCreate</span><span class="params">(LPCREATESTRUCT pCs)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnDraw</span><span class="params">(CDC* pDC)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">IMPLEMENT_DYNCREATE</span>(CMyView, CView);</span><br><span class="line"></span><br><span class="line"><span class="built_in">BEGIN_MESSAGE_MAP</span>(CMyView, CView)</span><br><span class="line">    <span class="built_in">ON_WM_CREATE</span>()</span><br><span class="line"><span class="built_in">END_MESSAGE_MAP</span>()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> AFX_MSG_CALL <span class="title">CMyView::OnCreate</span><span class="params">(LPCREATESTRUCT pCs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> CView::<span class="built_in">OnCreate</span>(pCs);        <span class="comment">// 在此函数内部，建立文档与当前视图的关联</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMyView::OnDraw</span><span class="params">(CDC* pDC)</span> </span>&#123;</span><br><span class="line">    pDC-&gt;<span class="built_in">TextOut</span>(<span class="number">100</span>, <span class="number">100</span>, <span class="string">L&quot;CMyView::OnDraw&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CMyFrameWnd</span> : <span class="keyword">public</span> CFrameWnd &#123;</span><br><span class="line">    <span class="built_in">DECLARE_MESSAGE_MAP</span>()</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">afx_msg <span class="type">int</span> AFX_MSG_CALL <span class="title">OnCreate</span><span class="params">(LPCREATESTRUCT)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">BEGIN_MESSAGE_MAP</span>(CMyFrameWnd, CFrameWnd)</span><br><span class="line">    <span class="built_in">ON_WM_CREATE</span>()</span><br><span class="line"><span class="built_in">END_MESSAGE_MAP</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> AFX_MSG_CALL <span class="title">CMyFrameWnd::OnCreate</span><span class="params">(LPCREATESTRUCT pCS)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> CFrameWnd::<span class="built_in">OnCreate</span>(pCS);        <span class="comment">// 在此函数内部，通过动态创建机制创建视图窗口，并挂接到框架窗口的主活动视图中。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CMyWinApp</span> :<span class="keyword">public</span> CWinApp &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CMyWinApp</span>();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> BOOL <span class="title">InitInstance</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">CMyWinApp::<span class="built_in">CMyWinApp</span>() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">CMyWinApp::InitInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CMyFrameWnd* frame = <span class="keyword">new</span> CMyFrameWnd;</span><br><span class="line">    CMyDoc* pDoc = <span class="keyword">new</span> CMyDoc;</span><br><span class="line"></span><br><span class="line">    CCreateContext createContext;</span><br><span class="line">    createContext.m_pCurrentDoc = pDoc;     <span class="comment">// 绑定文档类对象</span></span><br><span class="line">    createContext.m_pNewViewClass = <span class="built_in">RUNTIME_CLASS</span>(CMyView);     <span class="comment">// 绑定视图类的静态成员变量</span></span><br><span class="line"></span><br><span class="line">    frame-&gt;<span class="built_in">LoadFrame</span>(IDR_MENU_TOP, WS_OVERLAPPEDWINDOW, <span class="literal">nullptr</span>, &amp;createContext);       <span class="comment">// 创建框架窗口</span></span><br><span class="line"></span><br><span class="line">    m_pMainWnd = frame;</span><br><span class="line"></span><br><span class="line">    frame-&gt;<span class="built_in">ShowWindow</span>(SW_SHOW);</span><br><span class="line">    frame-&gt;<span class="built_in">UpdateWindow</span>();</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CMyWinApp g_theApp;</span><br></pre></td></tr></table></figure>              </div>            </details><p>这回，我们有了不少改动。</p><p>首先，我们先从应用的实例初始化开始看起：</p><details class="folding-tag" blue><summary> CMyWinApp::InitInstance </summary>              <div class='content'>              <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CMyWinApp::InitInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CMyFrameWnd* frame = <span class="keyword">new</span> CMyFrameWnd;</span><br><span class="line">    CMyDoc* pDoc = <span class="keyword">new</span> CMyDoc;</span><br><span class="line"></span><br><span class="line">    CCreateContext createContext;</span><br><span class="line">    createContext.m_pCurrentDoc = pDoc;     <span class="comment">// 绑定文档类对象</span></span><br><span class="line">    createContext.m_pNewViewClass = <span class="built_in">RUNTIME_CLASS</span>(CMyView);     <span class="comment">// 绑定视图类的静态成员变量</span></span><br><span class="line"></span><br><span class="line">    frame-&gt;<span class="built_in">LoadFrame</span>(IDR_MENU_TOP, WS_OVERLAPPEDWINDOW, <span class="literal">nullptr</span>, &amp;createContext);       <span class="comment">// 创建框架窗口</span></span><br><span class="line"></span><br><span class="line">    m_pMainWnd = frame;</span><br><span class="line"></span><br><span class="line">    frame-&gt;<span class="built_in">ShowWindow</span>(SW_SHOW);</span><br><span class="line">    frame-&gt;<span class="built_in">UpdateWindow</span>();</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><p>我们修改了 <code>CMyWinApp::InitInstance</code>  (及 <code>CMyView</code>  类)，通过 MFC 的 <code>动态创建机制</code> ，让 MFC 为我们创建视图窗口，并与主框架窗口建立关联。</p><blockquote><p>说实话，我觉得 MFC 整这么多种选择就很烦 = =，这个也要学哪个也要学，既然要封装不妨封装彻底一点。</p></blockquote><p>这里我们还建立了消息映射 <code>CMyFrameWnd::OnCreate</code> 、 <code>CMyView::OnCreate</code> ，但是并没有做别的事，只是调用了父类实现的消息映射；<br>实际上并不需要我们去建立消息映射然后调用父类的成员函数，这里是为了方便读者看得更明显。</p><hr><h1 id="多视图"><a class="markdownIt-Anchor" href="#多视图">#</a> 多视图</h1><p>在一个 <code>不规则框架窗口</code> 中，可以同时存在多个视图窗口。</p><p>我们需要在主框架窗口的客户区中，放置不规则框架窗口；<br>再在不规则框架窗口中放置多个视图窗口。</p><h2 id="csplitterwnd"><a class="markdownIt-Anchor" href="#csplitterwnd">#</a> CSplitterWnd</h2><p>拆分窗口类，即不规则框架窗口，<emp>其客户区可以放置多个视图窗口。</emp></p><h2 id="尝试多视图"><a class="markdownIt-Anchor" href="#尝试多视图">#</a> 尝试多视图</h2><details class="folding-tag" blue><summary> 代码示例 </summary>              <div class='content'>              <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;afxwin.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;afxext.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;resource.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CMyDoc</span> : <span class="keyword">public</span> CDocument &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CMyView</span> : <span class="keyword">public</span> CView &#123;</span><br><span class="line">    <span class="built_in">DECLARE_DYNCREATE</span>(CMyView);</span><br><span class="line">    <span class="built_in">DECLARE_MESSAGE_MAP</span>()</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> AFX_MSG_CALL <span class="title">OnCreate</span><span class="params">(LPCREATESTRUCT pCs)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnDraw</span><span class="params">(CDC* pDC)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">IMPLEMENT_DYNCREATE</span>(CMyView, CView);</span><br><span class="line"></span><br><span class="line"><span class="built_in">BEGIN_MESSAGE_MAP</span>(CMyView, CView)</span><br><span class="line">    <span class="built_in">ON_WM_CREATE</span>()</span><br><span class="line"><span class="built_in">END_MESSAGE_MAP</span>()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> AFX_MSG_CALL <span class="title">CMyView::OnCreate</span><span class="params">(LPCREATESTRUCT pCs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> CView::<span class="built_in">OnCreate</span>(pCs);        <span class="comment">// 在此函数内部，建立文档与当前视图的关联</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMyView::OnDraw</span><span class="params">(CDC* pDC)</span> </span>&#123;</span><br><span class="line">    pDC-&gt;<span class="built_in">TextOut</span>(<span class="number">100</span>, <span class="number">100</span>, <span class="string">L&quot;CMyView::OnDraw&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CMyFrameWnd</span> : <span class="keyword">public</span> CFrameWnd &#123;</span><br><span class="line">    <span class="built_in">DECLARE_MESSAGE_MAP</span>()</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">afx_msg <span class="type">int</span> AFX_MSG_CALL <span class="title">OnCreate</span><span class="params">(LPCREATESTRUCT)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> BOOL <span class="title">OnCreateClient</span><span class="params">(LPCREATESTRUCT pCs, CCreateContext* pContext)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    CSplitterWnd m_pSplitWnd;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">BEGIN_MESSAGE_MAP</span>(CMyFrameWnd, CFrameWnd)</span><br><span class="line">    <span class="built_in">ON_WM_CREATE</span>()</span><br><span class="line"><span class="built_in">END_MESSAGE_MAP</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> AFX_MSG_CALL <span class="title">CMyFrameWnd::OnCreate</span><span class="params">(LPCREATESTRUCT pCS)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> CFrameWnd::<span class="built_in">OnCreate</span>(pCS);        <span class="comment">// 在此函数内部，通过动态创建机制创建视图窗口</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重写框架窗口创建客户区时调用的成员函数</span></span><br><span class="line"><span class="function">BOOL <span class="title">CMyFrameWnd::OnCreateClient</span><span class="params">(LPCREATESTRUCT pCs, CCreateContext* pContext)</span> </span>&#123;</span><br><span class="line">    m_pSplitWnd.<span class="built_in">CreateStatic</span>(<span class="keyword">this</span>, <span class="number">1</span>, <span class="number">2</span>);       <span class="comment">// 创建布局</span></span><br><span class="line">    m_pSplitWnd.<span class="built_in">CreateView</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="built_in">RUNTIME_CLASS</span>(CMyView), <span class="built_in">CSize</span>(<span class="number">500</span>,<span class="number">500</span>), pContext);</span><br><span class="line">    m_pSplitWnd.<span class="built_in">CreateView</span>(<span class="number">0</span>, <span class="number">1</span>, pContext-&gt;m_pNewViewClass, <span class="built_in">CSize</span>(<span class="number">500</span>, <span class="number">500</span>), pContext);</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CMyWinApp</span> :<span class="keyword">public</span> CWinApp &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CMyWinApp</span>();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> BOOL <span class="title">InitInstance</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">CMyWinApp::<span class="built_in">CMyWinApp</span>() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">CMyWinApp::InitInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CMyFrameWnd* frame = <span class="keyword">new</span> CMyFrameWnd;</span><br><span class="line">    CMyDoc* pDoc = <span class="keyword">new</span> CMyDoc;</span><br><span class="line"></span><br><span class="line">    CCreateContext createContext;</span><br><span class="line">    createContext.m_pCurrentDoc = pDoc;     <span class="comment">// 绑定文档类对象</span></span><br><span class="line">    createContext.m_pNewViewClass = <span class="built_in">RUNTIME_CLASS</span>(CMyView);     <span class="comment">// 绑定视图类的静态成员变量</span></span><br><span class="line"></span><br><span class="line">    frame-&gt;<span class="built_in">LoadFrame</span>(IDR_MENU_TOP, WS_OVERLAPPEDWINDOW, <span class="literal">nullptr</span>, &amp;createContext);       <span class="comment">// 创建框架窗口</span></span><br><span class="line"></span><br><span class="line">    m_pMainWnd = frame;</span><br><span class="line"></span><br><span class="line">    frame-&gt;<span class="built_in">ShowWindow</span>(SW_SHOW);</span><br><span class="line">    frame-&gt;<span class="built_in">UpdateWindow</span>();</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CMyWinApp g_theApp;</span><br></pre></td></tr></table></figure>              </div>            </details>]]></content>
      
      
      <categories>
          
          <category> MFC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MFC </tag>
            
            <tag> 没饭吃 </tag>
            
            <tag> C++ </tag>
            
            <tag> 界面开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MFC】探索运行时类信息机制的实现原理</title>
      <link href="/posts/603c.html"/>
      <url>/posts/603c.html</url>
      
        <content type="html"><![CDATA[<p>空的哦</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【MFC】工具栏</title>
      <link href="/posts/6ee.html"/>
      <url>/posts/6ee.html</url>
      
        <content type="html"><![CDATA[<h1 id="工具栏简述"><a class="markdownIt-Anchor" href="#工具栏简述">#</a> 工具栏简述</h1><p>Windows 下的工具栏通常是指放置工具的容器。<br>通常我们能在一些软件的菜单栏下见到，各类样式的图形按钮，被框在一栏中，这便是工具栏。</p><h1 id="添加工具栏资源"><a class="markdownIt-Anchor" href="#添加工具栏资源">#</a> 添加工具栏资源</h1><ol><li>右键 <code>项目</code> ， <code>添加</code>  -&gt;  <code>资源</code></li><li>选择 <code>Toolbar</code> ，点击 <code>新建</code> ，进入资源编辑界面。</li><li>自行折腾编辑界面，随便画几个图案，这就是你工具栏里面的工具按钮</li><li>设置资源 ID，这里我将工具栏 ID 设置为 <code>IDR_TOOLBAR_1</code> ，工具按钮的 ID 依次为 <code>ID_TOOLBAR_BUTTOR_1</code> 、 <code>ID_TOOLBAR_BUTTOR_2</code> 、 <code>ID_TOOLBAR_BUTTOR_3</code> 。</li></ol><p>资源编辑界面示范：</p><ul><li><img src="/posts/6ee/1.png" class="" title="这是一张图片"></li></ul><h1 id="使用工具栏"><a class="markdownIt-Anchor" href="#使用工具栏">#</a> 使用工具栏</h1><p>工具栏的使用与菜单类似，只需要映射 <code>WM_COMMAND</code>  消息即可。</p><details class="folding-tag" blue><summary> 代码示例 </summary>              <div class='content'>              <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;afxwin.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;afxext.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;resource.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CMyFrameWnd</span> :<span class="keyword">public</span> CFrameWnd &#123;</span><br><span class="line">    <span class="built_in">DECLARE_MESSAGE_MAP</span>()</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">afx_msg <span class="type">int</span> <span class="title">OnCreate</span><span class="params">(LPCREATESTRUCT pCs)</span></span>;</span><br><span class="line">    <span class="function">afx_msg <span class="type">void</span> <span class="title">OnClose</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">afx_msg <span class="type">void</span> <span class="title">OnMenu_File_New</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">afx_msg <span class="type">void</span> <span class="title">OnContextMenu</span><span class="params">(CWnd* wnd, CPoint pos)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">afx_msg <span class="type">void</span> <span class="title">OnToolBar_1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">afx_msg <span class="type">void</span> <span class="title">OnToolBar_2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">afx_msg <span class="type">void</span> <span class="title">OnToolBar_3</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    CMenu* m_pMenu;</span><br><span class="line">    CToolBar* m_pToolBar;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">BEGIN_MESSAGE_MAP</span>(CMyFrameWnd, CFrameWnd)</span><br><span class="line">    <span class="built_in">ON_WM_CREATE</span>()</span><br><span class="line">    <span class="built_in">ON_WM_CLOSE</span>()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ON_COMMAND</span>(ID_MENU_FILE_NEW, OnMenu_File_New)</span><br><span class="line">    <span class="built_in">ON_WM_CONTEXTMENU</span>()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ON_COMMAND</span>(ID_TOOLBAR_BUTTON_1, OnToolBar_1)</span><br><span class="line">    <span class="built_in">ON_COMMAND</span>(ID_TOOLBAR_BUTTON_2, OnToolBar_2)</span><br><span class="line">    <span class="built_in">ON_COMMAND</span>(ID_TOOLBAR_BUTTON_3, OnToolBar_3)</span><br><span class="line"><span class="built_in">END_MESSAGE_MAP</span>()</span><br><span class="line"></span><br><span class="line"><span class="function">afx_msg <span class="type">int</span> <span class="title">CMyFrameWnd::OnCreate</span><span class="params">(LPCREATESTRUCT pCs)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Menu</span></span><br><span class="line">    m_pMenu = <span class="keyword">new</span> CMenu;</span><br><span class="line">    m_pMenu-&gt;<span class="built_in">LoadMenu</span>(IDR_MENU_TOP);</span><br><span class="line">    <span class="built_in">SetMenu</span>(m_pMenu);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ToolBar</span></span><br><span class="line">    m_pToolBar = <span class="keyword">new</span> CToolBar;</span><br><span class="line">    m_pToolBar-&gt;<span class="built_in">CreateEx</span>(<span class="keyword">this</span>, TBSTYLE_FLAT, WS_CHILD | WS_VISIBLE | CBRS_ALIGN_TOP);</span><br><span class="line">    m_pToolBar-&gt;<span class="built_in">LoadToolBar</span>(IDR_TOOLBAR_1);</span><br><span class="line">    <span class="keyword">return</span> CFrameWnd::<span class="built_in">OnCreate</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">afx_msg <span class="type">void</span> <span class="title">CMyFrameWnd::OnClose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_pMenu) &#123;</span><br><span class="line">        <span class="keyword">delete</span> m_pMenu;</span><br><span class="line">        m_pMenu = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m_pToolBar) &#123;</span><br><span class="line">        <span class="keyword">delete</span> m_pToolBar;</span><br><span class="line">        m_pToolBar = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    CFrameWnd::<span class="built_in">OnClose</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMyFrameWnd::OnContextMenu</span><span class="params">(CWnd* wnd, CPoint pos)</span> </span>&#123;</span><br><span class="line">    CMenu* pNewMenu = m_pMenu-&gt;<span class="built_in">GetSubMenu</span>(<span class="number">0</span>);</span><br><span class="line">    pNewMenu-&gt;<span class="built_in">TrackPopupMenu</span>(TPM_LEFTALIGN | TPM_TOPALIGN, pos.x, pos.y, wnd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">afx_msg <span class="type">void</span> <span class="title">CMyFrameWnd::OnMenu_File_New</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">AfxMessageBox</span>(<span class="string">L&quot;new&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">afx_msg <span class="type">void</span> <span class="title">CMyFrameWnd::OnToolBar_1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">AfxMessageBox</span>(<span class="string">L&quot;button 1&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">afx_msg <span class="type">void</span> <span class="title">CMyFrameWnd::OnToolBar_2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">AfxMessageBox</span>(<span class="string">L&quot;button 2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">afx_msg <span class="type">void</span> <span class="title">CMyFrameWnd::OnToolBar_3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">AfxMessageBox</span>(<span class="string">L&quot;button 3&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CMyWinApp</span> :<span class="keyword">public</span> CWinApp &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CMyWinApp</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> BOOL <span class="title">InitInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CMyFrameWnd* frame = <span class="keyword">new</span> CMyFrameWnd;</span><br><span class="line">        frame-&gt;<span class="built_in">Create</span>(<span class="literal">nullptr</span>, <span class="string">L&quot;MFCBase&quot;</span>);</span><br><span class="line">        m_pMainWnd = frame;</span><br><span class="line">        frame-&gt;<span class="built_in">ShowWindow</span>(SW_SHOW);</span><br><span class="line">        frame-&gt;<span class="built_in">UpdateWindow</span>();</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">CMyWinApp g_theApp;</span><br></pre></td></tr></table></figure>              </div>            </details><p>代码并不复杂，在上一节代码的基础上进行了如下部分修改：</p><ol><li>引入头文件 <code>afxext.h</code></li><li><code>CMyFrameWnd</code>  类添加私有成员 <code>m_pToolBar</code></li><li>在 <code>CMyFrameWnd::OnCreate</code>  函数中使 <code>m_pToolBar</code>  指向新创建的对象，并进行工具栏的加载</li><li>处理 <code>WM_COMMAND</code>  消息的映射</li></ol><h1 id="工具栏把手"><a class="markdownIt-Anchor" href="#工具栏把手">#</a> 工具栏把手</h1><p>工具栏不仅仅只能固定在菜单栏下方，它是可以拖动，漂浮的。<br>而工具栏的把手，就是工具栏中，被允许被鼠标拖拽的控制区域。</p><h2 id="cbrs_gripper"><a class="markdownIt-Anchor" href="#cbrs_gripper">#</a> CBRS_GRIPPER</h2><p>需要为工具栏添加把手时，需要在 <code>CToolBar::CreateEx</code>  函数中添加 <code>CBRS_GRIPPER</code>  样式。</p><h2 id="ctoolbarenabledocking"><a class="markdownIt-Anchor" href="#ctoolbarenabledocking">#</a> CToolBar::EnableDocking</h2><p>用于指定工具栏可以停放到窗口中的何处</p><h2 id="cframewndenabledocking"><a class="markdownIt-Anchor" href="#cframewndenabledocking">#</a> CFrameWnd::EnableDocking</h2><p>用于指定框架窗口允许被工具栏停放的位置</p><h2 id="cframewnddockcontrolbar"><a class="markdownIt-Anchor" href="#cframewnddockcontrolbar">#</a> CFrameWnd::DockControlBar</h2><p>设置工具栏当前停放的位置</p><h2 id="允许任意停放的工具栏"><a class="markdownIt-Anchor" href="#允许任意停放的工具栏">#</a> 允许任意停放的工具栏</h2><details class="folding-tag" blue><summary> 代码示例 </summary>              <div class='content'>              <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;afxwin.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;afxext.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;resource.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CMyFrameWnd</span> :<span class="keyword">public</span> CFrameWnd &#123;</span><br><span class="line">    <span class="built_in">DECLARE_MESSAGE_MAP</span>()</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">afx_msg <span class="type">int</span> <span class="title">OnCreate</span><span class="params">(LPCREATESTRUCT pCs)</span></span>;</span><br><span class="line">    <span class="function">afx_msg <span class="type">void</span> <span class="title">OnClose</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">afx_msg <span class="type">void</span> <span class="title">OnMenu_File_New</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">afx_msg <span class="type">void</span> <span class="title">OnContextMenu</span><span class="params">(CWnd* wnd, CPoint pos)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">afx_msg <span class="type">void</span> <span class="title">OnToolBar_1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">afx_msg <span class="type">void</span> <span class="title">OnToolBar_2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">afx_msg <span class="type">void</span> <span class="title">OnToolBar_3</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    CMenu* m_pMenu;</span><br><span class="line">    CToolBar* m_pToolBar;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">BEGIN_MESSAGE_MAP</span>(CMyFrameWnd, CFrameWnd)</span><br><span class="line">    <span class="built_in">ON_WM_CREATE</span>()</span><br><span class="line">    <span class="built_in">ON_WM_CLOSE</span>()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ON_COMMAND</span>(ID_MENU_FILE_NEW, OnMenu_File_New)</span><br><span class="line">    <span class="built_in">ON_WM_CONTEXTMENU</span>()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ON_COMMAND</span>(ID_TOOLBAR_BUTTON_1, OnToolBar_1)</span><br><span class="line">    <span class="built_in">ON_COMMAND</span>(ID_TOOLBAR_BUTTON_2, OnToolBar_2)</span><br><span class="line">    <span class="built_in">ON_COMMAND</span>(ID_TOOLBAR_BUTTON_3, OnToolBar_3)</span><br><span class="line"><span class="built_in">END_MESSAGE_MAP</span>()</span><br><span class="line"></span><br><span class="line"><span class="function">afx_msg <span class="type">int</span> <span class="title">CMyFrameWnd::OnCreate</span><span class="params">(LPCREATESTRUCT pCs)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Menu</span></span><br><span class="line">    m_pMenu = <span class="keyword">new</span> CMenu;</span><br><span class="line">    m_pMenu-&gt;<span class="built_in">LoadMenu</span>(IDR_MENU_TOP);</span><br><span class="line">    <span class="built_in">SetMenu</span>(m_pMenu);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ToolBar</span></span><br><span class="line">    m_pToolBar = <span class="keyword">new</span> CToolBar;</span><br><span class="line">    m_pToolBar-&gt;<span class="built_in">CreateEx</span>(<span class="keyword">this</span>, TBSTYLE_FLAT, WS_CHILD | WS_VISIBLE | CBRS_ALIGN_TOP | CBRS_GRIPPER);</span><br><span class="line">    m_pToolBar-&gt;<span class="built_in">LoadToolBar</span>(IDR_TOOLBAR_1);</span><br><span class="line">    m_pToolBar-&gt;<span class="built_in">EnableDocking</span>(CBRS_ALIGN_ANY);</span><br><span class="line">    <span class="built_in">EnableDocking</span>(CBRS_ALIGN_ANY);</span><br><span class="line">    <span class="built_in">DockControlBar</span>(m_pToolBar);</span><br><span class="line">    <span class="keyword">return</span> CFrameWnd::<span class="built_in">OnCreate</span>(pCs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">afx_msg <span class="type">void</span> <span class="title">CMyFrameWnd::OnClose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_pMenu) &#123;</span><br><span class="line">        <span class="keyword">delete</span> m_pMenu;</span><br><span class="line">        m_pMenu = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m_pToolBar) &#123;</span><br><span class="line">        <span class="keyword">delete</span> m_pToolBar;</span><br><span class="line">        m_pToolBar = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    CFrameWnd::<span class="built_in">OnClose</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMyFrameWnd::OnContextMenu</span><span class="params">(CWnd* wnd, CPoint pos)</span> </span>&#123;</span><br><span class="line">    CMenu* pNewMenu = m_pMenu-&gt;<span class="built_in">GetSubMenu</span>(<span class="number">0</span>);</span><br><span class="line">    pNewMenu-&gt;<span class="built_in">TrackPopupMenu</span>(TPM_LEFTALIGN | TPM_TOPALIGN, pos.x, pos.y, wnd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">afx_msg <span class="type">void</span> <span class="title">CMyFrameWnd::OnMenu_File_New</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">AfxMessageBox</span>(<span class="string">L&quot;new&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">afx_msg <span class="type">void</span> <span class="title">CMyFrameWnd::OnToolBar_1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">AfxMessageBox</span>(<span class="string">L&quot;button 1&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">afx_msg <span class="type">void</span> <span class="title">CMyFrameWnd::OnToolBar_2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">AfxMessageBox</span>(<span class="string">L&quot;button 2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">afx_msg <span class="type">void</span> <span class="title">CMyFrameWnd::OnToolBar_3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">AfxMessageBox</span>(<span class="string">L&quot;button 3&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CMyWinApp</span> :<span class="keyword">public</span> CWinApp &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CMyWinApp</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> BOOL <span class="title">InitInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CMyFrameWnd* frame = <span class="keyword">new</span> CMyFrameWnd;</span><br><span class="line">        frame-&gt;<span class="built_in">Create</span>(<span class="literal">nullptr</span>, <span class="string">L&quot;MFCBase&quot;</span>);</span><br><span class="line">        m_pMainWnd = frame;</span><br><span class="line">        frame-&gt;<span class="built_in">ShowWindow</span>(SW_SHOW);</span><br><span class="line">        frame-&gt;<span class="built_in">UpdateWindow</span>();</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">CMyWinApp g_theApp;</span><br></pre></td></tr></table></figure>              </div>            </details><p>代码并不复杂，就留给读者自行调试了。</p>]]></content>
      
      
      <categories>
          
          <category> MFC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MFC </tag>
            
            <tag> 没饭吃 </tag>
            
            <tag> C++ </tag>
            
            <tag> 界面开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MFC】菜单</title>
      <link href="/posts/d43b.html"/>
      <url>/posts/d43b.html</url>
      
        <content type="html"><![CDATA[<h1 id="菜单简述"><a class="markdownIt-Anchor" href="#菜单简述">#</a> 菜单简述</h1><p>Windows 的菜单分为两类：</p><ul><li>窗口菜单</li><li>弹出式菜单</li></ul><p>窗口菜单是挂接到窗口上的；<br>弹出式菜单是根据程序设计者的需要在某处弹出的。</p><h1 id="添加菜单资源"><a class="markdownIt-Anchor" href="#添加菜单资源">#</a> 添加菜单资源</h1><ol><li>右键 <code>项目</code> ， <code>添加</code>  -&gt;  <code>资源</code></li><li>选择 <code>Menu</code> ，点击 <code>新建</code> ，进入资源编辑界面。</li><li>顶层菜单 (类型为窗口菜单) 添加一个项 <code>新建</code> 、顶层的子菜单 (类型为弹出式菜单) 添加一个项 <code>文件</code></li><li>修改顶层菜单的资源为 <code>IDR_MENU_TOP</code></li><li>修改顶层菜单的 <code>新建</code> 项的子菜单的 <code>文件</code> 项的资源为 <code>ID_MENU_FILE_NEW</code> 。</li></ol><blockquote><p>注：此处附注的菜单类型并不需要你在编辑时设置，是指明该菜单属于什么类型。<br>顶层菜单的类型就是 <code>窗口菜单</code> <br>顶层菜单的子菜单的类型就是 <code>弹出式菜单</code></p></blockquote><p>资源编辑界面示范：</p><ul><li><img src="/posts/d43b/1.png" class="" title="这是一张图片"></li></ul><h1 id="使用窗口菜单"><a class="markdownIt-Anchor" href="#使用窗口菜单">#</a> 使用窗口菜单</h1><details class="folding-tag" blue><summary> 代码示例 </summary>              <div class='content'>              <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;afxwin.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;resource.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CMyFrameWnd</span> :<span class="keyword">public</span> CFrameWnd &#123;</span><br><span class="line">    <span class="built_in">DECLARE_MESSAGE_MAP</span>()</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">afx_msg <span class="type">int</span> <span class="title">OnCreate</span><span class="params">(LPCREATESTRUCT pCs)</span></span>;</span><br><span class="line">    <span class="function">afx_msg <span class="type">void</span> <span class="title">OnClose</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">afx_msg <span class="type">void</span> <span class="title">OnMenu_File_New</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    CMenu* m_pMenu;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">BEGIN_MESSAGE_MAP</span>(CMyFrameWnd, CFrameWnd)</span><br><span class="line">    <span class="built_in">ON_WM_CREATE</span>()</span><br><span class="line">    <span class="built_in">ON_WM_CLOSE</span>()</span><br><span class="line">    <span class="built_in">ON_COMMAND</span>(ID_MENU_FILE_NEW, OnMenu_File_New)</span><br><span class="line"><span class="built_in">END_MESSAGE_MAP</span>()</span><br><span class="line"></span><br><span class="line"><span class="function">afx_msg <span class="type">int</span> <span class="title">CMyFrameWnd::OnCreate</span><span class="params">(LPCREATESTRUCT pCs)</span> </span>&#123;</span><br><span class="line">    m_pMenu = <span class="keyword">new</span> CMenu;</span><br><span class="line">    m_pMenu-&gt;<span class="built_in">LoadMenu</span>(IDR_MENU_TOP);</span><br><span class="line">    <span class="built_in">SetMenu</span>(m_pMenu);</span><br><span class="line">    <span class="keyword">return</span> CFrameWnd::<span class="built_in">OnCreate</span>(pCs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">afx_msg <span class="type">void</span> <span class="title">CMyFrameWnd::OnClose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_pMenu) &#123;</span><br><span class="line">        <span class="keyword">delete</span> m_pMenu;</span><br><span class="line">        m_pMenu = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    CFrameWnd::<span class="built_in">OnClose</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">afx_msg <span class="type">void</span> <span class="title">CMyFrameWnd::OnMenu_File_New</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">AfxMessageBox</span>(<span class="string">L&quot;new&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CMyWinApp</span> :<span class="keyword">public</span> CWinApp &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CMyWinApp</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> BOOL <span class="title">InitInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CMyFrameWnd* frame = <span class="keyword">new</span> CMyFrameWnd;</span><br><span class="line">        frame-&gt;<span class="built_in">Create</span>(<span class="literal">nullptr</span>, <span class="string">L&quot;MFCBase&quot;</span>);</span><br><span class="line">        m_pMainWnd = frame;</span><br><span class="line">        frame-&gt;<span class="built_in">ShowWindow</span>(SW_SHOW);</span><br><span class="line">        frame-&gt;<span class="built_in">UpdateWindow</span>();</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">CMyWinApp g_theApp;</span><br></pre></td></tr></table></figure>              </div>            </details><p>代码想必读者也比较熟悉了，有一些需要注意的改动如下：</p><ol><li><code>CMyFrameWnd</code>  添加私有成员 <code>CMenu* m_pMenu</code> ；</li><li>添加了一个新的消息映射条目 <code>ON_COMMAND(ID_MENU_FILE_NEW, OnMenu_File_New)</code> ；</li><li>为消息映射函数添加了宏 <code>afx_msg</code> ；<ul><li>并无特殊作用，仅为提高代码可读性。</li></ul></li></ol><h2 id="挂接窗口菜单"><a class="markdownIt-Anchor" href="#挂接窗口菜单">#</a> 挂接窗口菜单</h2><div class="note warning no-icon flat"><p><code>CMyFrameWnd::OnCreate</code></p></div><p>首先，代码中 <code>new</code>  了一个 <code>CMenu</code>  类对象，使我们添加的私有成员指向它，这是 MFC 封装的菜单类。<br>其次，调用了 <code>CMenu::LoadMenu</code> ，用于加载我们添加的菜单资源。<br>最后，以当前 <code>CMyFrameWnd</code>  类对象的身份，调用了 <code>CFrameWnd::SetMenu</code>  成员函数。</p><p>至此，我们完成了将窗口菜单挂接到 <code>CMyFrameWnd</code>  类对象上的工作。</p><h2 id="处理菜单项回调事件"><a class="markdownIt-Anchor" href="#处理菜单项回调事件">#</a> 处理菜单项回调事件</h2><div class="note warning no-icon flat"><p><code>ON_COMMAND(ID_MENU_FILE_NEW, OnMenu_File_New)</code> <br> <code>CMyFrameWnd::OnMenu_File_New</code></p></div><p>只需要通过 <code>ON_COMMAND</code>  宏，就可以建立指定菜单资源被点击 ( <code>WM_COMMAND</code>  消息) 与回调函数的映射。</p><h2 id="wm_command"><a class="markdownIt-Anchor" href="#wm_command">#</a> WM_COMMAND</h2><p>命令消息，在菜单被点击等事件发生时产生。</p><p>在 MFC 的消息处理架构中， <code>WM_COMMAND</code>  的处理流程与我们先前接触的 <code>WM_CREATE</code>  等消息是不同的。<br>我们回到 <code>CWnd::OnWndMsg</code>  函数，在函数开始部分就能看到相关源码。</p><details class="folding-tag" blue><summary> 代码示例 </summary>              <div class='content'>              <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CWnd::OnWndMsg</span><span class="params">(UINT message, WPARAM wParam, LPARAM lParam, LRESULT* pResult)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LRESULT lResult = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">union</span> <span class="title class_">MessageMapFunctions</span> mmf;</span><br><span class="line">mmf.pfn = <span class="number">0</span>;</span><br><span class="line">CInternalGlobalLock winMsgLock;</span><br><span class="line"><span class="comment">// special case for commands</span></span><br><span class="line"><span class="keyword">if</span> (message == WM_COMMAND)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">OnCommand</span>(wParam, lParam))</span><br><span class="line">&#123;</span><br><span class="line">lResult = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">goto</span> LReturnTrue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>              </div>            </details><p>只要是 <code>WM_COMMAND</code>  消息，会调用 <code>CWnd::OnCommand</code> ，返回后就再次返回了。</p><p>最终会走到全局静态函数 <code>_AfxDispatchCmdMsg</code>  中回调 <code>CMyFrameWnd::OnMenu_File_New</code> 。</p><p>由于代码较为繁琐，故不再向下深入，读者感兴趣可以自行调试。</p><h1 id="使用弹出式菜单"><a class="markdownIt-Anchor" href="#使用弹出式菜单">#</a> 使用弹出式菜单</h1><h2 id="wm_contextmenu"><a class="markdownIt-Anchor" href="#wm_contextmenu">#</a> WM_CONTEXTMENU</h2><p><code>DefWindowProc</code>  在处理 <code>WM_RBUTTONUP</code>  或 <code>WM_NCRBUTTONUP</code>  消息，或是用户键入 <code>SHIFT+F10</code>  时，生成 <code>WM_CONTEXTMENU</code>  消息。</p><h2 id="实现右键客户区弹出菜单"><a class="markdownIt-Anchor" href="#实现右键客户区弹出菜单">#</a> 实现右键客户区弹出菜单</h2><p>我们知道，在菜单编辑界面中，顶层菜单的子菜单都是独立的弹出式菜单；</p><ul><li>故这些子菜单都是可以被单独弹出的</li><li>而顶层菜单项被点击时弹出子菜单不需要我们处理，是因为 windows 替我们做好了相关的工作。</li></ul><p>接下来我们通过映射 <code>WM_CONTEXTMENU</code>  消息，实现在客户区右键，弹出顶层菜单 <code>文件</code> 的子菜单。</p><details class="folding-tag" blue><summary> 代码示例 </summary>              <div class='content'>              <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;afxwin.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;resource.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CMyFrameWnd</span> :<span class="keyword">public</span> CFrameWnd &#123;</span><br><span class="line">    <span class="built_in">DECLARE_MESSAGE_MAP</span>()</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">afx_msg <span class="type">int</span> <span class="title">OnCreate</span><span class="params">(LPCREATESTRUCT pCs)</span></span>;</span><br><span class="line">    <span class="function">afx_msg <span class="type">void</span> <span class="title">OnClose</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">afx_msg <span class="type">void</span> <span class="title">OnMenu_File_New</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">afx_msg <span class="type">void</span> <span class="title">OnContextMenu</span><span class="params">(CWnd* wnd, CPoint pos)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    CMenu* m_pMenu;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">BEGIN_MESSAGE_MAP</span>(CMyFrameWnd, CFrameWnd)</span><br><span class="line">    <span class="built_in">ON_WM_CREATE</span>()</span><br><span class="line">    <span class="built_in">ON_WM_CLOSE</span>()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ON_COMMAND</span>(ID_MENU_FILE_NEW, OnMenu_File_New)</span><br><span class="line">    <span class="built_in">ON_WM_CONTEXTMENU</span>()</span><br><span class="line"><span class="built_in">END_MESSAGE_MAP</span>()</span><br><span class="line"></span><br><span class="line"><span class="function">afx_msg <span class="type">int</span> <span class="title">CMyFrameWnd::OnCreate</span><span class="params">(LPCREATESTRUCT pCs)</span> </span>&#123;</span><br><span class="line">    m_pMenu = <span class="keyword">new</span> CMenu;</span><br><span class="line">    m_pMenu-&gt;<span class="built_in">LoadMenu</span>(IDR_MENU_TOP);</span><br><span class="line">    <span class="built_in">SetMenu</span>(m_pMenu);</span><br><span class="line">    <span class="keyword">return</span> CFrameWnd::<span class="built_in">OnCreate</span>(pCs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">afx_msg <span class="type">void</span> <span class="title">CMyFrameWnd::OnClose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_pMenu) &#123;</span><br><span class="line">        <span class="keyword">delete</span> m_pMenu;</span><br><span class="line">        m_pMenu = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    CFrameWnd::<span class="built_in">OnClose</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMyFrameWnd::OnContextMenu</span><span class="params">(CWnd* wnd, CPoint pos)</span> </span>&#123;</span><br><span class="line">    CMenu* pNewMenu = m_pMenu-&gt;<span class="built_in">GetSubMenu</span>(<span class="number">0</span>);</span><br><span class="line">    pNewMenu-&gt;<span class="built_in">TrackPopupMenu</span>(TPM_LEFTALIGN | TPM_TOPALIGN, pos.x, pos.y, wnd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">afx_msg <span class="type">void</span> <span class="title">CMyFrameWnd::OnMenu_File_New</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">AfxMessageBox</span>(<span class="string">L&quot;new&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CMyWinApp</span> :<span class="keyword">public</span> CWinApp &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CMyWinApp</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> BOOL <span class="title">InitInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CMyFrameWnd* frame = <span class="keyword">new</span> CMyFrameWnd;</span><br><span class="line">        frame-&gt;<span class="built_in">Create</span>(<span class="literal">nullptr</span>, <span class="string">L&quot;MFCBase&quot;</span>);</span><br><span class="line">        m_pMainWnd = frame;</span><br><span class="line">        frame-&gt;<span class="built_in">ShowWindow</span>(SW_SHOW);</span><br><span class="line">        frame-&gt;<span class="built_in">UpdateWindow</span>();</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">CMyWinApp g_theApp;</span><br></pre></td></tr></table></figure>              </div>            </details><p>代码并不复杂，建议读者自行尝试调试运行。</p><blockquote><p>参考资料：<br><a href="https://www.cnblogs.com/hanford/p/6163690.html">https://www.cnblogs.com/hanford/p/6163690.html</a><br><a href="https://www.cnblogs.com/greenleaf1976/p/16460330.html">https://www.cnblogs.com/greenleaf1976/p/16460330.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> MFC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MFC </tag>
            
            <tag> 没饭吃 </tag>
            
            <tag> C++ </tag>
            
            <tag> 界面开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【C/C++逆向】数据类型的表现形式</title>
      <link href="/posts/51b.html"/>
      <url>/posts/51b.html</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="咱也不知道发生了啥" data-whm="咱也不知道发生了啥">  <script id="hbeData" type="hbeData" data-hmacdigest="dfea2844e4baf3c8dcd5a0ea14f21045fd66d72652f94d8b7b034e0193d5ff28">db3f4eb17c2318c256622b6960219afda507dbc0f727563f20c8a378137edd144480af96f63ef9ac5ad29fe678f7a1b1</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">或许，需要什么魔法咒语？</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> C/C++逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 逆向分析 </tag>
            
            <tag> C/C++ </tag>
            
            <tag> 反汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【C/C++逆向】前言</title>
      <link href="/posts/3fe5.html"/>
      <url>/posts/3fe5.html</url>
      
        <content type="html"><![CDATA[<p>当前分类所收录的文章主要是我个人学习 C/C++ 逆向时记录的读书笔记。</p><blockquote><p>主要参考资料<br>《C++ 反汇编与逆向分析技术揭秘 (第 2 版)》. 钱林松、张延清</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> C/C++逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 逆向分析 </tag>
            
            <tag> C/C++ </tag>
            
            <tag> 反汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【逆向工具】常用工具推荐</title>
      <link href="/posts/3f7e.html"/>
      <url>/posts/3f7e.html</url>
      
        <content type="html"><![CDATA[<p><em><strong>工欲善其事，必先利其器。</strong></em></p><blockquote><p>这里收录了一些我个人常用并推荐的工具。</p></blockquote><h1 id="动态分析"><a class="markdownIt-Anchor" href="#动态分析">#</a> 动态分析</h1><h2 id="软件调试"><a class="markdownIt-Anchor" href="#软件调试">#</a> 软件调试</h2><h3 id="x64dbg"><a class="markdownIt-Anchor" href="#x64dbg">#</a> x64dbg</h3><p><strong>面向未来的 Windows R3 调试器，开源，支持 x86/x64。</strong></p><ul><li><p>官方网站</p><ul><li><a href="https://x64dbg.com/">https://x64dbg.com/</a></li></ul></li><li><p>推荐插件</p><ul><li>ret-sync</li><li>SharpOD</li></ul></li></ul><h3 id="windbg"><a class="markdownIt-Anchor" href="#windbg">#</a> WinDbg</h3><p><strong>微软家的东西，不仅能够调试应用，还能调试内核，学习内核必备的工具。</strong></p><ul><li>推荐辅助工具<ul><li>VirtualKD-Redux</li></ul></li></ul><hr><h2 id="内存搜索"><a class="markdownIt-Anchor" href="#内存搜索">#</a> 内存搜索</h2><h3 id="cheat-engine"><a class="markdownIt-Anchor" href="#cheat-engine">#</a> Cheat Engine</h3><p><strong>大名鼎鼎的 CE，开源的内存修改工具，但不仅仅只能用于修改内存，其中依赖于调试机制的 &quot;找出是什么访问 / 修改了这个地址&quot; 等功能也非常好用。</strong></p><ul><li>官方网站<ul><li><a href="https://www.cheatengine.org/">https://www.cheatengine.org/</a></li></ul></li></ul><hr><h2 id="进程监控"><a class="markdownIt-Anchor" href="#进程监控">#</a> 进程监控</h2><h3 id="process-monitor"><a class="markdownIt-Anchor" href="#process-monitor">#</a> Process Monitor</h3><p><strong>用于 Windows 的高级监控工具，能够实时监控进程的行为，如文件、注册表、网络等动作，对分析工作有很大的帮助。</strong></p><ul><li>下载地址<ul><li><a href="https://learn.microsoft.com/en-us/sysinternals/downloads/procmon">https://learn.microsoft.com/en-us/sysinternals/downloads/procmon</a></li></ul></li></ul><h3 id="火绒剑"><a class="markdownIt-Anchor" href="#火绒剑">#</a> 火绒剑</h3><p><strong>火绒剑的系统监控也意外的好用，比起 Process Monitor，我觉得火绒剑的使用体验更加轻快。</strong></p><hr><h2 id="网络分析"><a class="markdownIt-Anchor" href="#网络分析">#</a> 网络分析</h2><h3 id="wireshark"><a class="markdownIt-Anchor" href="#wireshark">#</a> WireShark</h3><p><strong>开源的网络分析工具，针对网卡抓包，能用于分析学习更底层的协议 (传输层，网络层、数据链路层)。</strong></p><ul><li>官方网站<ul><li><a href="https://www.wireshark.org/">https://www.wireshark.org/</a></li></ul></li></ul><h3 id="fiddler"><a class="markdownIt-Anchor" href="#fiddler">#</a> Fiddler</h3><p><strong>免费的 http/https 抓包工具，基于系统代理工作，https 抓包原理是中间人攻击，为操作系统安装 Fiddler 生成的证书，就能截获信任操作系统中安装的证书的应用程序的 https 流量。</strong></p><ul><li>官方网站<ul><li><a href="https://www.telerik.com/fiddler">https://www.telerik.com/fiddler</a></li></ul></li></ul><h3 id="proxifier"><a class="markdownIt-Anchor" href="#proxifier">#</a> Proxifier</h3><p><strong>强制代理工具，有些应用并不会使用系统代理设置指定的代理，因此 Fiddler 无法截获这类应用的 http/https 流量，这个时候 Proxifier 是很好的搭档。</strong></p><ul><li>个人文章<ul><li><a href="/posts/5e1f.html" title="【Proxifier】基本配置与使用">【Proxifier】基本配置与使用</a></li></ul></li></ul><hr><h1 id="静态分析"><a class="markdownIt-Anchor" href="#静态分析">#</a> 静态分析</h1><h2 id="反汇编"><a class="markdownIt-Anchor" href="#反汇编">#</a> 反汇编</h2><h3 id="ida"><a class="markdownIt-Anchor" href="#ida">#</a> IDA</h3><p><strong>我觉得 &quot;IDA&quot; 这个名字，就是对 &quot;静态分析&quot; 最有力的诠释了，世界顶级的交互式反汇编工具，功能及其强大，所以使用也很复杂。</strong></p><ul><li><p>推荐书籍</p><ul><li>《IDA Pro 权威指南 (第 2 版)》</li></ul></li><li><p>推荐插件</p><ul><li>ret-sync</li></ul></li></ul><hr><h2 id="pe分析"><a class="markdownIt-Anchor" href="#pe分析">#</a> PE 分析</h2><h3 id="cff-explorer-viii"><a class="markdownIt-Anchor" href="#cff-explorer-viii">#</a> CFF Explorer VIII</h3><p><strong>很优秀的 PE 分析工具，用过之后就基本上没有再尝试其他的 PE 工具了。</strong></p><h2 id="十六进制编辑器"><a class="markdownIt-Anchor" href="#十六进制编辑器">#</a> 十六进制编辑器</h2><h3 id="hxd"><a class="markdownIt-Anchor" href="#hxd">#</a> HxD</h3><p><strong>个人体验很好的免费十六进制编辑器，轻便。</strong></p><ul><li>官方网站<ul><li><a href="https://mh-nexus.de/en/hxd/">https://mh-nexus.de/en/hxd/</a></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 逆向工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 逆向分析 </tag>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MFC】探索消息映射机制的实现原理</title>
      <link href="/posts/c22c.html"/>
      <url>/posts/c22c.html</url>
      
        <content type="html"><![CDATA[<h1 id="消息机制简述"><a class="markdownIt-Anchor" href="#消息机制简述">#</a> 消息机制简述</h1><p>我们知道，Windows 的窗口是由<strong>消息</strong>驱动的；<br>Windows 通过捕获鼠标、键盘等输入设备产生的动作，再生成对应的消息，并传递给相应的窗口所属的线程。</p><div class="note purple icon-padding simple"><i class="note-icon fas fa-fan"></i><p>直接基于 <code>Win32API</code>  开发时，我们需要在注册窗口类时指定<strong>窗口过程函数</strong>，以告知 Windows 回调 (传递消息) 的入口。</p></div><hr><h1 id="mfc的消息映射"><a class="markdownIt-Anchor" href="#mfc的消息映射">#</a> MFC 的消息映射</h1><p>而 MFC 为我们提供了一种更为方便的机制，<emp>直接为一个消息与一个函数建立映射关系</emp>，在消息产生时，回调此函数，而不再需要我们去自行分发。</p><details class="folding-tag" blue><summary> 消息映射示例 </summary>              <div class='content'>              <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;afxwin.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CMyFrameWnd</span> : <span class="keyword">public</span> CFrameWnd &#123;</span><br><span class="line"><span class="built_in">DECLARE_MESSAGE_MAP</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">LRESULT <span class="title">OnCreate</span><span class="params">(WPARAM wParam, LPARAM lParam)</span> </span>&#123;</span><br><span class="line"><span class="built_in">AfxMessageBox</span>(<span class="string">L&quot;Window Create!&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">BEGIN_MESSAGE_MAP</span>(CMyFrameWnd, CFrameWnd)</span><br><span class="line"><span class="built_in">ON_MESSAGE</span>(WM_CREATE, OnCreate)   <span class="comment">// 将WM_CREATE与CMyFrameWnd类的成员函数OnCreate建立映射</span></span><br><span class="line"><span class="built_in">END_MESSAGE_MAP</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CMyWinApp</span> : <span class="keyword">public</span> CWinApp &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">CMyWinApp</span>() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> BOOL <span class="title">InitInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">CMyFrameWnd* frame = <span class="keyword">new</span> CMyFrameWnd;</span><br><span class="line">frame-&gt;<span class="built_in">Create</span>(<span class="literal">nullptr</span>, <span class="string">L&quot;MFCBase&quot;</span>);</span><br><span class="line">m_pMainWnd = frame;</span><br><span class="line">frame-&gt;<span class="built_in">ShowWindow</span>(SW_SHOW);</span><br><span class="line">frame-&gt;<span class="built_in">UpdateWindow</span>();</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">CMyWinApp g_theApp;</span><br></pre></td></tr></table></figure>              </div>            </details><h2 id="消息映射宏"><a class="markdownIt-Anchor" href="#消息映射宏">#</a> 消息映射宏</h2><p>MFC 的消息映射是通过几个<strong>宏函数</strong>来实现的，我们以上述代码为例，将宏展开，一探究竟。</p><ul><li><p>声明宏<br> MFC 的声明宏，就是在窗口类中声明两个受保护的成员函数。</p>  <details class="folding-tag" blue><summary> ECLARE_MESSAGE_MAP() </summary>              <div class='content'>              <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">const</span> AFX_MSGMAP* PASCAL <span class="title">GetThisMessageMap</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">const</span> AFX_MSGMAP* <span class="title">GetMessageMap</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>              </div>            </details></li><li><p>定义宏<br>定义则稍显复杂，由多个宏函数组成，实际上是在实现声明宏声明的成员函数。</p>  <details class="folding-tag" blue><summary> BEGIN_MESSAGE_MAP() </summary>              <div class='content'>              <p><code>BEGIN_MESSAGE_MAP(CMyFrameWnd, CFrameWnd)</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PTM_WARNING_DISABLE</span></span><br><span class="line"><span class="function"><span class="type">const</span> AFX_MSGMAP* <span class="title">CMyFrameWnd::GetMessageMap</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">GetThisMessageMap</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">const</span> AFX_MSGMAP* PASCAL <span class="title">CMyFrameWnd::GetThisMessageMap</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">typedef</span> CMyFrameWnd ThisClass;</span><br><span class="line"><span class="keyword">typedef</span> CFrameWnd TheBaseClass;</span><br><span class="line">__pragma(<span class="built_in">warning</span>(push))</span><br><span class="line">__pragma(<span class="built_in">warning</span>(disable: <span class="number">4640</span>))</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> AFX_MSGMAP_ENTRY _messageEntries[] =</span><br><span class="line">&#123;</span><br></pre></td></tr></table></figure>              </div>            </details>  <details class="folding-tag" blue><summary> ON_MESSAGE() </summary>              <div class='content'>              <p><code>ON_MESSAGE(WM_CREATE, OnCreate)</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实际上是在为_messageEntries变量的初始化列表添加结构体元素</span></span><br><span class="line">&#123; WM_CREATE, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, AfxSig_lwl, (AFX_PMSG)(AFX_PMSGW)(<span class="built_in">static_cast</span>&lt;<span class="built_in">LRESULT</span>(AFX_MSG_CALL CWnd::*)(WPARAM, LPARAM)&gt;(OnCreate))&#125;,</span><br></pre></td></tr></table></figure>              </div>            </details>  <details class="folding-tag" blue><summary> END_MESSAGE_MAP() </summary>              <div class='content'>              <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, AfxSig_end, (AFX_PMSG)<span class="number">0</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line">__pragma(<span class="built_in">warning</span>(pop))</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> AFX_MSGMAP messageMap =</span><br><span class="line">&#123; &amp;TheBaseClass::GetThisMessageMap, &amp;_messageEntries[<span class="number">0</span>] &#125;;</span><br><span class="line"><span class="keyword">return</span> &amp;messageMap;</span><br><span class="line">&#125;</span><br><span class="line">PTM_WARNING_RESTORE</span><br></pre></td></tr></table></figure>              </div>            </details></li><li><p>整体展开</p><details class="folding-tag" blue><summary> 消息映射示例-宏展开 </summary>              <div class='content'>              <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;afxwin.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CMyFrameWnd</span> :<span class="keyword">public</span> CFrameWnd &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">const</span> AFX_MSGMAP* PASCAL <span class="title">GetThisMessageMap</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> AFX_MSGMAP* <span class="title">GetMessageMap</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">LRESULT <span class="title">OnCreate</span><span class="params">(WPARAM wParam, LPARAM lParam)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">AfxMessageBox</span>(<span class="string">L&quot;Window Create!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">PTM_WARNING_DISABLE</span></span><br><span class="line"><span class="function"><span class="type">const</span> AFX_MSGMAP* <span class="title">CMyFrameWnd::GetMessageMap</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">GetThisMessageMap</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">const</span> AFX_MSGMAP* PASCAL <span class="title">CMyFrameWnd::GetThisMessageMap</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> CMyFrameWnd ThisClass;</span><br><span class="line">    <span class="keyword">typedef</span> CFrameWnd TheBaseClass;</span><br><span class="line">    __pragma(<span class="built_in">warning</span>(push))</span><br><span class="line">    __pragma(<span class="built_in">warning</span>(disable: <span class="number">4640</span>))</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> AFX_MSGMAP_ENTRY _messageEntries[] =</span><br><span class="line">    &#123;</span><br><span class="line">      &#123; WM_CREATE, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, AfxSig_lwl, (AFX_PMSG)(AFX_PMSGW)(<span class="built_in">static_cast</span>&lt;<span class="built_in">LRESULT</span>(AFX_MSG_CALL CWnd::*)(WPARAM, LPARAM)&gt;(OnCreate))&#125;,</span><br><span class="line">      &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, AfxSig_end, (AFX_PMSG)<span class="number">0</span> &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    __pragma(<span class="built_in">warning</span>(pop))</span><br><span class="line">        <span class="type">static</span> <span class="type">const</span> AFX_MSGMAP messageMap =</span><br><span class="line">    &#123; &amp;TheBaseClass::GetThisMessageMap, &amp;_messageEntries[<span class="number">0</span>] &#125;;</span><br><span class="line">    <span class="keyword">return</span> &amp;messageMap;</span><br><span class="line">&#125;</span><br><span class="line">PTM_WARNING_RESTORE</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CMyWinApp</span> :<span class="keyword">public</span> CWinApp &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CMyWinApp</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> BOOL <span class="title">InitInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CMyFrameWnd* frame = <span class="keyword">new</span> CMyFrameWnd;</span><br><span class="line">        frame-&gt;<span class="built_in">Create</span>(<span class="literal">nullptr</span>, <span class="string">L&quot;MFCBase&quot;</span>);</span><br><span class="line">        m_pMainWnd = frame;</span><br><span class="line">        frame-&gt;<span class="built_in">ShowWindow</span>(SW_SHOW);</span><br><span class="line">        frame-&gt;<span class="built_in">UpdateWindow</span>();</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">CMyWinApp g_theApp;</span><br></pre></td></tr></table></figure>              </div>            </details></li></ul><div class="note purple icon-padding simple"><i class="note-icon fas fa-fan"></i><p>通过宏添加消息映射时，实际上是重写了 <code>CFrameWnd</code>  类的 <code>GetMessageMap</code>  成员虚函数；<br>而 <code>GetMessageMap</code>  函数初始化了一个名为 <code>_messageEntries</code>  和 <code>messageMap</code>  的<strong>静态局部变量</strong>，并将该变量的地址返回。<br>我们简单猜测，与上一节重写 <code>WindowProc</code>  类似，微软在<strong>窗口过程函数</strong> <code>AfxWndProc</code>  的某处，得到窗口对象之后，以窗口对象的身份调用其成员虚函数 <code>GetMessageMap</code> ；<br>由于成员虚函数被重写的原因，得到我们所设定的<strong>映射关系表</strong>，我们这里就把它叫做<strong>消息映射表</strong>；<br>基于此消息映射表，就可以在<strong>窗口过程函数</strong>中，<emp>根据消息调用对应的成员函数</emp>。</p></div><hr><h1 id="探索实现原理"><a class="markdownIt-Anchor" href="#探索实现原理">#</a> 探索实现原理</h1><p>我们基本上能够理解消息映射机制的工作原理，这小节我们就扒一下微软的源码，以便更清晰的了解消息映射机制。</p><details class="folding-tag" blue><summary> AfxWndProc </summary>              <div class='content'>              <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRESULT CALLBACK</span></span><br><span class="line"><span class="function"><span class="title">AfxWndProc</span><span class="params">(HWND hWnd, UINT nMsg, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// special message which identifies the window as using AfxWndProc</span></span><br><span class="line"><span class="keyword">if</span> (nMsg == WM_QUERYAFXWNDPROC)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// all other messages route through message map</span></span><br><span class="line">CWnd* pWnd = CWnd::<span class="built_in">FromHandlePermanent</span>(hWnd);</span><br><span class="line"><span class="built_in">ASSERT</span>(pWnd != <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">ASSERT</span>(pWnd==<span class="literal">NULL</span> || pWnd-&gt;m_hWnd == hWnd);</span><br><span class="line"><span class="keyword">if</span> (pWnd == <span class="literal">NULL</span> || pWnd-&gt;m_hWnd != hWnd)</span><br><span class="line"><span class="keyword">return</span> ::<span class="built_in">DefWindowProc</span>(hWnd, nMsg, wParam, lParam);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">AfxCallWndProc</span>(pWnd, hWnd, nMsg, wParam, lParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><p>调试上面提供的代码，首先在 <code>AfxWndProc</code>  函数设置断点；</p><p>继续走到 <code>AfxCallWndProc</code> ；</p><details class="folding-tag" blue><summary> AfxCallWndProc </summary>              <div class='content'>              <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRESULT AFXAPI <span class="title">AfxCallWndProc</span><span class="params">(CWnd* pWnd, HWND hWnd, UINT nMsg,</span></span></span><br><span class="line"><span class="params"><span class="function">WPARAM wParam = <span class="number">0</span>, LPARAM lParam = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="comment">// delegate to object&#x27;s WindowProc</span></span><br><span class="line">lResult = pWnd-&gt;<span class="built_in">WindowProc</span>(nMsg, wParam, lParam);</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>              </div>            </details><p>到此处停下，此时你可能会有些疑惑，诶，我们并没有重写 <code>Cwnd::WindowProc</code> ，为什么要到此处停下？<br>因为微软将消息映射机制放到了此函数内实现。</p><details class="folding-tag" blue><summary> CWnd::WindowProc </summary>              <div class='content'>              <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRESULT <span class="title">CWnd::WindowProc</span><span class="params">(UINT message, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// OnWndMsg does most of the work, except for DefWindowProc call</span></span><br><span class="line">LRESULT lResult = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">OnWndMsg</span>(message, wParam, lParam, &amp;lResult))</span><br><span class="line">lResult = <span class="built_in">DefWindowProc</span>(message, wParam, lParam);</span><br><span class="line"><span class="keyword">return</span> lResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><p>继续到进入 <code>CWnd::OnWndMsg</code> 。</p><details class="folding-tag" blue><summary> CWnd::OnWndMsg </summary>              <div class='content'>              <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CWnd::OnWndMsg</span><span class="params">(UINT message, WPARAM wParam, LPARAM lParam, LRESULT* pResult)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="type">const</span> AFX_MSGMAP* pMessageMap; pMessageMap = <span class="built_in">GetMessageMap</span>();</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>              </div>            </details><p>上面的代码我们暂时不关心，只关心对 <code>GetMessageMap</code>  函数的调用；<br>还记得吗？我们将消息声明 / 定义宏展开后，就相当于我们为 <code>CMyFrameWnd</code>  类定义了两个函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">const</span> AFX_MSGMAP* PASCAL <span class="title">GetThisMessageMap</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">const</span> AFX_MSGMAP* <span class="title">GetMessageMap</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><p>此处是以 <code>CMyFrameWnd</code>  类的对象的身份调用的 <code>GetMessageMap</code> ，因此实际上是在调用我们类中由消息映射宏重写的成员虚函数。</p><details class="folding-tag" blue><summary> CMyFrameWnd::GetMessageMap </summary>              <div class='content'>              <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> AFX_MSGMAP* <span class="title">CMyFrameWnd::GetMessageMap</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">GetThisMessageMap</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><p>这里只是简单的调用了静态成员函数 <code>GetThisMessageMap</code> 。</p><details class="folding-tag" blue><summary> CMyFrameWnd::GetThisMessageMap </summary>              <div class='content'>              <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> AFX_MSGMAP* PASCAL <span class="title">CMyFrameWnd::GetThisMessageMap</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> AFX_MSGMAP_ENTRY _messageEntries[] =</span><br><span class="line">    &#123;</span><br><span class="line">      &#123; WM_CREATE, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, AfxSig_lwl, (AFX_PMSG)(AFX_PMSGW)(<span class="built_in">static_cast</span>&lt;<span class="built_in">LRESULT</span>(AFX_MSG_CALL CWnd::*)(WPARAM, LPARAM)&gt;(&amp;OnCreate)) &#125;,</span><br><span class="line">      &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, AfxSig_end, (AFX_PMSG)<span class="number">0</span> &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> AFX_MSGMAP messageMap =</span><br><span class="line">    &#123; &amp;CFrameWnd::GetThisMessageMap, &amp;_messageEntries[<span class="number">0</span>] &#125;;</span><br><span class="line">    <span class="keyword">return</span> &amp;messageMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><p>我这里对原先的代码做了一些简化，更方便看一点，实际上呢就是为当前函数的静态局部变量 <code>_messageEntries</code> 、 <code>messageMap</code>  赋值，并返回 <code>messageMap</code>  的地址。</p><p>又回到 <code>CWnd::OnWndMsg</code></p><details class="folding-tag" blue><summary> CWnd::OnWndMsg </summary>              <div class='content'>              <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CWnd::OnWndMsg</span><span class="params">(UINT message, WPARAM wParam, LPARAM lParam, LRESULT* pResult)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="type">const</span> AFX_MSGMAP* pMessageMap; pMessageMap = <span class="built_in">GetMessageMap</span>();</span><br><span class="line">  UINT iHash; iHash = (<span class="built_in">LOWORD</span>((DWORD_PTR)pMessageMap) ^ message) &amp; (iHashMax<span class="number">-1</span>);</span><br><span class="line">winMsgLock.<span class="built_in">Lock</span>(CRIT_WINMSGCACHE);</span><br><span class="line">AFX_MSG_CACHE* pMsgCache; pMsgCache = &amp;_afxMsgCache[iHash];</span><br><span class="line"><span class="type">const</span> AFX_MSGMAP_ENTRY* lpEntry;</span><br><span class="line"><span class="keyword">if</span> (message == pMsgCache-&gt;nMsg &amp;&amp; pMessageMap == pMsgCache-&gt;pMessageMap)</span><br><span class="line">  &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// not in cache, look for it</span></span><br><span class="line">pMsgCache-&gt;nMsg = message;</span><br><span class="line">pMsgCache-&gt;pMessageMap = pMessageMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="comment">/* pMessageMap already init&#x27;ed */</span>; pMessageMap-&gt;pfnGetBaseMap != <span class="literal">NULL</span>;</span><br><span class="line">      pMessageMap = (*pMessageMap-&gt;pfnGetBaseMap)())</span><br><span class="line">&#123;</span><br><span class="line">      ...</span><br></pre></td></tr></table></figure>              </div>            </details><p>使 <code>pMessageMap</code>  指向静态局部变量 <code>messageMap</code> 。</p><p>记住上述代码的第 <code>19</code> ~ <code>20</code>  行要进入循环；</p><p>剩下的我们暂时不关心，继续向下看。</p><details class="folding-tag" blue><summary> CWnd::OnWndMsg </summary>              <div class='content'>              <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="comment">/* pMessageMap already init&#x27;ed */</span>; pMessageMap-&gt;pfnGetBaseMap != <span class="literal">NULL</span>;</span><br><span class="line">pMessageMap = (*pMessageMap-&gt;pfnGetBaseMap)())</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Note: catch not so common but fatal mistake!!</span></span><br><span class="line"><span class="comment">//      BEGIN_MESSAGE_MAP(CMyWnd, CMyWnd)</span></span><br><span class="line"><span class="built_in">ASSERT</span>(pMessageMap != (*pMessageMap-&gt;pfnGetBaseMap)());</span><br><span class="line"><span class="keyword">if</span> (message &lt; <span class="number">0xC000</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// constant window message</span></span><br><span class="line"><span class="keyword">if</span> ((lpEntry = <span class="built_in">AfxFindMessageEntry</span>(pMessageMap-&gt;lpEntries,</span><br><span class="line">message, <span class="number">0</span>, <span class="number">0</span>)) != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">pMsgCache-&gt;lpEntry = lpEntry;</span><br><span class="line">winMsgLock.<span class="built_in">Unlock</span>();</span><br><span class="line"><span class="keyword">goto</span> LDispatch;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><p>第 <code>10</code> ~ <code>11</code>  行是关键函数， <code>pMessageMap-&gt;lpEntries</code>  即是访问静态局部变量 <code>messageMap</code>  的第二个成员，也就是 <code>_messageEntries</code>  的地址；<br>而 <code>message</code>  就是本次窗口过程处理的消息 ID 了；</p><emp>即传入消息映射表地址和消息，查找对应的条目</emp>。<p>返回值即是 <code>_messageEntries</code>  中对应条目的地址，如果返回 <code>NULL</code>  表示消息映射表中不存在此消息。<br>我们假定此消息已经被我们影射了，跟随 <code>goto LDispatch;</code>  继续。</p><details class="folding-tag" blue><summary> CWnd::OnWndMsg </summary>              <div class='content'>              <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">LDispatch:</span><br><span class="line"><span class="built_in">ASSERT</span>(message &lt; <span class="number">0xC000</span>);</span><br><span class="line"></span><br><span class="line">mmf.pfn = lpEntry-&gt;pfn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (lpEntry-&gt;nSig)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">case</span> AfxSig_l_w_l:</span><br><span class="line">lResult = (<span class="keyword">this</span>-&gt;*mmf.pfn_l_w_l)(wParam, lParam);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>              </div>            </details><p>最终会在此处以 <code>CMyFrameWnd</code>  类对象的身份调用我们指定的 <code>OnCreate</code>  成员函数。</p><h2 id="消息映射表链表"><a class="markdownIt-Anchor" href="#消息映射表链表">#</a> 消息映射表链表</h2><p>整个流程基本上到这里就完成了，实际上我们留了一个小坑，即上面代码中我们暂时跳过的 for 循环。</p><p>实际上那是在遍历<emp>消息映射表链表</emp>，但是我们并没有提过，存在多个消息映射表这件事。</p><p>实际上， <code>CFrameWnd</code>  类也使用了消息映射机制，而 <code>CMyFrameWnd::GetMessageMap</code>  函数中的静态局部变量 <code>messageMap</code> ，第一个成员指向的就是静态成员函数 <code>CFrameWnd::GetThisMessageMap</code> 。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="comment">/* pMessageMap already init&#x27;ed */</span>; pMessageMap-&gt;pfnGetBaseMap != <span class="literal">NULL</span>;</span><br><span class="line">      pMessageMap = (*pMessageMap-&gt;pfnGetBaseMap)())</span><br></pre></td></tr></table></figure><p>而 <code>pMessageMap-&gt;pfnGetBaseMap</code> ，就是在访问 <code>messageMap</code>  的第一个成员。</p><p>此 for 循环的工作：<br>从链表头 ( <code>CMyFrameWnd</code> ) 开始，<emp>即最子类向上遍历，依次查找是否存在与本次消息匹配的消息映射关系，存在则调用对应的成员函数并返回</emp></p><hr><h1 id="消息映射分类"><a class="markdownIt-Anchor" href="#消息映射分类">#</a> 消息映射分类</h1><p>其实，除了 <code>ON_MESSAGE</code>  之外，微软还提供了更加方便的，直接映射指定消息的宏。</p><details class="folding-tag" blue><summary> 代码示例 </summary>              <div class='content'>              <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;afxwin.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CMyFrameWnd</span> :<span class="keyword">public</span> CFrameWnd &#123;</span><br><span class="line">    <span class="built_in">DECLARE_MESSAGE_MAP</span>()</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">OnCreate</span><span class="params">(LPCREATESTRUCT pCs)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">BEGIN_MESSAGE_MAP</span>(CMyFrameWnd, CFrameWnd)</span><br><span class="line">    <span class="built_in">ON_WM_CREATE</span>()</span><br><span class="line"><span class="built_in">END_MESSAGE_MAP</span>()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CMyFrameWnd::OnCreate</span><span class="params">(LPCREATESTRUCT pCs)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">AfxMessageBox</span>(<span class="string">L&quot;OnCreate!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CMyWinApp</span> :<span class="keyword">public</span> CWinApp &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CMyWinApp</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> BOOL <span class="title">InitInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CMyFrameWnd* frame = <span class="keyword">new</span> CMyFrameWnd;</span><br><span class="line">        frame-&gt;<span class="built_in">Create</span>(<span class="literal">nullptr</span>, <span class="string">L&quot;MFCBase&quot;</span>);</span><br><span class="line">        m_pMainWnd = frame;</span><br><span class="line">        frame-&gt;<span class="built_in">ShowWindow</span>(SW_SHOW);</span><br><span class="line">        frame-&gt;<span class="built_in">UpdateWindow</span>();</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">CMyWinApp g_theApp;</span><br></pre></td></tr></table></figure>              </div>            </details><p>我们将 <code>ON_WM_CREATE</code>  宏展开，看看与 <code>ON_MESSAGE</code>  有什么区别。</p><details class="folding-tag" blue><summary> ON_WM_CREATE </summary>              <div class='content'>              <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ON_WM_CREATE() \</span></span><br><span class="line"><span class="meta">&#123; WM_CREATE, 0, 0, 0, AfxSig_is, \</span></span><br><span class="line"><span class="meta">(AFX_PMSG) (AFX_PMSGW) \</span></span><br><span class="line"><span class="meta">(static_cast<span class="string">&lt; int (AFX_MSG_CALL CWnd::*)(LPCREATESTRUCT) &gt;</span> ( &amp;ThisClass :: OnCreate)) &#125;,</span></span><br></pre></td></tr></table></figure>              </div>            </details><details class="folding-tag" blue><summary> ON_MESSAGE </summary>              <div class='content'>              <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ON_MESSAGE(message, memberFxn) \</span></span><br><span class="line"><span class="meta">&#123; message, 0, 0, 0, AfxSig_lwl, \</span></span><br><span class="line"><span class="meta">(AFX_PMSG)(AFX_PMSGW) \</span></span><br><span class="line"><span class="meta">(static_cast<span class="string">&lt; LRESULT (AFX_MSG_CALL CWnd::*)(WPARAM, LPARAM) &gt;</span> \</span></span><br><span class="line"><span class="meta">(memberFxn)) &#125;,</span></span><br></pre></td></tr></table></figure>              </div>            </details><p>首先就是， <code>ON_WM_CREATE</code>  不再要求我们提供参数消息 id 与回调函数名，而是直接指定为 <code>WM_CREATE</code>  与 <code>OnCreate</code> ；<br>其次， <code>ON_MESSAGE</code>  与 <code>ON_WM_CREATE</code>  添加的消息映射条目 <code>AFX_MSGMAP_ENTRY</code>  元素的第 5 个成员 <code>nSig</code> ，分别是 <code>AfxSig_l_w_l</code>  与 <code>AfxSig_i_v_s</code> 。</p><p>还记得吗，我们指定的消息映射函数，都是在 <code>CWnd::OnWndMsg</code>  函数内被调用的；<br>而先前通过 <code>ON_MESSAGE</code>  定义的消息映射，回调函数原型都是相同的。<br>而通过 <code>ON_WM_CREATE</code>  定义的消息映射，和 <code>ON_MESSAGE</code>  指定的消息映射函数的原型是不同的，那么 <code>CWnd::OnWndMsg</code>  是怎么区分不同的函数原型并进行回调的呢？</p><p>我们回到 <code>CWnd::OnWndMsg</code>  函数：</p><details class="folding-tag" blue><summary> CWnd::OnWndMsg </summary>              <div class='content'>              <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">LDispatch:</span><br><span class="line"><span class="built_in">ASSERT</span>(message &lt; <span class="number">0xC000</span>);</span><br><span class="line"></span><br><span class="line">mmf.pfn = lpEntry-&gt;pfn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (lpEntry-&gt;nSig)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">case</span> AfxSig_i_v_s:</span><br><span class="line">lResult = (<span class="keyword">this</span>-&gt;*mmf.pfn_i_s)(<span class="built_in">reinterpret_cast</span>&lt;LPTSTR&gt;(lParam));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">case</span> AfxSig_l_w_l:</span><br><span class="line">lResult = (<span class="keyword">this</span>-&gt;*mmf.pfn_l_w_l)(wParam, lParam);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>              </div>            </details><p>其中最关键的就是 <code>switch (lpEntry-&gt;nSig)</code> ：</p><ul><li>通过 <code>ON_MESSAGE</code>  定义的消息映射时，nSig 成员是 <code>AfxSig_l_w_l</code> ；</li><li>通过 <code>ON_WM_CREATE</code>  定义的消息映射时，nSig 成员是 <code>AfxSig_i_v_s</code></li></ul><p>这就是为什么，函数原型不同，回调也能正确进行的缘故。</p>]]></content>
      
      
      <categories>
          
          <category> MFC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MFC </tag>
            
            <tag> 没饭吃 </tag>
            
            <tag> C++ </tag>
            
            <tag> 界面开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MFC】探索窗口创建机制的实现原理</title>
      <link href="/posts/78f0.html"/>
      <url>/posts/78f0.html</url>
      
        <content type="html"><![CDATA[<h1 id="何时创建窗口"><a class="markdownIt-Anchor" href="#何时创建窗口">#</a> 何时创建窗口？</h1><p>我们在直接使用 <code>Win32API</code>  开发窗口程序的时候，一般都是在消息循环之前调用相关的函数创建窗口，那么 MFC 的窗口是在何时被创建的呢？</p><p>实际上，我们重写了 <code>CWinThread::InitInstance</code>  成员虚函数，并在函数中编写了创建了窗口的代码；<br>根据我们之前分析的程序流程， <code>CWinThread::InitInstance</code>  的调用时机在 <code>CWubApp::Run</code>  之前，这自然也合情合理。</p><h1 id="窗口的基本创建流程"><a class="markdownIt-Anchor" href="#窗口的基本创建流程">#</a> 窗口的基本创建流程</h1><p>还是之前的示例代码：</p><details class="folding-tag" blue><summary> 示例 </summary>              <div class='content'>              <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;afxwin.h&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CMyFrameWnd</span> :<span class="keyword">public</span> CFrameWnd &#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CMyWinApp</span> :<span class="keyword">public</span> CWinApp &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CMyWinApp</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> BOOL <span class="title">InitInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CMyFrameWnd* frame = <span class="keyword">new</span> CMyFrameWnd;</span><br><span class="line">        frame-&gt;<span class="built_in">Create</span>(<span class="literal">nullptr</span>, <span class="string">L&quot;MFCBase&quot;</span>);</span><br><span class="line">        m_pMainWnd = frame;</span><br><span class="line">        frame-&gt;<span class="built_in">ShowWindow</span>(SW_SHOW);</span><br><span class="line">        frame-&gt;<span class="built_in">UpdateWindow</span>();</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">CMyWinApp g_theApp;</span><br></pre></td></tr></table></figure>              </div>            </details><div class="note warning no-icon flat"><p><code>CMyFrameWnd* frame = new CMyFrameWnd;</code></p></div><p>我们 new 了一个 <code>CMyFrameWnd</code>  对象，而 <code>CMyFrameWnd</code>  类继承自 <code>CFrameWnd</code>  类。<br> <code>CFrameWnd</code>  是对框架窗口的封装。</p><div class="note warning no-icon flat"><p><code>frame-&gt;Create(nullptr, L&quot;MFCBase&quot;);</code></p></div><p>基于新建的 <code>frame</code> ，调用了 <code>Create</code>  成员函数，我们猜测内部应当是调用了 <code>CreateWindow</code>  之类创建窗口的函数。</p><div class="note warning no-icon flat"><p><code>m_pMainWnd = frame;</code></p></div><p><code>m_pMainWnd</code>  是 <code>CWinThread</code>  类的成员，指向当前线程的主窗口。<br>那么我们所做的其实就是，创建一个框架窗口，并使其成为 <code>g_theApp</code>  的主窗口。</p><div class="tip "><p>读者可能会有些疑惑，线程和窗口又有什么关系？<br>实际上，Windows 产生的消息都是发送给线程的，每一个窗口都必须关联到一个线程中，一个线程可以被多个窗口关联。<br>消息循环就是线程的工作， <code>GetMessage</code>  从当前线程的消息队列中获取消息；<br> <code>DispatchMessage</code>  负责将消息再次派发给当前线程的所属窗口中对应的窗口 ( <code>回调窗口过程函数</code> )。<br>我们所定义的 <code>g_theApp</code> ，表示的是应用程序的主线程。</p></div><div class="note warning no-icon flat"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">frame-&gt;<span class="built_in">ShowWindow</span>(SW_SHOW);</span><br><span class="line">frame-&gt;<span class="built_in">UpdateWindow</span>();</span><br></pre></td></tr></table></figure></div><p>这两行就更加明显了，猜测内部应当是调用了 <code>ShowWindow</code> 、 <code>UpdateWindow</code> 。</p><h1 id="框架窗口的create分析"><a class="markdownIt-Anchor" href="#框架窗口的create分析">#</a> 框架窗口的 Create 分析</h1><p>我们在直接使用 <code>Win32API</code>  开发桌面应用时，创建窗口前会先注册窗口类、指定各种各样的字段和参数，创建窗口，十分繁琐。<br>而 MFC 为我们简化到只需要传递两个参数就能创建一个窗口，接下来我们进入这个函数内部一探究竟。</p><details class="folding-tag" blue><summary> CFrameWnd::Create 第一部分 </summary>              <div class='content'>              <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CFrameWnd::Create</span><span class="params">(LPCTSTR lpszClassName,</span></span></span><br><span class="line"><span class="params"><span class="function">LPCTSTR lpszWindowName,</span></span></span><br><span class="line"><span class="params"><span class="function">DWORD dwStyle,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">const</span> RECT&amp; rect,</span></span></span><br><span class="line"><span class="params"><span class="function">CWnd* pParentWnd,</span></span></span><br><span class="line"><span class="params"><span class="function">LPCTSTR lpszMenuName,</span></span></span><br><span class="line"><span class="params"><span class="function">DWORD dwExStyle,</span></span></span><br><span class="line"><span class="params"><span class="function">CCreateContext* pContext)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HMENU hMenu = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (lpszMenuName != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// load in a menu that will get destroyed when window gets destroyed</span></span><br><span class="line">HINSTANCE hInst = <span class="built_in">AfxFindResourceHandle</span>(lpszMenuName, ATL_RT_MENU);</span><br><span class="line"><span class="keyword">if</span> ((hMenu = ::<span class="built_in">LoadMenu</span>(hInst, lpszMenuName)) == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">TRACE</span>(traceAppMsg, <span class="number">0</span>, <span class="string">&quot;Warning: failed to load menu for CFrameWnd.\n&quot;</span>);</span><br><span class="line"><span class="built_in">PostNcDestroy</span>();            <span class="comment">// perhaps delete the C++ object</span></span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><p>进到函数中，发现参数其实还是不少的。<br>为什么我们只传递了两个呢？想必是 MFC 在成员函数的声明处，为后面的参数设置了缺省值。</p><div class="note warning no-icon flat"><p><code>if (lpszMenuName != NULL)</code></p></div><p>我们并没有指定这个参数，因此此参数使用缺省值 <code>NULL</code> ，跳过此部分。</p><details class="folding-tag" blue><summary> CFrameWnd::Create 第二部分 </summary>              <div class='content'>              <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">m_strTitle = lpszWindowName;    <span class="comment">// save title for later</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">CreateEx</span>(dwExStyle, lpszClassName, lpszWindowName, dwStyle,</span><br><span class="line">rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top,</span><br><span class="line">pParentWnd-&gt;<span class="built_in">GetSafeHwnd</span>(), hMenu, (LPVOID)pContext))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">TRACE</span>(traceAppMsg, <span class="number">0</span>, <span class="string">&quot;Warning: failed to create CFrameWnd.\n&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (hMenu != <span class="literal">NULL</span>)</span><br><span class="line"><span class="built_in">DestroyMenu</span>(hMenu);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><p>关键调用明显就只有 <code>CreateEx</code>  这个成员函数了，继续深入。</p><details class="folding-tag" blue><summary> CWnd::CreateEx 第一部分 </summary>              <div class='content'>              <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CWnd::CreateEx</span><span class="params">(DWORD dwExStyle, LPCTSTR lpszClassName,</span></span></span><br><span class="line"><span class="params"><span class="function">LPCTSTR lpszWindowName, DWORD dwStyle,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> nWidth, <span class="type">int</span> nHeight,</span></span></span><br><span class="line"><span class="params"><span class="function">HWND hWndParent, HMENU nIDorHMenu, LPVOID lpParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">ASSERT</span>(lpszClassName == <span class="literal">NULL</span> || <span class="built_in">AfxIsValidString</span>(lpszClassName) ||</span><br><span class="line"><span class="built_in">AfxIsValidAtom</span>(lpszClassName));</span><br><span class="line"><span class="built_in">ENSURE_ARG</span>(lpszWindowName == <span class="literal">NULL</span> || <span class="built_in">AfxIsValidString</span>(lpszWindowName));</span><br><span class="line"></span><br><span class="line"><span class="comment">// allow modification of several common create parameters</span></span><br><span class="line">CREATESTRUCT cs;</span><br><span class="line">cs.dwExStyle = dwExStyle;</span><br><span class="line">cs.lpszClass = lpszClassName;</span><br><span class="line">cs.lpszName = lpszWindowName;</span><br><span class="line">cs.style = dwStyle;</span><br><span class="line">cs.x = x;</span><br><span class="line">cs.y = y;</span><br><span class="line">cs.cx = nWidth;</span><br><span class="line">cs.cy = nHeight;</span><br><span class="line">cs.hwndParent = hWndParent;</span><br><span class="line">cs.hMenu = nIDorHMenu;</span><br><span class="line">cs.hInstance = <span class="built_in">AfxGetInstanceHandle</span>();</span><br><span class="line">cs.lpCreateParams = lpParam;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">PreCreateWindow</span>(cs))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">PostNcDestroy</span>();</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">AfxHookWindowCreate</span>(<span class="keyword">this</span>);</span><br><span class="line">HWND hWnd = <span class="built_in">CreateWindowEx</span>(cs.dwExStyle, cs.lpszClass,</span><br><span class="line">cs.lpszName, cs.style, cs.x, cs.y, cs.cx, cs.cy,</span><br><span class="line">cs.hwndParent, cs.hMenu, cs.hInstance, cs.lpCreateParams);</span><br></pre></td></tr></table></figure>              </div>            </details><p>我们可以直接看到对全局函数 <code>CreateWindowEx</code>  的调用，说明在这之前应该存在注册窗口类的代码。</p><div class="note warning no-icon flat"><p><code>if (!PreCreateWindow(cs))</code></p></div><p>实际上窗口类的注册位于 <code>PreCreateWindow</code>  成员函数中，如果 <code>cs.lpszClass</code>  为 <code>NULL</code> ，则会指定一个不会重复的窗口类名并基于此窗口类名注册窗口类。<br>而 <code>cs.lpszClass</code>  的值正是 <code>lpszClassName</code>  参数，是我们在调用 <code>CFrameWnd::Create</code>  时传递的 NULL。</p><details class="folding-tag" blue><summary> AfxEndDeferRegisterClass 部分 </summary>              <div class='content'>              <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL AFXAPI <span class="title">AfxEndDeferRegisterClass</span><span class="params">(LONG fToRegister)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// mask off all classes that are already registered</span></span><br><span class="line">AFX_MODULE_STATE* pModuleState = <span class="built_in">AfxGetModuleState</span>();</span><br><span class="line">fToRegister &amp;= ~pModuleState-&gt;m_fRegisteredClasses;</span><br><span class="line"><span class="keyword">if</span> (fToRegister == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line"></span><br><span class="line">LONG fRegisteredClasses = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// common initialization</span></span><br><span class="line">WNDCLASS wndcls;</span><br><span class="line"><span class="built_in">memset</span>(&amp;wndcls, <span class="number">0</span>, <span class="built_in">sizeof</span>(WNDCLASS));   <span class="comment">// start with NULL defaults</span></span><br><span class="line">wndcls.lpfnWndProc = DefWindowProc;</span><br><span class="line">wndcls.hInstance = <span class="built_in">AfxGetInstanceHandle</span>();</span><br><span class="line">wndcls.hCursor = afxData.hcurArrow;</span><br></pre></td></tr></table></figure>              </div>            </details><p>这个函数是 <code>PreCreateWindow</code>  内部调用的函数， <code>WNDCLASS</code>  是我们比较熟悉的结构，即注册窗口类需要使用的结构体。<br>需要关注的是，我们创建的窗口，窗口过程函数在哪里？<br>在这里出现了答案， <code>DefWindowProc</code>  函数就是我们创建的窗口过程函数。<br>但是是不是有点不对劲？ <code>DefWindowProc</code>  好像是 Windows 提供的默认窗口过程函数吧？<br>既然是 Windows 提供的函数实现，我们根本无法干涉，有消息也会回调这个函数。</p><p>显然，这是不正确的，那么我们暂时从 <code>AfxEndDeferRegisterClass</code>  函数退回到 <code>CWnd::CreateEx</code>  函数，继续我们的代码分析。</p><div class="note warning no-icon flat"><p><code>AfxHookWindowCreate(this);</code></p></div><p>这里调用了一个比较关键的函数，<emp>这也是MFC能再次拿到消息处理权的关键所在</emp>。</p><details class="folding-tag" blue><summary> AfxHookWindowCreate </summary>              <div class='content'>              <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> AFXAPI <span class="title">AfxHookWindowCreate</span><span class="params">(CWnd* pWnd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">_AFX_THREAD_STATE* pThreadState = _afxThreadState.<span class="built_in">GetData</span>();</span><br><span class="line"><span class="keyword">if</span> (pThreadState-&gt;m_pWndInit == pWnd)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pThreadState-&gt;m_hHookOldCbtFilter == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">pThreadState-&gt;m_hHookOldCbtFilter = ::<span class="built_in">SetWindowsHookEx</span>(WH_CBT,</span><br><span class="line">_AfxCbtFilterHook, <span class="literal">NULL</span>, ::<span class="built_in">GetCurrentThreadId</span>());</span><br><span class="line"><span class="keyword">if</span> (pThreadState-&gt;m_hHookOldCbtFilter == <span class="literal">NULL</span>)</span><br><span class="line"><span class="built_in">AfxThrowMemoryException</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">ASSERT</span>(pThreadState-&gt;m_hHookOldCbtFilter != <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">ASSERT</span>(pWnd != <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">ASSERT</span>(pWnd-&gt;m_hWnd == <span class="literal">NULL</span>);   <span class="comment">// only do once</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">ASSERT</span>(pThreadState-&gt;m_pWndInit == <span class="literal">NULL</span>);   <span class="comment">// hook not already in progress</span></span><br><span class="line">pThreadState-&gt;m_pWndInit = pWnd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><div class="note warning no-icon flat"><p><code>_AFX_THREAD_STATE* pThreadState = _afxThreadState.GetData();</code></p></div><p>这里获取了一个新的全局变量的地址，我们就叫它 <code>线程状态</code> 。</p><div class="note warning no-icon flat"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pThreadState-&gt;m_hHookOldCbtFilter = ::SetWindowsHookEx(WH_CBT,</span><br><span class="line">_AfxCbtFilterHook, NULL, ::GetCurrentThreadId());</span><br></pre></td></tr></table></figure></div><p>这里通过调用 <code>SetWindowsHookEx</code> ，告知 Windows，当前线程一旦收到某些消息时，提前回调 <code>_AfxCbtFilterHook</code>  函数，而 <code>WM_CREATE</code>  消息就在此列。<br> <code>_AfxCbtFilterHook</code>  又是 MFC 提供的全局函数，那么自当前函数调用完成后，消息处理权再次被 MFC 抓到了手里。</p><div class="note warning no-icon flat"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pThreadState-&gt;m_pWndInit = pWnd;</span><br></pre></td></tr></table></figure></div><p>使全局变量 <code>线程状态</code> 的成员 <code>m_pWndInit</code>  我们 new 出来的指向 <code>frame</code>  对象。<br>即设置<strong>待初始化窗口</strong>。</p><p>再次回到 <code>CWnd::CreateEx</code>  函数。</p><div class="note warning no-icon flat"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HWND hWnd = CreateWindowEx(cs.dwExStyle, cs.lpszClass,</span><br><span class="line">cs.lpszName, cs.style, cs.x, cs.y, cs.cx, cs.cy,</span><br><span class="line">cs.hwndParent, cs.hMenu, cs.hInstance, cs.lpCreateParams);</span><br></pre></td></tr></table></figure></div><p>这一行就没有什么好说的了，创建窗口，同时会产生 <code>WM_CREATE</code>  消息，就会回调到 <code>_AfxCbtFilterHook</code> 。</p><p>所以我们要继续分析 <code>_AfxCbtFilterHook</code> ，以得知 MFC 如何处理消息。</p><h2 id="mfc指定的消息钩子回调_afxcbtfilterhook"><a class="markdownIt-Anchor" href="#mfc指定的消息钩子回调_afxcbtfilterhook">#</a> MFC 指定的消息钩子回调： <code>_AfxCbtFilterHook</code></h2><p>经过分析， <code>_AfxCbtFilterHook</code>  的基本工作如下：</p><ol><li>为 <code>frame</code>  和窗口句柄建立映射关系<ul><li>通过全局变量 <code>线程状态</code> 的成员 <code>m_pWndInit</code> ，得到 <code>frame</code> 。</li><li>通过窗口句柄查找对应的 <code>CWnd</code>  对象，由 <code>CHandleMap</code>  类实现<ul><li><strong>模块线程状态</strong>的成员 <code>m_pmapHWND</code>  指向了一个映射类对象，负责管理 <code>HWND</code>  到 <code>CWnd*</code>  的映射。</li></ul></li></ul></li><li>调用 <code>SetWindowLongPtr</code> ，为新创建的窗口设置新的窗口过程函数： <code>AfxWndProc</code> 。</li></ol><p>即完成了对<strong>待初始化窗口</strong>的初始化工作。</p><p>具体代码就留给读者自行阅读了。</p><h1 id="框架窗口类的消息接收"><a class="markdownIt-Anchor" href="#框架窗口类的消息接收">#</a> 框架窗口类的消息接收</h1><p>我们已经知晓窗口的窗口过程函数实际上是 <code>AfxWndProc</code> ，但这是 MFC 提供的全局函数，我们如何处理消息呢？</p><p>实际上，MFC 在 <code>AfxWndProc</code>  函数中，调用了 <code>CWnd</code>  类的 <code>WindowProc</code>  成员虚函数，因此，我们只需要重写该虚函数，就能拿到消息的处理权。</p><details class="folding-tag" blue><summary> 示例 </summary>              <div class='content'>              <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;afxwin.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CMyFrameWnd</span> :<span class="keyword">public</span> CFrameWnd &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> LRESULT <span class="title">WindowProc</span><span class="params">(UINT msgID, WPARAM wParam, LPARAM lParam)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (msgID) &#123;</span><br><span class="line">        <span class="keyword">case</span> WM_CREATE: &#123;</span><br><span class="line">            <span class="built_in">AfxMessageBox</span>(<span class="string">L&quot;WM_CREATE&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> CFrameWnd::<span class="built_in">WindowProc</span>(msgID, wParam, lParam);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CMyWinApp</span> :<span class="keyword">public</span> CWinApp &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CMyWinApp</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> BOOL <span class="title">InitInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CMyFrameWnd* frame = <span class="keyword">new</span> CMyFrameWnd;</span><br><span class="line">        frame-&gt;<span class="built_in">Create</span>(<span class="literal">nullptr</span>, <span class="string">L&quot;MFCBase&quot;</span>);</span><br><span class="line">        m_pMainWnd = frame;</span><br><span class="line">        frame-&gt;<span class="built_in">ShowWindow</span>(SW_SHOW);</span><br><span class="line">        frame-&gt;<span class="built_in">UpdateWindow</span>();</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">CMyWinApp g_theApp;</span><br></pre></td></tr></table></figure>              </div>            </details><p>代码即重写了 <code>WindowProc</code>  成员虚函数，并在收到 <code>WM_CREATE</code>  消息时弹出信息框。</p><p>调试程序，会弹出信息框，内容是 <code>WM_CREATE</code> ，按下确定后，窗口才会出现。</p><h2 id="mfc是如何找到我们的框架窗口类对象的"><a class="markdownIt-Anchor" href="#mfc是如何找到我们的框架窗口类对象的">#</a> MFC 是如何找到我们的框架窗口类对象的？</h2><p>我们的框架窗口类是一个全局对象，<emp>在窗口过程函数中，MFC是如何找到我们创建的对象，并调用其成员函数的呢？</emp></p><p>还记得窗口过程的函数原型吗？第一个参数是类型为 <code>HWND</code>  的窗口句柄；<br>而我们在之前讲过，<strong>模块线程状态</strong>的成员 <code>m_pmapHWND</code>  指向了一个映射类对象，而 <code>_AfxCbtFilterHook</code>  函数中，会基于此映射类对象，维护从 <code>HWND</code>  到 <code>CWnd*</code>  的映射表。<br>MFC 在需要通过 <code>HWND</code>  查找到对应窗口类对象的地址时，也只需要访问这个映射类对象即可。</p><p>得到 <code>frame</code>  的地址后，就可以以此调用 <code>WindowProc</code>  成员虚函数。</p>]]></content>
      
      
      <categories>
          
          <category> MFC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MFC </tag>
            
            <tag> 没饭吃 </tag>
            
            <tag> C++ </tag>
            
            <tag> 界面开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MFC】探索程序启动机制的实现原理</title>
      <link href="/posts/a6e.html"/>
      <url>/posts/a6e.html</url>
      
        <content type="html"><![CDATA[<h1 id="全局对象的构造"><a class="markdownIt-Anchor" href="#全局对象的构造">#</a> 全局对象的构造</h1><p>C++ 的对象在创建时，会调用构造函数。<br>而全局对象的构造时机，<emp>自然应当在入口函数`main/WinMain`被调用之前</emp>，否则我们也就无法在入口函数中使用全局对象了。</p><p>这里以上节编写的示例代码为例，我们在代码中实例化了一个全局对象 <code>g_theApp</code> ，基于 VS 强大的源码调试能力，我们来对 MFC 程序的启动机制一探究竟。</p><details class="folding-tag" blue><summary> 示例 </summary>              <div class='content'>              <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;afxwin.h&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CMyFrameWnd</span> :<span class="keyword">public</span> CFrameWnd &#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CMyWinApp</span> :<span class="keyword">public</span> CWinApp &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CMyWinApp</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> BOOL <span class="title">InitInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CMyFrameWnd* frame = <span class="keyword">new</span> CMyFrameWnd;</span><br><span class="line">        frame-&gt;<span class="built_in">Create</span>(<span class="literal">nullptr</span>, <span class="string">L&quot;MFCBase&quot;</span>);</span><br><span class="line">        m_pMainWnd = frame;</span><br><span class="line">        frame-&gt;<span class="built_in">ShowWindow</span>(SW_SHOW);</span><br><span class="line">        frame-&gt;<span class="built_in">UpdateWindow</span>();</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">CMyWinApp g_theApp;</span><br></pre></td></tr></table></figure>              </div>            </details><h2 id="g_theapp构造调试"><a class="markdownIt-Anchor" href="#g_theapp构造调试">#</a>  <code>g_theApp</code>  构造调试</h2><ol><li>让光标停留在 <code>CMyWinApp g_theApp;</code>  行，按下 <code>F9</code> ，设置断点<ul><li><img src="/posts/a6e/1.png" class="" title="这是一张图片"></li></ul></li><li><code>F5</code>  运行，让程序中断到当前行</li><li><code>F11</code>  单步步入，进入到 <code>CMyWinApp</code>  的构造函数中</li><li>继续单步步入，进入到基类 <code>CWinApp</code>  的构造函数中</li></ol><p>到这里，我们就开始调试到 MFC 的源码了。</p><h2 id="g_theapp构造分析"><a class="markdownIt-Anchor" href="#g_theapp构造分析">#</a>  <code>g_theApp</code>  构造分析</h2><p>接下来我们选择部分代码进行讲解</p><details class="folding-tag" blue><summary> CWinApp::CWinApp 部分代码一 </summary>              <div class='content'>              <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">CWinApp::<span class="built_in">CWinApp</span>(LPCTSTR lpszAppName)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (lpszAppName != <span class="literal">NULL</span>)</span><br><span class="line">        m_pszAppName = _tcsdup(lpszAppName);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        m_pszAppName = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// initialize CWinThread state</span></span><br><span class="line">    AFX_MODULE_STATE* pModuleState = _AFX_CMDTARGET_GETSTATE();</span><br><span class="line">    <span class="built_in">ENSURE</span>(pModuleState);</span><br><span class="line">    AFX_MODULE_THREAD_STATE* pThreadState = pModuleState-&gt;m_thread;</span><br><span class="line">    <span class="built_in">ENSURE</span>(pThreadState);</span><br><span class="line">    <span class="built_in">ASSERT</span>(<span class="built_in">AfxGetThread</span>() == <span class="literal">NULL</span>);</span><br><span class="line">    pThreadState-&gt;m_pCurrentWinThread = <span class="keyword">this</span>;</span><br><span class="line">    <span class="built_in">ASSERT</span>(<span class="built_in">AfxGetThread</span>() == <span class="keyword">this</span>);</span><br><span class="line">    m_hThread = ::<span class="built_in">GetCurrentThread</span>();</span><br><span class="line">    m_nThreadID = ::<span class="built_in">GetCurrentThreadId</span>();</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure>              </div>            </details><div class="note warning no-icon flat"><p><code>AFX_MODULE_STATE* pModuleState = _AFX_CMDTARGET_GETSTATE();</code></p></div><p>MFC 类库中有一个描述<strong>主模块状态</strong>的全局对象， <code>_AFX_CMDTARGET_GETSTATE</code>  宏函数就是用于获取该全局对象的地址</p><div class="note warning no-icon flat"><p><code>AFX_MODULE_THREAD_STATE* pThreadState = pModuleState-&gt;m_thread;</code></p></div><p>以及描述<strong>主模块线程状态</strong>的全局对象，其地址保存在<strong>主模块状态</strong>中的成员中。</p><div class="tip "><p>MFC 在设计时想必已经安排好了构造顺序已确保程序运行的正确性，此处我们的全局对象 <code>g_theApp</code>  的父类部分 <code>CWinApp</code>  在构造时才能够正确使用这些全局对象，这里不再做深究。</p></div><div class="note warning no-icon flat"><p><code>pThreadState-&gt;m_pCurrentWinThread = this;</code></p></div><p>将我们创建的 <code>g_theApp</code>  的地址保存到<strong>主模块线程状态</strong>的 <code>m_pCurrentWinThread</code>  成员中。</p><details class="folding-tag" blue><summary> CWinApp::CWinApp 部分代码二 </summary>              <div class='content'>              <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// initialize CWinApp state</span></span><br><span class="line"><span class="built_in">ASSERT</span>(afxCurrentWinApp == <span class="literal">NULL</span>); <span class="comment">// only one CWinApp object please</span></span><br><span class="line">pModuleState-&gt;m_pCurrentWinApp = <span class="keyword">this</span>;</span><br><span class="line"><span class="built_in">ASSERT</span>(<span class="built_in">AfxGetApp</span>() == <span class="keyword">this</span>);</span><br><span class="line">......</span><br></pre></td></tr></table></figure>              </div>            </details><div class="note warning no-icon flat"><p><code>pModuleState-&gt;m_pCurrentWinApp = this;</code></p></div><p>将我们创建的 <code>g_theApp</code>  的地址保存到<strong>主模块状态</strong>的 <code>m_pCurrentWinApp</code>  成员中。</p><hr><h1 id="winmain的启动流程"><a class="markdownIt-Anchor" href="#winmain的启动流程">#</a> WinMain 的启动流程</h1><p>回忆我们的 <code>CMyWinApp</code>  类，在类中我们重写了虚函数 <code>InitInstance</code> 。<br>见名知意，我们猜测，这是一个初始化函数，但是我们不清楚函数是何时、如何被调用，因此我们需要继续分析 MFC 的源码。</p><h2 id="initinstance回调调试"><a class="markdownIt-Anchor" href="#initinstance回调调试">#</a>  <code>InitInstance</code>  回调调试</h2><ol><li>在 <code>CMyFrameWnd* frame = new CMyFrameWnd;</code>  行设置断点</li><li>运行程序，中断在此行</li><li>查看 <code>调用堆栈</code> ，我们可以看到 <code>InitInstance</code>  的调用函数，以及调用函数的调用函数… 等层级关系。<ul><li>在这里我们也看到了我们熟悉的 <code>WinMain</code>  函数，说明 <code>InitInstance</code>  是在 <code>WinMain</code>  执行过程中被调用的。</li><li>而我们并没有实现 <code>WinMain</code> ，那么 <code>WinMain</code>  自然也是由 MFC 实现的，至此，我们先前的一个疑惑也解决了。</li></ul></li><li>从 <code>调用堆栈</code> 中定位到 <code>WinMain</code>  函数，在此处设置断点，重新运行程序。<ul><li><img src="/posts/a6e/2.png" class="" title="这是一张图片"></li></ul></li><li><code>WinMain</code>  函数中仅有一行代码，即调用 <code>AfxWinMain</code>  并返回，单步进入</li></ol><h2 id="afxwinmain源码分析"><a class="markdownIt-Anchor" href="#afxwinmain源码分析">#</a>  <code>AfxWinMain</code>  源码分析</h2><p>我们依旧选择我们感兴趣的源码进行讲解</p><p><code>AfxWinMain</code>  是 MFC 实现的全局函数。</p><div class="tip "><p>以 <code>Afx</code>  开头的函数，基本上都是 MFC 实现的全局函数。</p></div><details class="folding-tag" blue><summary> AfxWinMain 部分代码 </summary>              <div class='content'>              <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> AFXAPI <span class="title">AfxWinMain</span><span class="params">(HINSTANCE hInstance, HINSTANCE hPrevInstance,</span></span></span><br><span class="line"><span class="params"><span class="function">_In_ LPTSTR lpCmdLine, <span class="type">int</span> nCmdShow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">ASSERT</span>(hPrevInstance == <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> nReturnCode = <span class="number">-1</span>;</span><br><span class="line">CWinThread* pThread = <span class="built_in">AfxGetThread</span>();</span><br><span class="line">CWinApp* pApp = <span class="built_in">AfxGetApp</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// AFX internal initialization</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">AfxWinInit</span>(hInstance, hPrevInstance, lpCmdLine, nCmdShow))</span><br><span class="line"><span class="keyword">goto</span> InitFailure;</span><br><span class="line"></span><br><span class="line"><span class="comment">// App global initializations (rare)</span></span><br><span class="line"><span class="keyword">if</span> (pApp != <span class="literal">NULL</span> &amp;&amp; !pApp-&gt;<span class="built_in">InitApplication</span>())</span><br><span class="line"><span class="keyword">goto</span> InitFailure;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Perform specific initializations</span></span><br><span class="line"><span class="keyword">if</span> (!pThread-&gt;<span class="built_in">InitInstance</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (pThread-&gt;m_pMainWnd != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">TRACE</span>(traceAppMsg, <span class="number">0</span>, <span class="string">&quot;Warning: Destroying non-NULL m_pMainWnd\n&quot;</span>);</span><br><span class="line">pThread-&gt;m_pMainWnd-&gt;<span class="built_in">DestroyWindow</span>();</span><br><span class="line">&#125;</span><br><span class="line">nReturnCode = pThread-&gt;<span class="built_in">ExitInstance</span>();</span><br><span class="line"><span class="keyword">goto</span> InitFailure;</span><br><span class="line">&#125;</span><br><span class="line">nReturnCode = pThread-&gt;<span class="built_in">Run</span>();</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure>              </div>            </details><div class="note warning no-icon flat"><p><code>CWinThread* pThread = AfxGetThread();</code></p></div><p>此函数获取<strong>主模块线程状态</strong>的 <code>m_pCurrentWinThread</code>  成员。<br>先前我们在构造 <code>g_theApp</code>  的过程中已经看到，<strong>主模块线程状态</strong>的 <code>m_pCurrentWinThread</code>  成员保存的是 <code>g_theApp</code>  的地址；<br>因此，此函数实际上是获取 <code>g_theApp</code>  的地址，也就是说，在 MFC 的启动流程中，可能要使用我们创建的全局对象 <code>g_theApp</code> 。</p><div class="note warning no-icon flat"><p><code>CWinApp* pApp = AfxGetApp();</code></p></div><p>此函数获取<strong>主模块状态</strong>的 <code>m_pCurrentWinApp</code>  成员。<br>先前我们在构造 <code>g_theApp</code>  的过程中已经看到，<strong>主模块状态</strong>的 <code>m_pCurrentWinApp</code>  成员保存的是 <code>g_theApp</code>  的地址；<br>与 AfxGetThread 作用类似。</p><div class="tip "><p><code>CWinApp*</code>  指向 <code>CMyWinApp</code>  类型的对象，我们是能够理解的；<br>但是为什么 <code>CWinThread*</code>  的赋值也能被允许呢？因为 <code>CWinApp</code>  类就继承自 <code>CWinThread</code>  类。</p></div><div class="note warning no-icon flat"><p><code>if (pApp != NULL &amp;&amp; !pApp-&gt;InitApplication())</code></p></div><p>当前行实际上调用了 <code>g_theApp</code>  的 <code>InitApplication</code>  函数，我们并没有提供此函数，因此只可能是 <code>g_theApp</code>  的父类部分提供的。<br>这个函数实际上也是虚函数，我们能够重写它，一般在我们希望做一些应用程序初始化的工作时重写。</p><div class="note warning no-icon flat"><p><code>if (!pThread-&gt;InitInstance())</code></p></div><p>终于又到了我们熟悉的部分了， <code>InitInstance</code>  就是我们重写的函数，此时 <code>pThread</code>  指向 <code>g_theApp</code> ，这就是 <code>多态</code> 了。</p><details class="folding-tag" blue><summary> CMyWinApp::InitInstance </summary>              <div class='content'>              <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> BOOL <span class="title">InitInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CMyFrameWnd* frame = <span class="keyword">new</span> CMyFrameWnd;</span><br><span class="line">    frame-&gt;<span class="built_in">Create</span>(<span class="literal">nullptr</span>, <span class="string">L&quot;MFCBase&quot;</span>);</span><br><span class="line">    m_pMainWnd = frame;</span><br><span class="line">    frame-&gt;<span class="built_in">ShowWindow</span>(SW_SHOW);</span><br><span class="line">    frame-&gt;<span class="built_in">UpdateWindow</span>();</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><p>我们暂时略过具体代码，最终是通过 <code>return TRUE</code>  返回的；</p><div class="note warning no-icon flat"><p><code>nReturnCode = pThread-&gt;Run();</code></p></div><p>根据 <code>AfxWinMain</code>  中的代码的逻辑，我们会走到 <code>Run</code>  这个函数。</p><hr><h1 id="不可或缺的消息循环"><a class="markdownIt-Anchor" href="#不可或缺的消息循环">#</a> 不可或缺的消息循环</h1><p>在直接使用 <code>Win32API</code>  开发界面程序时，我们都会编写消息循环以阻塞主线程，避免 <code>WinMain</code>  返回后终止进程。<br>MFC 程序自然也不例外，而 MFC 的消息循环究竟编写在哪里呢？<br>其实读者只要在调试时步过 <code>nReturnCode = pThread-&gt;Run();</code> ，就会使得程序直接运行起来，不再处于中断状态，因而得知， <code>Run</code>  成员函数封装了消息循环。</p><h2 id="cwinapprun的源码分析"><a class="markdownIt-Anchor" href="#cwinapprun的源码分析">#</a>  <code>CWinApp::Run</code>  的源码分析</h2><details class="folding-tag" blue><summary> CWinApp::Run </summary>              <div class='content'>              <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">CWinApp::Run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (m_pMainWnd == <span class="literal">NULL</span> &amp;&amp; <span class="built_in">AfxOleGetUserCtrl</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Not launched /Embedding or /Automation, but has no main window!</span></span><br><span class="line"><span class="built_in">TRACE</span>(traceAppMsg, <span class="number">0</span>, <span class="string">&quot;Warning: m_pMainWnd is NULL in CWinApp::Run - quitting application.\n&quot;</span>);</span><br><span class="line"><span class="built_in">AfxPostQuitMessage</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> CWinThread::<span class="built_in">Run</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><div class="note warning no-icon flat"><p><code>if (m_pMainWnd == NULL &amp;&amp; AfxOleGetUserCtrl())</code></p></div><p>我们忽略对 <code>AfxOleGetUserCtrl</code>  函数的调用， <code>m_pMainWnd</code>  是不是有些眼熟？<br>我们在重写 <code>InitInstance</code>  时，使 <code>m_pMainWnd</code>  指向了 <code>new</code>  出来的 <code>CMyFrameWnd</code>  对象。<br>而我们在调用 <code>Run</code>  成员函数时，就是以 <code>g_theApp</code>  的身份进行调用的。<br>因此，在 <code>Run</code>  成员函数中访问 <code>m_pMainWnd</code> ，自然得到我们当时 <code>new</code>  出来的 <code>CMyFrameWnd</code>  对象。</p><emp>这也就是 g_theApp 全局对象的主窗口。</emp><div class="note warning no-icon flat"><p><code>return CWinThread::Run();</code></p></div><p>接下来我们调用 <code>CWinApp</code>  的父类 <code>CWinThread</code>  的 <code>Run</code>  成员函数</p><details class="folding-tag" blue><summary> CWinThread::Run 第一部分 </summary>              <div class='content'>              <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">CWinThread::Run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">ASSERT_VALID</span>(<span class="keyword">this</span>);</span><br><span class="line">_AFX_THREAD_STATE* pState = <span class="built_in">AfxGetThreadState</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// for tracking the idle time state</span></span><br><span class="line">BOOL bIdle = TRUE;</span><br><span class="line">LONG lIdleCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// acquire and dispatch messages until a WM_QUIT message is received.</span></span><br><span class="line"><span class="keyword">for</span> (;;)        <span class="comment">// 开始消息循环</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果没有消息(PeekMessage返回0)</span></span><br><span class="line"><span class="comment">// phase1: check to see if we can do idle work</span></span><br><span class="line"><span class="keyword">while</span> (bIdle &amp;&amp;</span><br><span class="line">!::<span class="built_in">PeekMessage</span>(&amp;(pState-&gt;m_msgCur), <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, PM_NOREMOVE))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// call OnIdle while in bIdle state</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">OnIdle</span>(lIdleCount++))      <span class="comment">// 调用成员虚函数OnIdle，进入空闲处理</span></span><br><span class="line">bIdle = FALSE; <span class="comment">// assume &quot;no idle&quot; state</span></span><br><span class="line">&#125;</span><br><span class="line">        ......</span><br></pre></td></tr></table></figure>              </div>            </details><p>代码并不复杂，这里直接在代码中注释，可以自行阅读。</p><div class="tip "><p>在 MFC 中程序中调用 <code>Win32API</code>  时，通常都会指明调用的是全局作用域下的函数 :: 。</p></div><details class="folding-tag" blue><summary> CWinThread::Run 第二部分 </summary>              <div class='content'>              <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">        ......</span><br><span class="line"><span class="comment">// phase2: pump messages while available</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// pump message, but quit on WM_QUIT</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">PumpMessage</span>())</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">ExitInstance</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// reset &quot;no idle&quot; state after pumping &quot;normal&quot; message</span></span><br><span class="line"><span class="comment">//if (IsIdleMessage(&amp;m_msgCur))</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">IsIdleMessage</span>(&amp;(pState-&gt;m_msgCur)))</span><br><span class="line">&#123;</span><br><span class="line">bIdle = TRUE;</span><br><span class="line">lIdleCount = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">while</span> (::<span class="built_in">PeekMessage</span>(&amp;(pState-&gt;m_msgCur), <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, PM_NOREMOVE));        <span class="comment">// 如果连续有消息就继续处理</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><p><code>if (!PumpMessage())</code> <br> MFC 在此函数中封装了对 <code>GetMessage</code> 、 <code>TranslateMessage</code> 、 <code>DispatchMessage</code>  函数的调用，读者感兴趣可以自行跟进，这里就不再分析了。</p><p>一旦 <code>PumpMessage</code>  返回 <code>FALSE</code> ，就会调用虚成员函数 <code>ExitInstance</code>  并退出消息循环。<br>而 <code>PumpMessage</code>  返回 <code>FALSE</code>  的条件即是 <code>GetMessage</code>  获得 <code>WM_QUIT</code>  消息，程序结束。</p><p>我们也可以重写 <code>ExitInstance</code> ，在程序结束前做必要的资源释放。</p><p>从 <code>Run</code>  成员函数返回后，也会一路返回到 <code>WinMain</code> ，程序也就退出了。</p><h1 id="基本流程"><a class="markdownIt-Anchor" href="#基本流程">#</a> 基本流程</h1><ol><li><p>首先，我们在编写 MFC 应用时，需要实例化一个类型为 <code>CWinApp</code>  的全局对象。</p><ul><li>如果需要重写初始化等成员虚函数，则需要创建继承自 <code>CWinApp</code>  的子类的对象 (此处命名为 <code>g_theApp</code> )。</li></ul></li><li><p>在 <code>g_theApp</code>  被构造时，会使 MFC 定义的全局变量<strong>主模块状态</strong>和<strong>主模块线程状态</strong>的成员指向 <code>g_theApp</code>  地址。</p></li><li><p>程序进入 <code>WinMain</code>  函数，会通过全局变量<strong>主模块状态</strong>和<strong>主模块线程状态</strong>得到 <code>g_theApp</code>  地址，再以 <code>g_theApp</code>  的身份调用必要的成员虚函数。</p><ul><li>初始化</li><li>消息循环</li><li>退出</li></ul></li></ol><p>至此，我们基本上对 MFC 程序的启动流程有了一个大致的认知。</p><p>而窗口的创建、消息的接收处理等部分，我们留到下一篇再叙。</p>]]></content>
      
      
      <categories>
          
          <category> MFC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MFC </tag>
            
            <tag> 没饭吃 </tag>
            
            <tag> C++ </tag>
            
            <tag> 界面开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MFC】初识MFC</title>
      <link href="/posts/7c79.html"/>
      <url>/posts/7c79.html</url>
      
        <content type="html"><![CDATA[<h1 id="mfc简述"><a class="markdownIt-Anchor" href="#mfc简述">#</a> MFC 简述</h1><p><strong>MFC (Microsoft Foundation Classes)，微软基础类库；</strong><br>是微软使用 <code>C++</code>  的特性，在 <code>Win32API</code>  基础上再次进行的封装。</p><hr><h1 id="mfc基本使用"><a class="markdownIt-Anchor" href="#mfc基本使用">#</a> MFC 基本使用</h1><p>MFC 只是一个 C++ 类库，我们只需要对 C++ 有一定了解，就能够理解 MFC 的工作机制。<br>而微软的宇宙第一 IDE <code>Visual Studio</code>  本身也替我们做好了许多工作，这里以 vs2022 为例，对 MFC 的安装与使用进行简单的说明。</p><h2 id="安装"><a class="markdownIt-Anchor" href="#安装">#</a> 安装</h2><ol><li>运行 <code>Visual Studio Installer</code><ul><li><img src="/posts/7c79/1.png" class="" title="这是一张图片"></li></ul></li><li>点击 <code>修改</code></li><li>选择 <code>单个组件</code> 选项卡</li><li>搜索 <code>MFC</code> ，勾选需要的组件<ul><li><img src="/posts/7c79/2.png" class="" title="这是一张图片"></li></ul></li><li>点击 <code>修改</code> ，等待完成即可<ul><li>我这里已经装过了，就不重新做演示了</li></ul></li></ol><h2 id="新建项目"><a class="markdownIt-Anchor" href="#新建项目">#</a> 新建项目</h2><ol><li>运行 <code>Visual Studio 2022</code></li><li>点击 <code>创建新项目</code></li><li>选择 <code>空项目</code></li><li>项目名称随意，我这里写 <code>MFCTestProject</code></li></ol><h2 id="配置项目"><a class="markdownIt-Anchor" href="#配置项目">#</a> 配置项目</h2><p>由于是空项目，什么都没有，我们需要自行做一些必要的设置。</p><ol><li>右键 <code>MFCTestProject</code>  项目，选择 <code>属性</code></li><li><code>属性页</code> 中选择 <code>高级</code> 选项卡</li><li><code>MFC的使用</code> 选项，修改为 <code>在静态库中使用MFC</code><ul><li><code>在共享DLL中使用MFC</code>  调试时无法找到 MFC 的源码。</li></ul></li><li><code>属性页</code> 中展开 <code>链接器</code> ，选择 <code>系统</code> 选项卡</li><li><code>子系统</code> 选择 <code>窗口(/SUBSYSTEM:WINDOWS)</code></li></ol><h2 id="编写源代码"><a class="markdownIt-Anchor" href="#编写源代码">#</a> 编写源代码</h2><ol><li>新建 <code>.cpp</code>  文件，文件名随意</li><li>编写如下示例代码 <details class="folding-tag" blue><summary> 示例 </summary>              <div class='content'>              <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;afxwin.h&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CMyFrameWnd</span> :<span class="keyword">public</span> CFrameWnd &#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CMyWinApp</span> :<span class="keyword">public</span> CWinApp &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CMyWinApp</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> BOOL <span class="title">InitInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CMyFrameWnd* frame = <span class="keyword">new</span> CMyFrameWnd;</span><br><span class="line">        frame-&gt;<span class="built_in">Create</span>(<span class="literal">nullptr</span>, <span class="string">L&quot;MFCBase&quot;</span>);</span><br><span class="line">        m_pMainWnd = frame;</span><br><span class="line">        frame-&gt;<span class="built_in">ShowWindow</span>(SW_SHOW);</span><br><span class="line">        frame-&gt;<span class="built_in">UpdateWindow</span>();</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">CMyWinApp g_theApp;</span><br></pre></td></tr></table></figure>              </div>            </details></li><li>F5 运行，编译运行正常会出现这样的窗口<ul><li><img src="/posts/7c79/3.png" class="" title="这是一张图片"></li></ul></li></ol><p>至此，我们就已经建立了一个非常简单的 MFC 程序，并且它还能够运行。</p><h1 id="源代码注释"><a class="markdownIt-Anchor" href="#源代码注释">#</a> 源代码注释</h1><p>接下来我们简单对代码进行一些注释：</p><div class="note warning no-icon flat"><p><code>#include &lt;afxwin.h&gt;</code></p></div><p>类似 <code>Win32API</code>  开发时使用的 <code>#include &lt;windows.h&gt;</code></p><div class="note warning no-icon flat"><p><code>class CMyFrameWnd :public CFrameWnd {...</code></p></div><p>创建继承于 <code>CFrameWnd</code>  类的 <code>CMyFrameWnd</code>  类<br> <code>CFrameWnd</code>  是对窗口框架的封装</p><div class="note warning no-icon flat"><p><code>class CMyWinApp :public CWinApp {...</code></p></div><p>创建继承于 <code>CWinApp</code>  类的 <code>CMyWinApp</code>  类<br> <code>CWinApp</code>  是对应用程序执行流程的抽象封装</p><div class="note warning no-icon flat"><p><code>virtual BOOL InitInstance() {...</code></p></div><p>在 <code>CMyWinApp</code>  类中重写 <code>CWinApp</code>  类的 <code>InitInstance</code>  成员虚函数</p><div class="note warning no-icon flat"><p><code>CMyWinApp g_theApp;</code></p></div><p>基于 <code>CMyWinApp</code>  类实例化全局对象 <code>g_theApp</code></p><div class="note purple icon-padding simple"><i class="note-icon fas fa-fan"></i><p>当然，这些代码也许会使你感到困惑，毕竟代码中甚至找不到你最熟悉的 main、WinMain，为什么它能够跑起来？</p><p>我们将在下篇文章探索 MFC 的程序启动机制。</p></div><hr>]]></content>
      
      
      <categories>
          
          <category> MFC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MFC </tag>
            
            <tag> 没饭吃 </tag>
            
            <tag> C++ </tag>
            
            <tag> 界面开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MFC】前言</title>
      <link href="/posts/6339.html"/>
      <url>/posts/6339.html</url>
      
        <content type="html"><![CDATA[<p>当前分类所收录的文章主要是我个人学习 MFC 时记录的读书笔记。</p><blockquote><p>主要参考资料<br><a href="https://www.bilibili.com/video/BV1mU4y1C7XA/?p=14&amp;spm_id_from=333.999.header_right.history_list.click&amp;vd_source=2f16cbe6e2d0a9708b5b399c0b862fe3"> C++ 之 MFC 全套教程</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> MFC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MFC </tag>
            
            <tag> 没饭吃 </tag>
            
            <tag> C++ </tag>
            
            <tag> 界面开发 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title></title>
      <link href="/manifest.json"/>
      <url>/manifest.json</url>
      
        <content type="html"><![CDATA[{"name":"鹿鹿鱼鱼","short_name":"鹿鹿鱼鱼","theme_color":"#425aef","background_color":"#425aef","display":"standalone","scope":"/","start_url":"/","icons":[{"src":"/img/siteicon/16.png","sizes":"16x16","type":"image/png"},{"src":"/img/siteicon/32.png","sizes":"32x32","type":"image/png"},{"src":"/img/siteicon/48.png","sizes":"48x48","type":"image/png"},{"src":"/img/siteicon/64.png","sizes":"64x64","type":"image/png"},{"src":"/img/siteicon/128.png","sizes":"128x128","type":"image/png"},{"src":"/img/siteicon/144.png","sizes":"144x144","type":"image/png"},{"src":"/img/siteicon/512.png","sizes":"512x512","type":"image/png"}],"splash_pages":null}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>关于</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<p>关于我？</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/custom.css"/>
      <url>/css/custom.css</url>
      
        <content type="html"><![CDATA[/* @font-face {  font-family: Candyhome;  src: url(https://npm.elemecdn.com/anzhiyu-blog@1.1.6/fonts/Candyhome.ttf);  font-display: swap;  font-weight: lighter;} */@font-face {    font-family: ZhuZiAYuanJWD;    src: url(https://npm.elemecdn.com/anzhiyu-blog@1.1.6/fonts/ZhuZiAWan.woff2);    font-display: swap;    font-weight: lighter;  }    div#menus {    font-family: 'ZhuZiAYuanJWD';  }  h1#site-title {    font-family: ZhuZiAYuanJWD;    font-size: 3em !important;  }  a.article-title,  a.blog-slider__title,  a.categoryBar-list-link,  h1.post-title {    font-family: ZhuZiAYuanJWD;  }    .iconfont {    font-family: 'iconfont' !important;    font-size: 3em;    /* 可以定义图标大小 */    font-style: normal;    -webkit-font-smoothing: antialiased;    -moz-osx-font-smoothing: grayscale;  }    /* 时间轴生肖icon */  svg.icon {    /* 这里定义svg.icon，避免和Butterfly自带的note标签冲突 */    width: 1em;    height: 1em;    /* width和height定义图标的默认宽度和高度*/    vertical-align: -0.15em;    fill: currentColor;    overflow: hidden;  }    .icon-zhongbiao::before {    color: #f7c768;  }    /* bilibli番剧插件 */  #article-container .bangumi-tab.bangumi-active {    background: var(--anzhiyu-theme);    color: var(--anzhiyu-ahoverbg);    border-radius: 10px;  }  a.bangumi-tab:hover {    text-decoration: none !important;  }  .bangumi-button:hover {    background: var(--anzhiyu-theme) !important;    border-radius: 10px !important;    color: var(--anzhiyu-ahoverbg) !important;  }  a.bangumi-button.bangumi-nextpage:hover {    text-decoration: none !important;  }  .bangumi-button {    padding: 5px 10px !important;  }    a.bangumi-tab {    padding: 5px 10px !important;  }  svg.icon.faa-tada {    font-size: 1.1em;  }  .bangumi-info-item {    border-right: 1px solid #f2b94b;  }  .bangumi-info-item span{    color: #f2b94b;  }  .bangumi-info-item em{    color: #f2b94b;  }    /* 解决artitalk的图标问题 */  #uploadSource > svg {    width: 1.19em;    height: 1.5em;  }    /*top-img黑色透明玻璃效果移除，不建议加，除非你执着于完全一图流或者背景图对比色明显 */  #page-header:not(.not-top-img):before {    background-color: transparent !important;  }    /* 首页文章卡片 */  #recent-posts > .recent-post-item {    background: rgba(255, 255, 255, 0.9);  }    /* 首页侧栏卡片 */  #aside-content .card-widget {    background: rgba(255, 255, 255, 0.9);  }    /* 文章页面正文背景 */  div#post {    background: rgba(255, 255, 255, 0.9);  }    /* 分页页面 */  div#page {    background: rgba(255, 255, 255, 0.9);  }    /* 归档页面 */  div#archive {    background: rgba(255, 255, 255, 0.9);  }    /* 标签页面 */  div#tag {    background: rgba(255, 255, 255, 0.9);  }    /* 分类页面 */  div#category {    background: rgba(255, 255, 255, 0.9);  }    /*夜间模式伪类遮罩层透明*/  [data-theme='dark'] #recent-posts > .recent-post-item {    background: #121212;  }    [data-theme='dark'] .card-widget {    background: #121212 !important;  }    [data-theme='dark'] div#post {    background: #121212 !important;  }    [data-theme='dark'] div#tag {    background: #121212 !important;  }    [data-theme='dark'] div#archive {    background: #121212 !important;  }    [data-theme='dark'] div#page {    background: #121212 !important;  }    [data-theme='dark'] div#category {    background: #121212 !important;  }    [data-theme='dark'] div#category {    background: transparent !important;  }  /* 页脚透明 */  #footer {    background: transparent !important;  }    /* 头图透明 */  #page-header {    background: transparent !important;  }    #rightside > div > button {    border-radius: 5px;  }    /* 滚动条 */    ::-webkit-scrollbar {    width: 10px;    height: 10px;  }    ::-webkit-scrollbar-thumb {    background-color: #425aef;    border-radius: 2em;  }    ::-webkit-scrollbar-corner {    background-color: transparent;  }    ::-moz-selection {    color: #fff;    background-color: #425aef;  }    /* 音乐播放器 */    /* .aplayer .aplayer-lrc {    display: none !important;  } */    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {    left: -66px !important;    transition: all 0.3s;    /* 默认情况下缩进左侧66px，只留一点箭头部分 */  }    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {    left: 0 !important;    transition: all 0.3s;    /* 鼠标悬停是左侧缩进归零，完全显示按钮 */  }    .aplayer.aplayer-fixed {    z-index: 999999 !important;  }    /* 评论框  */  .vwrap {    box-shadow: 2px 2px 5px #bbb;    background: rgba(255, 255, 255, 0.3);    border-radius: 8px;    padding: 30px;    margin: 30px 0px 30px 0px;  }    /* 设置评论框 */    .vcard {    box-shadow: 2px 2px 5px #bbb;    background: rgba(255, 255, 255, 0.3);    border-radius: 8px;    padding: 30px;    margin: 30px 0px 0px 0px;  }    /* 鼠标图标 */  body {    cursor: url('/img/x1.cur'), auto;  }  a,  [type='button']:not(:disabled),  [type='reset']:not(:disabled),  [type='submit']:not(:disabled),  button:not(:disabled) {    cursor: url('/img/x2.cur'), auto !important;  }  /* md网站下划线 */  #article-container a:hover {    text-decoration: none !important;  }    #article-container #hpp_talk p img {    display: inline;  }    /* 404页面 */  #error-wrap {    position: absolute;    top: 40%;    right: 0;    left: 0;    margin: 0 auto;    padding: 0 1rem;    max-width: 1000px;    transform: translate(0, -50%);  }    #error-wrap .error-content {    display: flex;    flex-direction: row;    justify-content: center;    align-items: center;    margin: 0 1rem;    height: 18rem;    border-radius: 8px;    background: var(--card-bg);    box-shadow: var(--card-box-shadow);    transition: all 0.3s;  }    #error-wrap .error-content .error-img {    box-flex: 1;    flex: 1;    height: 100%;    border-top-left-radius: 8px;    border-bottom-left-radius: 8px;    background-color: #425aef;    background-position: center;    background-size: cover;  }    #error-wrap .error-content .error-info {    box-flex: 1;    flex: 1;    padding: 0.5rem;    text-align: center;    font-size: 14px;    font-family: Titillium Web, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft JhengHei', 'Microsoft YaHei', sans-serif;  }  #error-wrap .error-content .error-info .error_title {    margin-top: -4rem;    font-size: 9em;  }  #error-wrap .error-content .error-info .error_subtitle {    margin-top: -3.5rem;    word-break: break-word;    font-size: 1.6em;  }  #error-wrap .error-content .error-info a {    display: inline-block;    margin-top: 0.5rem;    padding: 0.3rem 1.5rem;    background: var(--btn-bg);    color: var(--btn-color);  }    #body-wrap.error .aside-list {    display: flex;    flex-direction: row;    flex-wrap: nowrap;    bottom: 0px;    position: absolute;    padding: 1rem;    width: 100%;    overflow: scroll;  }    #body-wrap.error .aside-list .aside-list-group {    display: flex;    flex-direction: row;    flex-wrap: nowrap;    max-width: 1200px;    margin: 0 auto;  }    #body-wrap.error .aside-list .aside-list-item {    padding: 0.5rem;  }    #body-wrap.error .aside-list .aside-list-item img {    width: 100%;    -o-object-fit: cover;       object-fit: cover;    border-radius: 12px;  }    #body-wrap.error .aside-list .aside-list-item .thumbnail {    overflow: hidden;    width: 230px;    height: 143px;    background: var(--heo-card-bg);    display: flex;  }    #body-wrap.error .aside-list .aside-list-item .content .title {    -webkit-line-clamp: 2;    overflow: hidden;    display: -webkit-box;    -webkit-box-orient: vertical;    line-height: 1.5;    justify-content: center;    align-items: flex-end;    align-content: center;    padding-top: 0.5rem;    color: white;  }    #body-wrap.error .aside-list .aside-list-item .content time {    display: none;  }    /* 代码框主题 */  #article-container figure.highlight {    border-radius: 10px;  }  ]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>文章分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/runtime/runtime.min.css"/>
      <url>/css/runtime/runtime.min.css</url>
      
        <content type="html"><![CDATA[div#runtime{width:180px;margin:auto;color:#fff;padding-inline:5px;border-radius:10px;background-color:rgba(0,0,0,.7)}#workboard{font-size:12px}[data-theme=dark] div#runtime{color:#28b4c8;box-shadow:0 0 5px rgba(28,69,218,.71);animation:flashlight 1s linear infinite alternate}#ghbdages .github-badge img{height:20px}@keyframes flashlight{from{box-shadow:0 0 5px #1478d2}to{box-shadow:0 0 2px #1478d2}}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/runtime/runtime.min.js"/>
      <url>/js/runtime/runtime.min.js</url>
      
        <content type="html"><![CDATA[var now = new Date; function createtime() { var t = new Date("10/03/2022 00:00:00"); now.setTime(now.getTime() + 250); var e = (now - t) / 1e3 / 60 / 60 / 24, a = Math.floor(e), n = (now - t) / 1e3 / 60 / 60 - 24 * a, r = Math.floor(n); 1 == String(r).length && (r = "0" + r); var s = (now - t) / 1e3 / 60 - 1440 * a - 60 * r, i = Math.floor(s); 1 == String(i).length && (i = "0" + i); var o = (now - t) / 1e3 - 86400 * a - 3600 * r - 60 * i, l = Math.round(o); 1 == String(l).length && (l = "0" + l); let g = ""; g = r < 18 && r >= 9 ? `<img class='boardsign' src='/img/badge/上班摸鱼中.svg' title='距离月入25k也就还差一个大佬带我~'><span class='textTip'> <br> 本站居然运行了 ${a} 天</span><span id='runtime'> ${r} 小时 ${i} 分 ${l} 秒 </span> <i class='fas fa-heartbeat' style='color:red'></i>` : `<img class='boardsign' src='/img/badge/下班啦.svg' title='下班了就该开开心心的玩耍，嘿嘿~'><span class='textTip'> <br> 本站居然运行了 ${a} 天</span><span id='runtime'> ${r} 小时 ${i} 分 ${l} 秒 </span> <i class='fas fa-heartbeat' style='color:red'></i>`, document.getElementById("workboard") && (document.getElementById("workboard").innerHTML = g) } setInterval((() => { createtime() }), 250);]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/ali_font.js"/>
      <url>/js/ali_font.js</url>
      
        <content type="html"><![CDATA[!function(c){var l,h,a,t,i,v='<svg><symbol id="icon-dragon_chen" viewBox="0 0 1024 1024"><path d="M512 512m-296.421053 0a296.421053 296.421053 0 1 0 592.842106 0 296.421053 296.421053 0 1 0-592.842106 0Z" fill="#D6B196" ></path><path d="M970.105263 512c0 224.983579-163.166316 412.186947-377.263158 450.533053v-54.460632C777.135158 870.507789 916.210526 707.206737 916.210526 512c0-222.881684-181.328842-404.210526-404.210526-404.210526S107.789474 289.118316 107.789474 512s181.328842 404.210526 404.210526 404.210526c9.081263 0 18.000842-0.754526 26.947368-1.374315v53.894736c-8.973474 0.538947-17.866105 1.374316-26.947368 1.374316-252.604632 0-458.105263-205.500632-458.105263-458.105263S259.395368 53.894737 512 53.894737s458.105263 205.500632 458.105263 458.105263z m-498.122105 265.620211L431.157895 754.526316V485.052632h-66.074948c-14.470737 110.645895-44.355368 197.066105-102.696421 260.742736l-39.747368-36.432842C306.526316 617.876211 323.368421 462.901895 323.368421 242.526316V215.578947h377.263158v53.894737H377.182316c-0.404211 58.260211-2.209684 112.128-6.359579 161.684211H700.631579v53.894737h-122.152421a481.172211 481.172211 0 0 0 76.826947 119.70021l66.479158-39.855158 27.728842 46.214737-54.460631 32.687158c29.507368 24.953263 63.757474 45.675789 102.80421 58.098526l-16.303158 51.361684c-134.224842-42.711579-222.773895-167.073684-261.551158-268.207157H485.052632v221.857684l68.985263-41.391158 27.728842 46.214737-109.783579 65.886316zM646.736842 377.263158h-215.578947v-53.894737h215.578947v53.894737z" fill="#231F20" ></path></symbol><symbol id="icon-dog_xu" viewBox="0 0 1024 1024"><path d="M512 512m-296.421053 0a296.421053 296.421053 0 1 0 592.842106 0 296.421053 296.421053 0 1 0-592.842106 0Z" fill="#D6B196" ></path><path d="M970.105263 512c0 224.983579-163.166316 412.186947-377.263158 450.533053v-54.460632C777.135158 870.507789 916.210526 707.206737 916.210526 512c0-222.881684-181.328842-404.210526-404.210526-404.210526S107.789474 289.118316 107.789474 512s181.328842 404.210526 404.210526 404.210526c9.081263 0 18.000842-0.754526 26.947368-1.374315v53.894736c-8.973474 0.538947-17.866105 1.374316-26.947368 1.374316-252.604632 0-458.105263-205.500632-458.105263-458.105263S259.395368 53.894737 512 53.894737s458.105263 205.500632 458.105263 458.105263z m-375.592421 150.393263c33.684211 44.544 75.210105 74.698105 124.739369 90.812632l11.425684 3.718737 10.401684-6.009264C781.204211 727.740632 808.421053 622.565053 808.421053 592.842105h-53.894737c0 22.069895-19.132632 80.869053-33.711158 103.504842-34.816-14.605474-64.538947-39.262316-89.249684-74.13221 48.316632-55.269053 92.079158-117.328842 120.535579-179.900632l-49.044211-22.285473c-23.767579 52.250947-59.742316 104.717474-100.055579 152.656842-24.010105-50.930526-41.148632-115.927579-51.658105-195.395369H700.631579v-53.894737h-155.189895A1848.050526 1848.050526 0 0 1 538.947368 161.684211h-53.894736c0 58.206316 2.155789 112.074105 6.494315 161.68421H323.368421v26.947368c0 216.549053-13.177263 263.545263-100.702316 359.046737l39.747369 36.432842c63.326316-69.093053 92.806737-118.272 105.714526-206.848H485.052632v-53.894736h-111.319579a1742.147368 1742.147368 0 0 0 3.449263-107.789474h120.158316c12.611368 98.250105 35.031579 177.475368 67.395368 238.187789-61.978947 65.536-128.053895 117.975579-173.298526 142.282106l25.519158 47.481263c47.589053-25.573053 114.095158-77.446737 177.55621-142.821053z m125.170526-411.971368l-80.842105-80.842106-38.103579 38.103579 80.842105 80.842106 38.103579-38.103579z" fill="#231F20" ></path></symbol><symbol id="icon-dog" viewBox="0 0 1024 1024"><path d="M894.814316 904.434526l83.240421-183.134315-13.824-13.204211c-0.485053-0.458105-45.648842-47.589053-47.939369-185.263158-0.134737-7.922526-0.134737-33.953684-0.134736-55.996631-30.693053 15.306105-70.090105 19.887158-106.09179 19.887157-92.752842 0-163.624421-23.983158-210.647579-71.275789a192.512 192.512 0 0 1-27.944421-36.513684H377.263158v377.263158c342.662737 0 403.105684 51.092211 494.592 128.377263 7.922526 6.682947 15.521684 13.312 22.959158 19.86021z" fill="#85C3DE" ></path><path d="M326.063158 282.947368c0 34.250105-13.231158 44.463158-29.642105 44.463158s-29.642105-10.213053-29.642106-44.463158c0-34.223158 13.231158-44.463158 29.642106-44.463157s29.642105 10.24 29.642105 44.463157zM269.473684 430.295579v311.646316L190.275368 916.210526h59.203369L323.368421 753.637053V377.263158h-26.947368c-119.403789 0-172.732632-53.382737-185.505685-107.789474h35.624421c51.092211 0 68.581053-15.764211 120.535579-62.544842 12.773053-11.506526 28.079158-25.276632 47.023158-41.741474l18.351158-15.952842-69.658947-99.139368-44.085895 30.989474 41.768421 59.472842c-11.183158 9.862737-20.884211 18.593684-29.480421 26.327579C180.736 212.156632 176.235789 215.578947 146.539789 215.578947H53.894737v26.947369c0 88.710737 66.910316 178.149053 215.578947 187.769263z m216.710737-161.414737c2.290526 71.733895 28.698947 136.326737 75.048421 182.918737C618.711579 509.628632 702.437053 538.947368 810.091789 538.947368c18.593684 0 36.190316-1.158737 52.628211-3.449263 3.745684 111.265684 33.630316 170.334316 51.496421 196.015158l-38.507789 84.722526C782.174316 742.049684 688.774737 700.631579 377.263158 700.631579v53.894737c34.277053 0 65.697684 0.512 94.639158 1.509052L374.595368 970.105263h59.203369l96.013474-211.240421c66.182737 4.338526 117.005474 11.829895 157.911578 22.016L626.229895 916.210526h59.176421l54.16421-119.134315c47.616 18.405053 79.737263 42.091789 113.125053 69.739789L805.753263 970.105263h59.203369l113.071157-248.778105-13.824-13.204211c-0.485053-0.458105-45.648842-47.589053-47.939368-185.263158C985.168842 498.553263 1024 447.811368 1024 377.263158c0-95.205053-66.506105-161.684211-161.684211-161.684211v53.894737c65.482105 0 107.789474 42.307368 107.789474 107.789474 0 89.088-87.013053 107.789474-160.013474 107.789474-92.752842 0-163.624421-23.983158-210.647578-71.27579-30.315789-30.504421-45.891368-65.832421-53.35579-98.735158 11.210105 6.952421 22.932211 13.338947 35.274105 19.186527l23.04-48.720843c-92.106105-43.654737-148.992-128.646737-219.243789-243.981473l-46.026105 28.05221c49.448421 81.246316 92.968421 148.506947 147.051789 199.302737z" fill="#231F20" ></path></symbol><symbol id="icon-goat" viewBox="0 0 1024 1024"><path d="M548.378947 646.736842a952.32 952.32 0 0 1 140.90779-161.68421H107.789474c0 107.600842 0 107.600842-63.649685 169.283368l-13.069473 12.665263L66.721684 754.526316h417.172211c20.345263-41.472 43.654737-77.446737 64.485052-107.789474z" fill="#F7C768" ></path><path d="M608.256 144.734316C555.762526 115.577263 506.098526 107.789474 485.052632 107.789474V53.894737c32.579368 0 91.270737 11.452632 149.369263 43.735579 75.290947 41.822316 130.694737 94.531368 171.385263 150.878316C755.873684 288.013474 697.101474 323.368421 646.736842 323.368421h-107.789474v-53.894737h107.789474c20.506947 0 48.424421-11.210105 80.437895-31.285895a471.04 471.04 0 0 0-118.918737-93.453473zM832.673684 342.231579c-16.384 0-29.642105 10.24-29.642105 44.463158 0 34.250105 13.231158 44.463158 29.642105 44.463158s29.642105-10.213053 29.642105-44.463158c0-34.223158-13.231158-44.463158-29.642105-44.463158zM1024 619.789474C1024 347.109053 901.066105 122.448842 686.753684 3.395368l-26.165895 47.104C914.324211 191.461053 964.688842 440.400842 969.647158 592.842105h-84.506947c-17.92-35.624421-45.352421-69.12-87.013053-101.995789l-16.788211-13.285053-16.734315 13.392842c-66.128842 52.897684-134.629053 127.083789-187.311158 209.677474H102.965895l-8.272842-20.318316C159.043368 617.013895 161.684211 603.109053 161.684211 485.052632v-53.894737h485.052631v-53.894737H161.684211c0-80.384 14.309053-110.026105 66.586947-137.916632l-25.384421-47.535158C123.365053 234.226526 107.789474 291.920842 107.789474 377.263158v107.789474c0 107.600842 0 107.600842-63.649685 169.283368l-13.069473 12.665263L110.618947 862.315789h58.206316l-43.897263-107.789473h103.477895l43.897263 107.789473h58.206316l-43.897263-107.789473h259.47621C508.981895 824.939789 485.052632 899.152842 485.052632 970.105263h53.894736c0-68.688842 27.270737-144.060632 68.958316-215.578947H687.157895c7.410526 0 13.473684 6.063158 13.473684 13.473684V862.315789h53.894737v-94.315789c0-37.160421-30.208-67.368421-67.368421-67.368421h-44.65179c40.771368-58.017684 89.438316-111.427368 138.913684-153.626947C841.512421 600.037053 862.315789 655.225263 862.315789 754.526316h53.894737c0-38.912-2.748632-74.482526-11.102315-107.789474H1024v-26.947368z" fill="#231F20" ></path></symbol><symbol id="icon-goat_wei" viewBox="0 0 1024 1024"><path d="M512 512m-296.421053 0a296.421053 296.421053 0 1 0 592.842106 0 296.421053 296.421053 0 1 0-592.842106 0Z" fill="#D6B196" ></path><path d="M970.105263 512c0 224.983579-163.166316 412.186947-377.263158 450.533053v-54.460632C777.135158 870.507789 916.210526 707.206737 916.210526 512c0-222.881684-181.328842-404.210526-404.210526-404.210526S107.789474 289.118316 107.789474 512s181.328842 404.210526 404.210526 404.210526c9.081263 0 18.000842-0.754526 26.947368-1.374315v53.894736c-8.973474 0.538947-17.866105 1.374316-26.947368 1.374316-252.604632 0-458.105263-205.500632-458.105263-458.105263S259.395368 53.894737 512 53.894737s458.105263 205.500632 458.105263 458.105263z m-431.157895 50.202947c52.304842 70.925474 136.973474 152.144842 232.528843 190.383158l19.994947-50.041263c-109.271579-43.708632-202.805895-152.629895-238.780632-217.49221H808.421053v-53.894737H538.947368v-53.894737h215.578948v-53.894737h-215.578948V161.684211h-53.894736v161.68421h-215.578948v53.894737h215.578948v53.894737H215.578947v53.894737h255.757474c-35.974737 64.862316-129.536 173.783579-238.807579 217.49221l20.021895 50.041263c95.528421-38.238316 180.197053-119.484632 232.501895-190.383158V808.421053h53.894736v-246.218106z" fill="#231F20" ></path></symbol><symbol id="icon-dragon" viewBox="0 0 1024 1024"><path d="M366.376421 344.441263l152.980211-152.98021c43.142737-43.142737 141.204211-9.216 270.201263 115.738947-15.225263 9.835789-25.114947 15.818105-44.13979 32.256s-38.076632 35.489684-59.418947 56.832c-4.203789 4.203789-51.173053 53.221053-78.740211 82.027789-10.805895-12.126316-22.743579-24.171789-34.654315-36.082526L493.136842 362.792421l-54.218105 54.218105-72.542316-72.569263zM862.315789 512c0 46.834526-45.352421 80.842105-107.789473 80.842105-108.948211 0-189.359158-28.806737-267.129263-56.697263C414.100211 509.871158 344.872421 485.052632 258.182737 485.052632 80.788211 485.052632 0 588.126316 0 683.897263h53.894737C73.216 659.779368 135.302737 646.736842 177.340632 646.736842c77.338947 0 223.124211 23.282526 291.893894 47.912421C547.462737 722.701474 615.989895 754.526316 734.315789 754.526316 862.315789 754.526316 916.210526 670.315789 916.210526 512h-53.894737z" fill="#FF8787" ></path><path d="M552.421053 1024c-69.766737 0-113.825684-13.958737-156.402527-27.459368-54.487579-17.273263-110.807579-35.004632-232.421052-26.516211l-3.826527-53.733053c131.718737-9.458526 195.934316 10.967579 252.52379 28.887579 42.226526 13.365895 78.686316 24.926316 140.126316 24.926316 92.752842 0 148.210526-57.936842 148.210526-113.960421 0-16.949895-5.524211-101.618526-114.634105-101.618526-64.970105 0-112.747789 23.336421-163.328 48.02021C365.325474 830.571789 300.301474 862.315789 204.288 862.315789 85.908211 862.315789 0 787.294316 0 683.897263 0 588.126316 80.788211 485.052632 258.182737 485.052632c86.689684 0 155.917474 24.818526 229.214316 51.09221 45.810526 16.410947 92.564211 33.172211 145.488842 44.166737 9.000421-7.033263 13.850947-16.276211 13.850947-26.758737 0-37.187368-37.672421-74.859789-74.13221-111.265684l-3.287579-3.287579 38.103579-38.103579 3.260631 3.287579C652.853895 446.275368 700.631579 494.026105 700.631579 553.552842c0 12.719158-2.802526 24.926316-7.976421 36.109474A594.997895 594.997895 0 0 0 754.526316 592.842105c62.437053 0 107.789474-34.007579 107.789473-80.842105 0-58.853053-52.870737-110.268632-108.840421-164.702316l-8.057263-7.841684c-19.024842 16.437895-38.076632 35.489684-59.418947 56.832l-38.103579-38.103579c74.805895-74.832842 134.898526-134.898526 268.314947-141.931789V55.619368c-63.407158 7.787789-120.993684 39.424-121.667368 39.801264l-15.818105 8.811789-14.120421-11.344842C731.701895 66.452211 709.712842 53.894737 673.684211 53.894737c-41.418105 0-74.347789 25.869474-109.190737 53.301895-26.624 20.911158-54.137263 42.549895-86.851369 53.194105L469.342316 161.684211h-69.093053l-105.525895 105.525894-38.103579-38.130526L324.015158 161.684211H161.684211V107.789474h303.104c22.231579-8.272842 43.708632-25.168842 66.398315-42.981053C569.829053 34.438737 613.618526 0 673.684211 0c48.909474 0 81.408 17.946947 110.888421 40.097684C813.702737 26.300632 877.729684 0 943.157895 0h26.947368v323.368421h-53.894737v-53.167158c-54.164211 3.098947-92.914526 15.845053-127.002947 36.675369l1.832421 1.778526C852.587789 368.505263 916.210526 430.376421 916.210526 512c0 60.928-43.708632 109.945263-107.789473 127.622737V700.631579h53.894736v-53.894737h53.894737v53.894737h53.894737v53.894737h-53.894737v53.894737h-53.894737v-53.894737h-53.894736c-29.722947 0-53.894737-24.171789-53.894737-53.894737v-53.894737c-118.325895 0-207.063579-31.797895-285.318737-59.877053C400.437895 562.229895 335.494737 538.947368 258.182737 538.947368 117.059368 538.947368 53.894737 611.732211 53.894737 683.897263 53.894737 757.221053 115.738947 808.421053 204.288 808.421053c11.910737 0 23.228632-0.538947 34.034526-1.536C248.454737 796.321684 269.473684 770.640842 269.473684 739.166316c0-33.118316-43.088842-70.979368-58.152421-81.596632l30.935579-44.139789c8.299789 5.793684 81.111579 58.664421 81.111579 125.736421 0 19.429053-4.527158 37.052632-10.994526 52.304842 30.773895-10.051368 58.314105-23.498105 86.662737-37.349053C452.877474 727.848421 508.577684 700.631579 585.997474 700.631579 702.410105 700.631579 754.526316 778.725053 754.526316 856.144842 754.526316 938.657684 678.912 1024 552.421053 1024z m-21.180632-623.104L493.136842 362.792421l137.889684-137.889684 38.103579 38.103579-137.889684 137.889684z m-126.760421-18.351158l-38.103579-38.103579 152.980211-152.98021 38.103579 38.103579-152.980211 152.98021z m282.004211-218.624c15.494737-9.754947 43.331368-31.447579 43.331368-31.447579-25.734737-27.809684-49.556211-33.333895-67.368421-29.07621-19.240421 4.608-37.753263 24.602947-37.753263 24.602947s42.253474 22.447158 61.790316 35.920842z" fill="#231F20" ></path></symbol><symbol id="icon-horse" viewBox="0 0 1024 1024"><path d="M776.003368 646.736842c16.599579-99.947789 43.439158-181.086316 83.213474-256.538947l6.817684-12.934737H269.473684c-36.756211 0-53.894737 54.945684-53.894737 92.05221 0 46.753684 6.656 77.527579 70.278737 176.074106l84.533895 128.269473L498.876632 646.736842h277.126736z" fill="#FFAF6E" ></path><path d="M1024 0v404.210526c0 33.333895 0 134.736842-92.079158 134.736842h-13.824l-78.362947-109.056c-22.743579 49.906526-40.340211 103.046737-53.490527 162.950737h115.092211C937.310316 592.842105 970.105263 625.637053 970.105263 661.638737c0 60.631579-69.389474 154.300632-77.312 164.75621l-43.008-32.471579C875.466105 759.861895 916.210526 693.813895 916.210526 661.638737c0-5.982316-8.919579-14.901895-14.901894-14.901895h-125.332211C761.128421 736.121263 754.526316 840.569263 754.526316 970.105263h-53.894737c0-283.971368 31.097263-453.605053 110.888421-605.049263l20.318316-38.534737 112.801684 156.995369c14.443789-4.419368 25.465263-20.938105 25.465263-79.306106V0h53.894737z m-161.684211 161.684211h53.894737V0h-53.894737v80.842105c-17.381053-14.955789-38.184421-26.947368-80.842105-26.947368h-134.736842v53.894737h134.736842c37.672421 0 80.842105 40.906105 80.842105 53.894737z m-107.789473 0h-215.578948v53.894736h161.684211l53.894737-53.894736zM300.894316 766.544842L400.680421 916.210526h64.754526l-95.043368-142.551579L498.876632 646.736842h167.855157a1212.631579 1212.631579 0 0 1 9.431579-53.894737h-199.383579l-175.885473 173.702737z m109.97221-184.400842l-37.861052-38.319158-132.419369 130.802526C173.729684 571.095579 161.684211 529.812211 161.684211 469.315368 161.684211 398.578526 199.464421 323.368421 269.473684 323.368421h323.368421l53.894737-53.894737H269.473684c-6.709895 0-13.258105 0.565895-19.698526 1.482105C234.927158 249.451789 204.638316 215.578947 160.633263 215.578947 65.967158 215.578947 0 349.291789 0 469.315368c0 70.170947 16.141474 136.650105 49.232842 202.671158L6.197895 723.833263l41.472 34.41179 66.128842-79.737264-8.704-16.033684C83.105684 622.133895 53.894737 558.214737 53.894737 469.315368 53.894737 368.451368 106.765474 269.473684 160.633263 269.473684c13.231158 0 25.815579 9.889684 35.43579 20.533895C142.874947 321.967158 107.789474 388.500211 107.789474 469.315368c0 78.201263 19.698526 130.937263 93.642105 243.981474l-55.296 54.622316L280.899368 970.105263h64.754527l-130.048-195.072 195.260631-192.889263z" fill="#231F20" ></path></symbol><symbol id="icon-monkey_shen" viewBox="0 0 1024 1024"><path d="M512 512m-296.421053 0a296.421053 296.421053 0 1 0 592.842106 0 296.421053 296.421053 0 1 0-592.842106 0Z" fill="#BBC4C9" ></path><path d="M970.105263 512c0 224.983579-163.166316 412.186947-377.263158 450.533053v-54.460632C777.135158 870.507789 916.210526 707.206737 916.210526 512c0-222.881684-181.328842-404.210526-404.210526-404.210526S107.789474 289.118316 107.789474 512s181.328842 404.210526 404.210526 404.210526c9.081263 0 18.000842-0.754526 26.947368-1.374315v53.894736c-8.973474 0.538947-17.866105 1.374316-26.947368 1.374316-252.604632 0-458.105263-205.500632-458.105263-458.105263S259.395368 53.894737 512 53.894737s458.105263 205.500632 458.105263 458.105263z m-431.157895 134.736842h161.684211v53.894737h53.894737V269.473684h-215.578948V161.684211h-53.894736v107.789473h-215.578948v431.157895h53.894737v-53.894737h161.684211v215.578947h53.894736v-215.578947z m0-161.68421h161.684211v107.789473h-161.684211v-107.789473z m-215.578947 0h161.684211v107.789473h-161.684211v-107.789473z m215.578947-161.684211h161.684211v107.789474h-161.684211v-107.789474z m-215.578947 0h161.684211v107.789474h-161.684211v-107.789474z" fill="#231F20" ></path></symbol><symbol id="icon-ox_chou" viewBox="0 0 1024 1024"><path d="M512 512m-296.421053 0a296.421053 296.421053 0 1 0 592.842106 0 296.421053 296.421053 0 1 0-592.842106 0Z" fill="#D6B196" ></path><path d="M970.105263 512c0 224.983579-163.166316 412.186947-377.263158 450.533053v-54.460632C777.135158 870.507789 916.210526 707.206737 916.210526 512c0-222.881684-181.328842-404.210526-404.210526-404.210526S107.789474 289.118316 107.789474 512s181.328842 404.210526 404.210526 404.210526c9.081263 0 18.000842-0.754526 26.947368-1.374315v53.894736c-8.973474 0.538947-17.866105 1.374316-26.947368 1.374316-252.604632 0-458.105263-205.500632-458.105263-458.105263S259.395368 53.894737 512 53.894737s458.105263 205.500632 458.105263 458.105263z m-161.68421 188.631579h-159.555369c13.985684-172.813474 43.115789-357.429895 70.817684-385.158737L700.631579 269.473684H323.368421v53.894737h107.169684c-1.940211 45.756632-8.192 103.962947-15.76421 161.684211H323.368421v53.894736h83.968c-9.862737 68.446316-20.264421 130.128842-25.734737 161.684211H215.578947v53.894737h592.842106v-53.894737z m-346.543158-161.684211h149.800421a3313.717895 3313.717895 0 0 0-16.842105 161.684211h-158.477474c6.036211-35.247158 16.114526-95.636211 25.519158-161.684211z m22.608842-215.578947h171.735579c-15.198316 41.121684-27.405474 100.594526-36.890948 161.684211h-150.123789c7.383579-57.505684 13.419789-115.361684 15.279158-161.684211z" fill="#231F20" ></path></symbol><symbol id="icon-monkey" viewBox="0 0 1024 1024"><path d="M757.733053 485.052632H565.894737a80.842105 80.842105 0 0 0-80.842105 80.842105v215.578947c0 40.96 43.546947 99.678316 77.446736 139.210105C596.426105 960.215579 603.055158 970.105263 603.055158 970.105263H754.526316s15.144421-18.674526 45.891368-58.071579S862.315789 809.984 862.315789 717.608421c0-89.573053-47.993263-166.346105-104.582736-232.555789z" fill="#C3D686" ></path><path d="M538.947368 1024h-53.894736c0-32.794947 25.869474-87.417263 77.446736-103.316211C528.599579 881.152 485.052632 822.433684 485.052632 781.473684c0-44.570947 36.271158-80.842105 80.842105-80.842105h80.842105v53.894737h-80.842105a26.947368 26.947368 0 0 0-26.947369 26.947368c0 19.725474 36.675368 77.473684 92.133053 134.736842h88.602947c20.210526-14.147368 88.737684-71.464421 88.737685-198.602105 0-108.382316-93.237895-202.967579-168.151579-278.986105-49.502316-50.202947-88.576-89.842526-98.735158-128.61979-11.749053-44.732632-21.584842-112.586105-26.327579-148.318315H377.263158c-45.136842 0-89.519158 8.434526-121.802105 53.894736H431.157895v53.894737c-97.28 0-107.789474 113.071158-107.789474 161.684211v53.894737h53.894737v161.68421h-53.894737v-107.789474h-26.947368c-170.253474 0-188.631579-94.234947-188.631579-134.736842 0-31.043368 35.220211-72.326737 55.727158-93.722947 2.694737-14.686316 5.847579-28.348632 9.431579-41.013895H161.684211V215.578947h31.528421C239.642947 120.993684 317.224421 107.789474 377.263158 107.789474h185.640421l2.802526 23.794526c0.134737 1.050947 12.719158 106.657684 27.944421 164.756211 6.494316 24.872421 44.624842 63.514947 84.965053 104.448C760.481684 483.813053 862.315789 587.129263 862.315789 717.608421c0 92.375579-31.124211 155.028211-61.898105 194.425263C904.919579 892.146526 970.105263 803.004632 970.105263 673.684211c0-91.405474-42.819368-154.381474-84.237474-215.255579C847.791158 402.458947 808.421053 344.576 808.421053 269.473684c0-119.349895 87.093895-161.684211 161.68421-161.68421v53.894737c-32.417684 0-107.789474 10.509474-107.789474 107.789473 0 58.502737 31.555368 104.933053 68.096 158.639158C974.282105 492.597895 1024 565.679158 1024 673.684211c0 177.286737-108.301474 296.421053-269.473684 296.421052h-161.684211c-37.672421 0-53.894737 40.906105-53.894737 53.894737zM229.214316 269.473684a384.808421 384.808421 0 0 0-14.012632 58.341053l-1.401263 8.488421-6.090105 6.117053c-22.878316 22.932211-44.813474 52.601263-46.026105 62.275368 0 56.805053 53.76 75.264 107.789473 79.386947V431.157895c0-58.691368 13.473684-119.619368 46.511158-161.684211h-86.770526zM323.368421 1024h-53.894737c0-32.794947 25.869474-87.417263 77.446737-103.316211C313.020632 881.152 269.473684 822.433684 269.473684 781.473684c0-44.570947 36.271158-80.842105 80.842105-80.842105h45.16379A188.847158 188.847158 0 0 1 565.894737 592.842105h134.736842v53.894737h-134.736842c-74.293895 0-134.736842 60.442947-134.736842 134.736842v26.516211l-53.894737 0.377263V781.473684c0-9.162105 0.646737-18.135579 1.913263-26.947368H350.315789c-14.848 0-26.947368 12.072421-26.947368 26.947368 0 19.725474 36.675368 77.473684 92.133053 134.736842H431.157895v53.894737h-53.894737c-37.672421 0-53.894737 40.906105-53.894737 53.894737z" fill="#231F20" ></path></symbol><symbol id="icon-horse_wu" viewBox="0 0 1024 1024"><path d="M512 512m-296.421053 0a296.421053 296.421053 0 1 0 592.842106 0 296.421053 296.421053 0 1 0-592.842106 0Z" fill="#FF8787" ></path><path d="M970.105263 512c0 224.983579-163.166316 412.186947-377.263158 450.533053v-54.460632C777.135158 870.507789 916.210526 707.206737 916.210526 512c0-222.881684-181.328842-404.210526-404.210526-404.210526S107.789474 289.118316 107.789474 512s181.328842 404.210526 404.210526 404.210526c9.081263 0 18.000842-0.754526 26.947368-1.374315v53.894736c-8.973474 0.538947-17.866105 1.374316-26.947368 1.374316-252.604632 0-458.105263-205.500632-458.105263-458.105263S259.395368 53.894737 512 53.894737s458.105263 205.500632 458.105263 458.105263z m-431.157895 26.947368h269.473685v-53.894736H538.947368v-161.684211h161.684211v-53.894737H411.001263c12.045474-33.28 20.156632-69.793684 20.156632-107.789473h-53.894737c0 121.963789-105.364211 233.391158-106.415158 234.496l38.858105 37.349052c2.883368-3.018105 43.816421-46.133895 77.392842-110.160842H485.052632v161.684211H215.578947v53.894736h269.473685v323.368421h53.894736V538.947368z" fill="#231F20" ></path></symbol><symbol id="icon-ox" viewBox="0 0 1025 1024"><path d="M540.294737 754.526316h215.578947c20.210526 0 35.112421 1.374316 53.894737 4.581052 91.863579 15.656421 145.354105 67.691789 161.684211 86.069895V916.210526h53.894736V635.580632l-7.895579-7.895579c-9.269895-9.269895-36.513684-49.232842-44.032-196.527158H540.294737a161.684211 161.684211 0 0 0-161.684211 161.68421v131.098948c43.304421 20.210526 97.28 30.585263 161.684211 30.585263z" fill="#FFAF6E" ></path><path d="M1025.347368 635.580632V916.210526h-53.894736v-71.033263c-16.330105-18.405053-69.820632-70.413474-161.684211-86.069895V916.210526h-53.894737v-161.68421h-107.789473v215.578947h-53.894737V700.631579h161.68421c100.998737 0 172.570947 38.669474 215.578948 71.868632v-115.738948c-33.684211-43.627789-51.712-137.458526-53.706106-279.498105H701.978947c-76.934737 0-127.218526-26.219789-175.804631-51.550316a1556.048842 1556.048842 0 0 0-26.839579-13.743158c-26.839579 26.004211-66.209684 44.921263-115.738948 55.511579 24.441263 22.986105 60.874105 52.116211 106.469053 72.838737l-22.312421 49.044211c-76.584421-34.816-129.589895-88.926316-150.824421-113.125053-10.644211 0.619789-21.477053 1.024-32.687158 1.024a473.734737 473.734737 0 0 1-123.365053-15.952842l-93.022315 186.314105 68.581052 53.86779C167.882105 579.557053 237.891368 538.947368 324.715789 538.947368v53.894737c-95.986526 0-170.361263 62.490947-171.088842 63.137684l-16.78821 14.282106-136.838737-107.358316 109.729684-219.809684C46.430316 314.448842 1.347368 267.371789 1.347368 199.868632 1.347368 89.815579 121.586526 53.894737 163.031579 53.894737v53.894737c-14.120421 0-107.789474 17.165474-107.789474 92.079158C55.242105 290.465684 192.188632 323.368421 284.240842 323.368421c67.907368 0 122.421895-12.988632 157.696-35.624421-42.711579-14.336-95.097263-23.120842-169.337263-18.324211l-3.503158-53.786947c95.878737-6.117053 160.148211 8.515368 211.429053 28.833684C484.244211 235.439158 486.4 225.818947 486.4 215.578947c0-48.855579-57.829053-76.288-58.394947-76.557473l22.393263-49.017263C454.063158 91.648 540.294737 131.826526 540.294737 215.578947c0 18.566737-3.422316 35.84-9.997474 51.631158 7.060211 3.584 13.985684 7.168 20.776421 10.698106C597.854316 302.322526 638.248421 323.368421 701.978947 323.368421h269.473685v26.947368c0 214.689684 35.220211 266.590316 45.999157 277.369264l7.895579 7.895579z m-729.384421 25.141894l-98.789052 118.541474 86.797473 137.835789 45.594948-28.725894-65.913263-104.690527 37.052631-44.43621C358.642526 785.192421 439.080421 808.421053 540.294737 808.421053v-53.894737c-99.893895 0-175.077053-24.549053-223.474526-72.946527l-20.857264-20.857263z" fill="#231F20" ></path></symbol><symbol id="icon-rabbit_mao" viewBox="0 0 1024 1024"><path d="M512 512m-296.421053 0a296.421053 296.421053 0 1 0 592.842106 0 296.421053 296.421053 0 1 0-592.842106 0Z" fill="#7DD47F" ></path><path d="M970.105263 512c0 224.983579-163.166316 412.186947-377.263158 450.533053v-54.460632C777.135158 870.507789 916.210526 707.206737 916.210526 512c0-222.881684-181.328842-404.210526-404.210526-404.210526S107.789474 289.118316 107.789474 512s181.328842 404.210526 404.210526 404.210526c9.081263 0 18.000842-0.754526 26.947368-1.374315v53.894736c-8.973474 0.538947-17.866105 1.374316-26.947368 1.374316-252.604632 0-458.105263-205.500632-458.105263-458.105263S259.395368 53.894737 512 53.894737s458.105263 205.500632 458.105263 458.105263z m-377.263158-188.631579h107.789474v323.368421c-20.48 0-39.936-11.264-40.016842-11.317895l-27.728842 46.214737c3.206737 1.940211 32.660211 18.997895 67.745684 18.997895 30.746947 0 53.894737-23.147789 53.894737-53.894737V269.473684h-215.578948v538.947369h53.894737V323.368421z m-107.789473 242.526316v-242.526316h-53.894737v196.904421l-107.789474 40.421053v-243.927579l169.094737-48.316632-14.821053-51.819789L269.473684 276.102737v304.801684l-36.405895 13.662316 18.917053 50.472421 178.741895-67.018105c-5.039158 69.928421-55.269053 106.981053-165.133474 122.933894l7.733895 53.328842C325.712842 746.657684 485.052632 723.536842 485.052632 565.894737z" fill="#231F20" ></path></symbol><symbol id="icon-rabbit" viewBox="0 0 1024 1024"><path d="M680.96 488.744421a1666.667789 1666.667789 0 0 0-54.433684-23.95621c-16.006737 12.234105-33.899789 20.264421-60.631579 20.264421h-80.842105c-36.810105 0-83.644632 30.396632-104.394106 67.772631-42.819368 77.123368-53.409684 117.813895-11.021473 201.701053C397.096421 808.879158 431.157895 876.409263 431.157895 970.105263h338.539789l68.338527-138.859789c20.129684-40.96 24.252632-73.701053 24.252631-110.349474 0.026947-57.397895-25.061053-159.717053-181.328842-232.151579z" fill="#FFBDD8" ></path><path d="M862.315789 720.896c0 36.621474-4.122947 69.389474-24.252631 110.349474L769.697684 970.105263H485.052632v-53.894737h48.370526C507.877053 880.074105 485.052632 833.509053 485.052632 781.473684c0-59.418947 24.171789-113.313684 63.218526-152.360421l38.103579 38.103579A161.091368 161.091368 0 0 0 538.947368 781.473684c0 54.784 35.381895 104.043789 63.514948 134.736842h133.712842l53.490526-108.759579c15.710316-31.851789 18.755368-55.834947 18.755369-86.554947 0-80.976842-63.434105-150.096842-178.607158-195.503158-17.542737 8.138105-38.292211 13.554526-63.919158 13.554526h-80.842105c-13.958737 0-43.924211 15.979789-57.290106 40.016843l-47.104-26.165895C401.408 515.449263 448.242526 485.052632 485.052632 485.052632h80.842105c37.268211 0 57.478737-15.440842 79.090526-36.45979C625.367579 336.195368 549.753263 269.473684 485.052632 269.473684h-107.789474a21.288421 21.288421 0 0 0-5.955369 2.021053A683.762526 683.762526 0 0 0 302.187789 194.021053c-35.84-34.223158-61.763368-58.933895-94.908631-79.440842A42.442105 42.442105 0 0 0 185.478737 107.789474a22.824421 22.824421 0 0 0-17.381053 7.194947c-10.913684 11.425684-6.063158 28.240842 1.428211 39.181474 21.989053 32.121263 47.912421 56.858947 83.752421 91.109052 20.614737 19.671579 49.259789 43.169684 77.392842 63.08379C281.007158 367.400421 215.578947 484.432842 215.578947 592.842105c0 74.482526 24.791579 124.065684 51.065264 176.586106C294.534737 825.209263 323.368421 882.903579 323.368421 970.105263h-53.894737c0-74.482526-24.791579-124.065684-51.065263-176.586105C190.517895 737.738105 161.684211 680.043789 161.684211 592.842105c0-90.866526 42.226526-197.685895 93.453473-274.485894a803.759158 803.759158 0 0 1-39.046737-34.115369C177.852632 247.754105 150.231579 221.399579 125.035789 184.616421c-24.441263-35.759158-22.797474-78.686316 4.069053-106.819368 26.300632-27.567158 70.898526-31.043368 106.522947-9.000421 37.941895 23.444211 65.562947 49.798737 103.774316 86.258526 9.970526 9.512421 33.037474 32.309895 56.93979 60.550737h68.634947c-27.621053-37.780211-60.416-72.730947-88.522105-99.543579-28.833684-27.540211-54.730105-52.116211-84.533895-74.024421L326.305684 0.296421c31.232 23.228632 57.802105 48.532211 87.309474 76.719158 53.840842 51.388632 94.450526 100.594526 121.74821 146.83621 82.836211 26.650947 150.042947 116.870737 165.025685 230.750316l1.724631 13.177263-9.404631 9.404632c-3.772632 3.772632-7.706947 7.653053-11.802948 11.587368C837.227789 561.178947 862.315789 663.498105 862.315789 720.896zM309.463579 754.526316c3.934316 8.057263 7.895579 16.087579 11.991579 24.144842C348.887579 832.970105 377.263158 889.128421 377.263158 970.105263h53.894737c0-93.696-34.061474-161.226105-61.520842-215.578947h-60.173474z m597.90821 53.894737c-3.422316 9.404632-7.814737 19.806316-13.770105 31.959579L829.790316 970.105263h60.065684l52.143158-105.957052c10.778947-21.935158 17.515789-40.016842 21.90821-55.727158h-56.535579zM514.694737 390.736842c0-34.223158-13.231158-44.463158-29.642105-44.463158s-29.642105 10.24-29.642106 44.463158c0 34.250105 13.231158 44.463158 29.642106 44.463158s29.642105-10.213053 29.642105-44.463158z" fill="#231F20" ></path></symbol><symbol id="icon-rat_zi" viewBox="0 0 1024 1024"><path d="M512 512m-296.421053 0a296.421053 296.421053 0 1 0 592.842106 0 296.421053 296.421053 0 1 0-592.842106 0Z" fill="#85C3DE" ></path><path d="M970.105263 512c0 224.983579-163.166316 412.186947-377.263158 450.533053v-54.460632C777.135158 870.507789 916.210526 707.206737 916.210526 512c0-222.881684-181.328842-404.210526-404.210526-404.210526S107.789474 289.118316 107.789474 512s181.328842 404.210526 404.210526 404.210526c9.081263 0 18.000842-0.754526 26.947368-1.374315v53.894736c-8.973474 0.538947-17.866105 1.374316-26.947368 1.374316-252.604632 0-458.105263-205.500632-458.105263-458.105263S259.395368 53.894737 512 53.894737s458.105263 205.500632 458.105263 458.105263z m-431.157895 188.631579v-215.578947h269.473685v-53.894737H538.947368v-39.585684c26.543158-18.081684 94.585263-65.050947 177.852632-127.488L700.631579 215.578947H323.368421v53.894737h295.316211a4221.008842 4221.008842 0 0 1-121.640421 85.369263l-11.991579 8.003369V431.157895H242.526316v53.894737h242.526316v215.578947c0 48.343579-13.850947 53.894737-134.736843 53.894737v53.894737c105.391158 0 188.631579 0 188.631579-107.789474z" fill="#231F20" ></path></symbol><symbol id="icon-rat" viewBox="0 0 1024 1024"><path d="M727.659789 431.157895c-132.581053 0-220.348632 47.454316-285.803789 154.354526-19.779368 32.309895-15.845053 76.503579-9.404632 96.579368 3.260632 10.159158 7.760842 18.647579 12.422737 25.546106C464.761263 737.010526 499.927579 754.526316 538.947368 754.526316h66.829474c1.158737 17.893053-1.967158 34.762105-15.144421 53.975579-12.692211 18.539789-37.807158 40.151579-56.32 54.810947 25.249684-0.673684 52.709053-0.997053 83.240421-0.997053C877.487158 862.315789 970.105263 711.922526 970.105263 571.176421 936.421053 512 882.364632 431.157895 727.659789 431.157895z" fill="#85C3DE" ></path><path d="M210.432 1012.897684l-43.573895-31.690105c106.954105-147.051789 185.317053-171.196632 423.828211-172.705684 21.396211-31.258947 16.249263-56.266105 9.377684-89.70779-3.557053-17.138526-7.221895-34.842947-7.221895-54.433684 0-68.958316 25.330526-104.636632 63.407158-136.973474l34.896842 41.040842c-29.453474 25.061053-44.409263 46.780632-44.409263 95.932632 0 14.093474 2.937263 28.402526 6.063158 43.546947 5.901474 28.510316 12.8 62.032842-1.131789 99.462737 166.373053-10.24 264.542316-96.902737 264.542315-236.193684C916.210526 418.330947 827.580632 323.368421 684.921263 323.368421c-83.644632 0-153.303579 29.696-174.187789 39.612632a224.875789 224.875789 0 0 1-20.533895 31.339789l-41.741474-34.115368 20.884211 17.057684-20.911158-16.976842C448.781474 359.828211 485.052632 314.287158 485.052632 262.736842c0-34.816-8.946526-60.766316-26.570106-77.069474-17.515789-16.249263-44.786526-24.602947-81.219368-24.953263V323.368421h-53.894737V109.783579l24.872421-1.913263c64.700632-4.931368 114.095158 7.895579 146.863158 38.238316C524.207158 173.056 538.947368 212.291368 538.947368 262.736842c0 11.102316-1.131789 21.908211-3.072 32.202105 37.268211-12.584421 89.842526-25.465263 149.045895-25.465263C858.165895 269.473684 970.105263 387.907368 970.105263 571.176421 970.105263 711.922526 877.487158 862.315789 617.552842 862.315789c-258.667789 0-311.942737 19.698526-407.120842 150.581895z m19.105684-256.835368c-12.045474 0-24.387368-0.565895-37.025684-1.64379l-22.096842-1.859368-2.425263-22.016C167.747368 728.144842 161.684211 672.444632 161.684211 631.026526c0-103.585684 21.450105-178.903579 53.894736-259.045052V107.789474h53.894737v274.782315l-2.021052 4.904422C235.439158 465.758316 215.578947 533.800421 215.578947 631.026526c0 22.878316 2.101895 51.442526 3.826527 70.979369 99.678316 2.802526 172.813474-35.408842 222.450526-116.493474l48.020211 24.090947c-11.237053 28.133053-11.371789 51.577263-0.377264 67.853474 9.701053 14.282105 28.645053 23.174737 49.448421 23.174737v53.894737c-39.019789 0-74.186105-17.515789-94.073263-46.888421a100.244211 100.244211 0 0 1-12.422737-25.546106c-53.221053 49.178947-121.128421 73.943579-202.913684 73.970527zM379.957895 525.473684c0-34.223158-13.231158-44.463158-29.642106-44.463158s-29.642105 10.24-29.642105 44.463158c0 34.250105 13.231158 44.463158 29.642105 44.463158s29.642105-10.213053 29.642106-44.463158z" fill="#231F20" ></path></symbol><symbol id="icon-rooster_you" viewBox="0 0 1024 1024"><path d="M512 512m-296.421053 0a296.421053 296.421053 0 1 0 592.842106 0 296.421053 296.421053 0 1 0-592.842106 0Z" fill="#BBC4C9" ></path><path d="M970.105263 512c0 224.983579-163.166316 412.186947-377.263158 450.533053v-54.460632C777.135158 870.507789 916.210526 707.206737 916.210526 512c0-222.881684-181.328842-404.210526-404.210526-404.210526S107.789474 289.118316 107.789474 512s181.328842 404.210526 404.210526 404.210526c9.081263 0 18.000842-0.754526 26.947368-1.374315v53.894736c-8.973474 0.538947-17.866105 1.374316-26.947368 1.374316-252.604632 0-458.105263-205.500632-458.105263-458.105263S259.395368 53.894737 512 53.894737s458.105263 205.500632 458.105263 458.105263z m-215.578947-188.631579h-161.684211v-26.947368h161.684211V242.526316H269.473684v53.894737h161.684211v26.947368h-161.684211v485.052632h53.894737v-53.894737h377.263158v53.894737h53.894737V323.368421zM323.368421 646.736842h377.263158v53.894737H323.368421v-53.894737z m0-269.473684h107.789474c0 103.316211-72.784842 107.654737-81.084632 107.789474L350.315789 538.947368c46.592 0 134.736842-33.792 134.736843-161.68421h53.894736v107.789474c0 29.722947 24.171789 53.894737 53.894737 53.894736h107.789474v53.894737H323.368421v-215.578947z m377.263158 0v107.789474h-107.789474v-107.789474h107.789474z m-215.578947-80.842105h53.894736v26.947368h-53.894736v-26.947368z" fill="#231F20" ></path></symbol><symbol id="icon-rooster" viewBox="0 0 1024 1024"><path d="M891.688421 506.421895C877.244632 455.033263 862.315789 401.893053 862.315789 323.368421V116.224l-323.368421 195.745684V323.368421c0 78.524632 14.928842 131.664842 29.372632 183.053474 12.611368 44.894316 24.522105 87.282526 24.522105 140.314947 0 101.618526-77.931789 176.693895-168.286316 203.991579l5.416422 11.587368h215.578947c24.333474 0 43.385263-0.242526 58.556631-2.128842C811.52 846.821053 916.210526 764.550737 916.210526 646.736842c0-53.032421-11.910737-95.420632-24.522105-140.314947z" fill="#FF8787" ></path><path d="M673.684211 354.357895c-16.384 0-29.642105-10.213053-29.642106-44.463158 0-34.223158 13.231158-44.463158 29.642106-44.463158s29.642105 10.24 29.642105 44.463158c0 34.250105-13.258105 44.463158-29.642105 44.463158zM540.106105 970.105263l-50.58021-107.789474h156.05221l50.607158 107.789474h59.553684l-51.60421-109.918316C811.52 846.821053 916.210526 764.550737 916.210526 646.736842c0-53.032421-11.910737-95.420632-24.522105-140.314947C877.244632 455.033263 862.315789 401.893053 862.315789 323.368421V107.789474c0-59.445895-48.343579-107.789474-107.789473-107.789474a107.924211 107.924211 0 0 0-107.789474 106.172632 100.890947 100.890947 0 0 0-24.117895-3.314527 88.710737 88.710737 0 0 0-88.602947 88.602948c0 20.668632 5.227789 39.720421 10.671158 53.921684l-99.489684 59.688421 93.749894 14.470737V377.263158c0 14.416842-5.901474 21.692632-33.360842 49.152l-11.129263 11.129263C398.228211 326.521263 324.985263 269.473684 215.740632 269.473684 96.768 269.473684 0 366.241684 0 485.214316V646.736842h53.894737v-161.522526A162.007579 162.007579 0 0 1 215.740632 323.368421c82.081684 0 140.422737 36.244211 240.64 152.252632l-38.615579 38.615579C367.804632 461.285053 323.098947 431.157895 259.584 431.157895A151.983158 151.983158 0 0 0 107.789474 582.952421V754.526316h53.894737v-171.573895A98.007579 98.007579 0 0 1 259.584 485.052632c46.322526 0 79.629474 20.911158 137.027368 86.016l18.970948 21.530947 128.080842-128.080842C572.200421 435.981474 592.842105 415.366737 592.842105 377.263158v-97.926737l23.309474-14.120421-13.662316-23.04c-0.161684-0.242526-14.578526-24.899368-14.578526-50.688 0-19.132632 15.575579-34.708211 34.70821-34.708211 5.093053 0 26.785684 3.179789 39.558737 18.647579l26.327579 46.026106 39.774316-24.090948-20.372211-49.367579C704.754526 140.449684 700.631579 117.517474 700.631579 107.789474c0-29.722947 24.171789-53.894737 53.894737-53.894737s53.894737 24.171789 53.894737 53.894737v215.578947c0 85.935158 16.680421 145.300211 31.366736 197.632C851.887158 564.008421 862.315789 601.141895 862.315789 646.736842c0 95.285895-99.408842 161.684211-188.631578 161.684211h-209.461895l-68.419369-145.704421C375.242105 618.954105 338.108632 592.842105 296.448 592.842105A80.976842 80.976842 0 0 0 215.578947 673.711158V862.315789h53.894737v-188.604631c0-14.874947 12.099368-26.974316 26.974316-26.974316 20.533895 0 38.965895 14.147368 50.553263 38.858105L480.579368 970.105263h59.526737z" fill="#231F20" ></path></symbol><symbol id="icon-snake_si" viewBox="0 0 1024 1024"><path d="M512 512m-296.421053 0a296.421053 296.421053 0 1 0 592.842106 0 296.421053 296.421053 0 1 0-592.842106 0Z" fill="#FF8787" ></path><path d="M970.105263 512c0 224.983579-163.166316 412.186947-377.263158 450.533053v-54.460632C777.135158 870.507789 916.210526 707.206737 916.210526 512c0-222.881684-181.328842-404.210526-404.210526-404.210526S107.789474 289.118316 107.789474 512s181.328842 404.210526 404.210526 404.210526c9.081263 0 18.000842-0.754526 26.947368-1.374315v53.894736c-8.973474 0.538947-17.866105 1.374316-26.947368 1.374316-252.604632 0-458.105263-205.500632-458.105263-458.105263S259.395368 53.894737 512 53.894737s458.105263 205.500632 458.105263 458.105263z m-242.041263 180.762947l-52.116211-13.797052C657.219368 749.864421 651.425684 754.526316 619.789474 754.526316h-242.526316V485.052632h269.473684v53.894736h53.894737V215.578947H323.368421v538.947369c0 29.722947 24.171789 53.894737 53.894737 53.894737h242.526316c77.689263 0 91.189895-51.065263 108.274526-115.658106zM377.263158 269.473684h269.473684v161.684211H377.263158v-161.684211z" fill="#231F20" ></path></symbol><symbol id="icon-tiger_yin" viewBox="0 0 1024 1024"><path d="M512 512m-296.421053 0a296.421053 296.421053 0 1 0 592.842106 0 296.421053 296.421053 0 1 0-592.842106 0Z" fill="#7DD47F" ></path><path d="M970.105263 512c0 224.983579-163.166316 412.186947-377.263158 450.533053v-54.460632C777.135158 870.507789 916.210526 707.206737 916.210526 512c0-222.881684-181.328842-404.210526-404.210526-404.210526S107.789474 289.118316 107.789474 512s181.328842 404.210526 404.210526 404.210526c9.081263 0 18.000842-0.754526 26.947368-1.374315v53.894736c-8.973474 0.538947-17.866105 1.374316-26.947368 1.374316-252.604632 0-458.105263-205.500632-458.105263-458.105263S259.395368 53.894737 512 53.894737s458.105263 205.500632 458.105263 458.105263z m-257.42821 299.250526l-107.789474-53.894737-24.117895 48.208843 107.789474 53.894736 24.117895-48.208842z m-269.473685-5.658947l-24.117894-48.208842-107.789474 53.894737 24.117895 48.208842 107.789473-53.894737zM700.631579 431.157895h-161.684211v-53.894737h107.789474v-53.894737H377.263158v53.894737h107.789474v53.894737h-161.684211v323.368421h53.894737v-53.894737h269.473684v53.894737h53.894737V431.157895z m-161.684211 161.68421h107.789474v53.894737h-107.789474v-53.894737z m-161.68421 0h107.789474v53.894737h-107.789474v-53.894737z m161.68421-107.789473h107.789474v53.894736h-107.789474v-53.894736z m-161.68421 0h107.789474v53.894736h-107.789474v-53.894736zM754.526316 215.578947h-223.097263l-20.803369-62.410105-51.119158 17.057684L474.624 215.578947H269.473684v107.789474h53.894737v-53.894737h377.263158v53.894737h53.894737V215.578947z" fill="#231F20" ></path></symbol><symbol id="icon-snake" viewBox="0 0 1024 1024"><path d="M107.789474 790.474105c0-72.434526 67.880421-91.513263 121.451789-91.513263 74.401684 0 153.815579 34.438737 237.891369 70.925474 50.580211 21.935158 104.609684 45.325474 162.250105 63.083789-52.412632 44.786526-118.784 74.347789-195.152842 83.078737-143.171368 16.357053-326.440421 7.006316-326.440421-125.574737zM377.263158 215.578947c-15.575579 0-30.288842 3.449263-43.654737 9.377685A250.691368 250.691368 0 0 0 323.368421 296.421053c0 115.550316 76.422737 169.391158 137.83579 212.614736 8.138105 5.712842 16.141474 11.371789 23.848421 17.057685V323.368421a107.789474 107.789474 0 0 0-107.789474-107.789474z" fill="#C3D686" ></path><path d="M671.528421 788.857263c44.328421 11.964632 89.626947 19.563789 136.892632 19.56379 89.168842 0 161.684211-60.442947 161.68421-134.736842s-72.515368-134.736842-161.68421-134.736843c-19.078737 0-37.025684 1.509053-54.218106 4.015158-0.754526-101.402947-38.211368-172.355368-79.413894-219.648L673.684211 323.368421a1749.962105 1749.962105 0 0 1-79.036632-1.751579c45.702737 35.866947 108.705684 107.870316 105.984 232.367158 0 0.431158-0.080842 0.808421-0.10779 1.239579-34.923789 10.994526-66.155789 26.731789-95.097263 45.190737a163.085474 163.085474 0 0 0-15.845052-42.388211c-21.557895-39.639579-60.065684-66.775579-97.360842-93.022316C433.098105 423.343158 377.263158 384 377.263158 296.421053c0-130.290526 108.274526-188.631579 215.578947-188.631579 64.134737 0 132.715789 12.045474 214.366316 37.807158C802.330947 180.250947 780.099368 209.381053 700.631579 214.635789V161.684211h-53.894737v53.679157c-63.272421-1.024-104.528842-5.200842-104.986947-5.254736l-5.578106 53.598315C538.408421 263.949474 592.357053 269.473684 673.684211 269.473684c125.170526 0 188.631579-48.128 188.631578-143.063579V106.981053l-18.432-6.144C747.789474 68.823579 668.025263 53.894737 592.842105 53.894737c-158.666105 0-269.473684 99.732211-269.473684 242.526316 0 115.550316 76.422737 169.391158 137.83579 212.614736 33.684211 23.713684 65.509053 46.106947 81.003789 74.698106 9.539368 17.542737 13.285053 33.414737 12.341895 47.750737 21.153684 9.108211 42.118737 17.839158 62.949052 25.977263C671.151158 620.193684 729.977263 592.842105 808.421053 592.842105c59.445895 0 107.789474 36.271158 107.789473 80.842106s-48.343579 80.842105-107.789473 80.842105c-105.472 0-203.237053-42.388211-297.768421-83.429053-94.800842-41.094737-184.346947-79.952842-281.411369-79.952842C122.718316 591.171368 53.894737 644.715789 53.894737 727.578947c0 79.063579 67.098947 136.434526 159.555368 136.434527 142.174316 0 230.426947-66.883368 306.79579-129.886316 31.420632 13.419789 62.787368 26.058105 94.450526 37.133474-47.077053 49.637053-110.969263 82.566737-186.610526 91.270736l5.066105 53.625264c93.453474-7.006316 143.144421 9.350737 195.718737 26.543157 46.457263 15.225263 94.127158 30.854737 169.822316 30.854737 19.994947 0 41.957053-1.077895 66.344421-3.557052l-5.416421-53.625263c-105.283368 10.778947-158.100211-6.548211-213.935158-24.872422-22.150737-7.275789-44.624842-14.632421-70.305684-20.345263a334.848 334.848 0 0 0 96.14821-82.297263z m-458.078316 21.261474C162.573474 810.118737 107.789474 784.276211 107.789474 727.578947c0-60.847158 62.733474-82.539789 121.451789-82.539789 77.850947 0 154.731789 30.288842 235.250526 64.943158-66.263579 52.924632-139.722105 100.136421-251.041684 100.136421z" fill="#231F20" ></path></symbol><symbol id="icon-tiger" viewBox="0 0 1024 1024"><path d="M431.157895 162.250105V134.736842c0-41.552842-39.289263-80.842105-80.842106-80.842105-28.833684 0-57.128421 4.661895-58.314105 4.850526L269.473684 62.490947v83.887158C144.788211 223.824842 89.222737 346.839579 66.991158 431.157895h266.051368c240.747789 0 415.851789 107.789474 415.85179 269.473684-14.848-25.114947-43.924211-53.894737-88.68379-53.894737-67.988211 0-121.263158 71.033263-121.263158 161.684211 0 66.802526 30.477474 119.888842 60.712421 156.16 12.638316 15.171368 36.055579 37.726316 59.014737 58.88 5.066105 0.107789 9.781895 0.538947 15.009685 0.538947 219.297684 0 350.315789-191.811368 350.315789-377.263158C1024 327.545263 679.855158 172.813474 431.157895 162.250105z" fill="#F7C768" ></path><path d="M673.684211 1024c-114.768842 0-188.820211-33.333895-254.167579-62.787368-53.625263-24.144842-99.974737-45.002105-161.28-45.002106-40.448 0-83.590737 23.255579-103.639579 45.16379l-39.747369-36.432842C142.497684 894.787368 199.168 862.315789 258.236632 862.315789c68.392421 0 119.861895 21.288421 172.921263 45.056V673.684211c0-35.166316-17.542737-64.107789-30.639158-80.815158-15.198316 9.835789-32.067368 18.890105-50.741895 26.947368l-21.342316-49.475368C469.800421 509.413053 485.052632 377.317053 485.052632 323.368421V221.642105A597.827368 597.827368 0 0 0 404.210526 215.578947h-26.947368V134.736842c0-12.099368-14.848-26.947368-26.947369-26.947368-9.377684 0-18.836211 0.592842-26.947368 1.347368V269.473684h-53.894737V211.671579c-136.030316 102.912-158.450526 266.886737-161.306947 295.882105 9.135158 9.108211 38.992842 25.061053 71.976421 38.669474l38.103579-59.365053 12.449684-1.589894C321.212632 473.653895 377.263158 392.192 377.263158 323.368421h53.894737c0 88.333474-68.796632 192.242526-180.870737 213.342316l-48.397474 75.398737-20.291368-7.437474C53.894737 557.756632 53.894737 523.317895 53.894737 512c0-50.041263 37.025684-254.733474 215.578947-365.621895V62.490947l22.528-3.745684C293.187368 58.556632 321.482105 53.894737 350.315789 53.894737c41.552842 0 80.842105 39.289263 80.842106 80.842105v27.513263c248.697263 10.563368 592.842105 165.295158 592.842105 484.486737 0 185.451789-131.018105 377.263158-350.315789 377.263158z m-13.473685-323.368421c-36.513684 0-67.368421 49.367579-67.368421 107.789474 0 85.746526 68.096 145.084632 89.465263 161.549473 91.540211-2.533053 164.378947-45.487158 213.827369-107.654737H700.631579v-53.894736h230.238316c8.919579-17.273263 16.357053-35.354947 22.285473-53.894737h-239.885473l-6.467369-17.650527C706.290526 735.582316 692.439579 700.631579 660.210526 700.631579zM485.052632 931.112421c33.926737 14.066526 70.521263 26.597053 114.607157 33.468632C569.424842 928.309895 538.947368 875.223579 538.947368 808.421053c0-90.650947 53.274947-161.684211 121.263158-161.684211 44.759579 0 73.835789 28.779789 88.68379 53.894737h217.007158c2.775579-17.866105 4.203789-35.920842 4.203789-53.894737 0-38.938947-5.658947-74.752-15.925895-107.627789l-126.706526 126.679579-38.103579-38.103579L932.001684 485.052632a367.939368 367.939368 0 0 0-57.775158-81.596632l-154.543158 154.543158-38.103579-38.103579 153.573053-153.573053a537.869474 537.869474 0 0 0-82.593684-56.751158l-140.665263 140.638316-38.103579-38.103579 128.134737-128.134737A794.731789 794.731789 0 0 0 538.947368 231.046737V323.368421c0 50.149053-11.102316 156.698947-95.932631 236.328421 18.378105 23.417263 42.037895 63.407158 42.037895 113.987369v257.42821zM215.578947 431.157895v-53.894737c39.774316 0 53.894737-29.022316 53.894737-53.894737h53.894737c0 53.571368-37.025684 107.789474-107.789474 107.789474z" fill="#231F20" ></path></symbol><symbol id="icon-boar" viewBox="0 0 1024 1024"><path d="M732.079158 377.263158c-107.789474 0-186.421895 31.393684-281.869474 126.841263L180.331789 773.982316C257.724632 807.909053 348.725895 808.421053 485.052632 808.421053h96.013473c55.834947-34.411789 133.551158-53.894737 227.354948-53.894737h121.344L970.105263 680.555789V572.631579c0-94.315789-130.236632-195.368421-238.026105-195.368421z" fill="#FFBDD8" ></path><path d="M808.421053 700.631579v53.894737c-196.446316 0-323.368421 84.641684-323.368421 215.578947h-53.894737c0-163.705263 148.075789-269.473684 377.263158-269.473684z m-323.368421 107.789474v-53.894737c-158.342737 0-245.598316 0-319.649685-49.367579L158.612211 700.631579H80.842105c-21.692632 0-26.624-14.821053-26.947368-26.947368v-82.620632c84.156632-11.183158 161.684211-74.913684 161.68421-186.853053V215.578947H161.684211v161.684211H134.736842c-66.964211 0-134.736842 37.025684-134.736842 107.789474h53.894737c0-42.630737 52.870737-53.894737 80.842105-53.894737h24.629895C147.132632 504.912842 85.153684 538.947368 26.947368 538.947368H0v134.736843c0 32.498526 21.530947 80.842105 80.842105 80.842105h61.682527c32.687158 20.506947 67.125895 33.145263 105.957052 41.013895A232.879158 232.879158 0 0 0 215.578947 916.210526h53.894737c0-41.930105 14.012632-80.303158 39.424-112.505263C358.885053 808.151579 415.959579 808.421053 485.052632 808.421053z m-72.946527-342.420211L323.368421 554.738526V431.157895h-53.894737v253.682526l180.736-180.736-38.103579-38.103579zM323.368421 161.684211h-53.894737v190.032842a769.536 769.536 0 0 1 53.894737-49.098106V161.684211z m323.368421-53.894737c-72.623158 0-146.809263 23.336421-215.578947 58.637473V107.789474h-53.894737v154.138947C458.832842 205.392842 555.331368 161.684211 646.736842 161.684211c148.587789 0 269.473684 120.885895 269.473684 269.473684v235.654737L809.579789 862.315789h61.359158L970.105263 680.555789V431.157895c0-178.310737-145.057684-323.368421-323.368421-323.368421z" fill="#231F20" ></path></symbol><symbol id="icon-boar_hai" viewBox="0 0 1024 1024"><path d="M512 512m-296.421053 0a296.421053 296.421053 0 1 0 592.842106 0 296.421053 296.421053 0 1 0-592.842106 0Z" fill="#85C3DE" ></path><path d="M309.975579 804.756211l-27.136-46.592c103.073684-60.011789 183.026526-132.473263 241.475368-219.24379H350.315789l-13.473684-50.283789c58.88-33.980632 99.435789-117.571368 118.703158-165.295158H242.526316v-53.894737h538.947368v53.894737h-268.18021c-12.395789 34.088421-42.469053 106.603789-90.435369 161.68421h134.009263a680.555789 680.555789 0 0 0 46.349474-107.708631l51.092211 17.057684c-58.421895 175.265684-171.034947 309.490526-344.333474 410.381474z m192.350316-2.937264L467.806316 760.454737c88.414316-73.728 154.516211-158.773895 202.105263-259.907369l48.801684 22.959158a797.372632 797.372632 0 0 1-82.351158 137.781895c32.741053 15.009684 83.456 44.867368 137.647158 101.591579l-38.938947 37.268211c-57.236211-59.877053-109.325474-85.557895-133.766737-95.178106a850.997895 850.997895 0 0 1-98.977684 96.848842z m48.613052-536.872421l-80.842105-53.894737 29.884632-44.840421 80.842105 53.894737-29.884632 44.840421zM512 53.894737C259.395368 53.894737 53.894737 259.395368 53.894737 512s205.500632 458.105263 458.105263 458.105263c9.081263 0 17.973895-0.835368 26.947368-1.374316v-53.894736c-8.946526 0.619789-17.866105 1.374316-26.947368 1.374315-222.881684 0-404.210526-181.328842-404.210526-404.210526S289.118316 107.789474 512 107.789474s404.210526 181.328842 404.210526 404.210526c0 195.206737-139.075368 358.507789-323.368421 396.045474v54.460631c214.096842-38.346105 377.263158-225.549474 377.263158-450.533052C970.105263 259.395368 764.604632 53.894737 512 53.894737z" fill="#231F20" ></path></symbol><symbol id="icon-bilibili1" viewBox="0 0 1129 1024"><path d="M234.909 9.656a80.468 80.468 0 0 1 68.398 0 167.374 167.374 0 0 1 41.843 30.578l160.937 140.82h115.07l160.936-140.82a168.983 168.983 0 0 1 41.843-30.578A80.468 80.468 0 0 1 930.96 76.445a80.468 80.468 0 0 1-17.703 53.914 449.818 449.818 0 0 1-35.406 32.187 232.553 232.553 0 0 1-22.531 18.508h100.585a170.593 170.593 0 0 1 118.289 53.109 171.397 171.397 0 0 1 53.914 118.288v462.693a325.897 325.897 0 0 1-4.024 70.007 178.64 178.64 0 0 1-80.468 112.656 173.007 173.007 0 0 1-92.539 25.75H212.377a341.186 341.186 0 0 1-72.421-4.024A177.835 177.835 0 0 1 28.91 939.065a172.202 172.202 0 0 1-27.36-92.539V388.662a360.498 360.498 0 0 1 0-66.789A177.03 177.03 0 0 1 162.487 178.64h105.414c-16.899-12.07-31.383-26.555-46.672-39.43a80.468 80.468 0 0 1-25.75-65.984 80.468 80.468 0 0 1 39.43-63.57M216.4 321.873a80.468 80.468 0 0 0-63.57 57.937 108.632 108.632 0 0 0 0 30.578v380.615a80.468 80.468 0 0 0 55.523 80.469 106.218 106.218 0 0 0 34.601 5.632h654.208a80.468 80.468 0 0 0 76.444-47.476 112.656 112.656 0 0 0 8.047-53.109v-354.06a135.187 135.187 0 0 0 0-38.625 80.468 80.468 0 0 0-52.304-54.719 129.554 129.554 0 0 0-49.89-7.242H254.22a268.764 268.764 0 0 0-37.82 0z m0 0" fill="#20B0E3" ></path><path d="M348.369 447.404a80.468 80.468 0 0 1 55.523 18.507 80.468 80.468 0 0 1 28.164 59.547v80.468a80.468 80.468 0 0 1-16.094 51.5 80.468 80.468 0 0 1-131.968-9.656 104.609 104.609 0 0 1-10.46-54.719v-80.468a80.468 80.468 0 0 1 70.007-67.593z m416.02 0a80.468 80.468 0 0 1 86.102 75.64v80.468a94.148 94.148 0 0 1-12.07 53.11 80.468 80.468 0 0 1-132.773 0 95.757 95.757 0 0 1-12.875-57.133V519.02a80.468 80.468 0 0 1 70.007-70.812z m0 0" fill="#20B0E3" ></path></symbol><symbol id="icon-yinle" viewBox="0 0 1024 1024"><path d="M512.2976 0a531.2 531.2 0 0 0-512 548.48V960h128V548.48a398.72 398.72 0 0 1 384-411.52 398.72 398.72 0 0 1 384 411.52V960h128V548.48A531.2 531.2 0 0 0 512.2976 0z" fill="#5c8add" ></path><path d="M64.2976 576l256 0 0 448-256 0 0-448Z" fill="#5c8add" ></path><path d="M704.2976 576l256 0 0 448-256 0 0-448Z" fill="#5c8add" ></path></symbol><symbol id="icon-icon-test-copy" viewBox="0 0 1024 1024"><path d="M512 512m-229.517241 0a229.517241 229.517241 0 1 0 459.034482 0 229.517241 229.517241 0 1 0-459.034482 0Z" fill="#5c8add" ></path><path d="M512 1024A512 512 0 1 1 1024 512 512 512 0 0 1 512 1024z m0-141.241379A370.758621 370.758621 0 1 0 141.241379 512 370.758621 370.758621 0 0 0 512 882.758621z" fill="#5c8add" ></path></symbol><symbol id="icon-V" viewBox="0 0 1024 1024"><path d="M1012.47774251 492.58192592L544.94137566 87.22962963a49.96686561 49.96686561 0 0 0-65.88275132 0L11.63784127 492.6975097c-21.03624691 18.26223633-23.3479224 49.93219048-5.08568606 70.96843739 18.03106878 21.03624691 49.93219048 23.3479224 70.96843738 5.08568607L512 191.83294532l434.71057495 376.91868784c9.47786949 8.20644797 21.26741446 12.25188008 32.82579189 12.13629629 14.10122046 0 27.97127337-5.77918871 38.02706173-17.33756613 18.14665256-20.92066314 15.95056084-52.70620106-5.08568606-70.9684374z" fill="#5c8add" ></path><path d="M109.30613051 567.59579541V896.89396825c0 42.53482892 34.90629982 77.44112875 77.44112875 77.44112875h220.76500882V666.30433862c0-25.54401411 20.92066314-46.46467725 46.46467724-46.46467724h116.16169313c25.54401411 0 46.46467725 20.92066314 46.46467725 46.46467724V974.335097h220.76500882c42.53482892 0 77.44112875-34.90629982 77.44112874-77.44112875l0.11558377-329.29817284L512 218.18604586 109.30613051 567.59579541zM848.00203175 197.49655027h-63.91782716c-12.82979894 0-23.23233862 10.40253968-23.23233863 23.23233862v24.27259259l110.49808818 95.70336508V220.72888889h-0.11558377c0-12.82979894-10.40253968-23.23233862-23.23233862-23.23233862zM905.44716754 83.18419754s-34.90629982 56.86721693-89.11508994 100.32671603c152.68616579 13.98563668 127.83565432-133.26809171 127.83565432-133.2680917-134.07717813-10.28695591-132.92134039 102.29164021-131.072 127.83565432 20.92066314-20.92066314 49.70102293-62.64640564 92.35143562-94.89427865zM798.53217637 174.61096297c-19.64924162-16.52847972-40.56990476-43.45949912-51.203612-53.97762258 0 0 32.94137566 20.57391182 56.40488184 49.3542716 2.42725926-18.37782011 6.47269135-93.3916896-93.16052205-85.3008254 0 0-13.98563668 104.71889947 87.95925221 89.92417638z" fill="#5c8add" ></path></symbol><symbol id="icon-zhifeiji" viewBox="0 0 1167 1024"><path d="M41.201759 463.52493L1110.665064 30.117647c10.32605-4.159104 21.942857 0.860504 26.101961 11.043137 1.434174 3.728852 1.864426 7.744538 1.003921 11.616807L949.033691 978.823529c-2.151261 10.89972-12.764146 17.927171-23.663865 15.632493-2.72493-0.573669-5.306443-1.721008-7.601121-3.298599L634.80624 789.79944l-163.065546 133.951821c-16.492997 13.62465-40.87395 11.186555-54.498599-5.306443-3.011765-3.728852-5.306443-7.887955-6.884034-12.477311l-102.973669-313.080112-265.178712-91.787115c-10.469468-3.585434-16.062745-15.058824-12.333893-25.528291 1.864426-5.44986 6.023529-9.895798 11.329972-12.047059z" fill="#FCFDFC" ></path><path d="M929.385512 1023.569748c-3.155182 0-6.453782-0.286835-9.752381-1.003922-6.740616-1.434174-12.907563-4.015686-18.50084-8.031372L635.953579 825.940616l-146.142297 120.040336c-13.911485 11.473389-31.408403 16.779832-49.335574 15.058824-17.927171-1.721008-34.133333-10.32605-45.463305-24.237535-5.306443-6.453782-9.322129-13.768067-11.903642-21.79944l-98.527731-299.598879-251.697479-87.19776c-12.333894-4.302521-22.229692-13.05098-27.966386-24.811204s-6.453782-24.954622-2.151261-37.288515c4.589356-13.337815 14.771989-23.9507 27.82297-29.257143L1099.908761 3.585434c24.954622-10.039216 53.351261 2.007843 63.533894 26.819048 3.585434 8.891877 4.445938 18.644258 2.581513 28.109804L977.143495 984.560224c-4.732773 23.090196-25.098039 39.009524-47.757983 39.009524z m-294.579272-233.770308l282.962465 201.357983c2.294678 1.577591 4.87619 2.72493 7.601121 3.298599 10.89972 2.151261 21.512605-4.87619 23.663865-15.632493L1137.914364 52.777591c0.860504-3.872269 0.430252-7.887955-1.003922-11.616807-4.159104-10.32605-15.919328-15.202241-26.101961-11.043137L41.201759 463.52493c-5.306443 2.151261-9.465546 6.597199-11.47339 12.047059-1.721008 5.019608-1.434174 10.469468 0.860505 15.345658 2.294678 4.87619 6.453782 8.461625 11.473389 10.182633l265.178711 91.787115L410.214644 905.967507c1.434174 4.589356 3.872269 8.748459 6.884033 12.477311 6.597199 8.031373 15.919328 12.907563 26.101961 13.911485 10.32605 1.003922 20.365266-2.007843 28.396639-8.605042l163.208963-133.951821z" fill="#4A4A4A" ></path><path d="M307.097557 592.743978l105.698599 316.091876c6.310364 18.787675 26.532213 28.970308 45.319888 22.659944 4.159104-1.434174 7.887955-3.442017 11.186555-6.166946l164.786555-133.951821-165.360224-118.892997c297.017367-287.982073 447.462185-433.980952 451.191036-437.853222 0.573669-0.573669 2.581513-3.442017 0.430252-7.027451-1.290756-1.577591-3.298599-3.298599-7.027451-2.15126-202.218487 120.327171-404.293557 242.805602-606.22521 367.291877z" fill="#CAE0EE" ></path><path d="M446.786072 934.794398c-5.736695 0-11.329972-1.290756-16.636414-3.872269-8.891877-4.445938-15.632493-12.047059-18.787675-21.512605L305.376549 592.313725l1.003921-0.573669C507.308201 467.684034 711.391114 344.058263 912.60568 224.161345l0.286835-0.143418c3.585434-1.147339 6.310364-0.286835 8.605042 2.581513l0.143417 0.143417c2.438095 4.015686 0.573669 7.457703-0.573669 8.74846-3.872269 4.015686-155.177591 150.87507-450.043698 436.705882l165.503642 119.036414-166.220728 135.09916c-3.442017 2.868347-7.457703 5.019608-11.760225 6.453782-3.728852 1.290756-7.744538 2.007843-11.760224 2.007843z m-137.967507-341.333334l105.268348 314.944538c2.868347 8.748459 9.035294 15.77591 17.210084 19.935014 8.17479 4.159104 17.496919 4.732773 26.245378 1.864426 3.872269-1.290756 7.60112-3.298599 10.756302-5.880112l163.352381-132.804482L466.434252 672.627451l1.290756-1.147339C763.308201 384.932213 915.043775 237.642577 918.772627 233.626891c0 0 2.007843-2.294678 0.286835-5.306443-1.003922-1.290756-2.438095-2.438095-5.306443-1.577591-200.784314 119.610084-404.293557 242.94902-604.934454 366.718207z" fill="#CAE0EE" ></path><path d="M460.840974 924.898599l7.457703-253.561904 165.933894 119.896918-168.658824 135.959664c-1.290756 1.003922-3.011765 0.860504-4.015686-0.430252-0.430252-0.430252-0.717087-1.147339-0.717087-1.864426z" fill="#94C3E2" ></path><path d="M463.709322 929.344538c-1.290756 0-2.438095-0.573669-3.2986-1.577591-0.573669-0.860504-1.003922-1.864426-1.003921-2.868348l7.60112-256.286834 169.519328 122.621848-1.434174 1.147339-168.658823 135.959664c-0.860504 0.717087-1.721008 1.003922-2.72493 1.003922z m6.023529-255.282913l-7.457703 250.836974c0 0.286835 0.143417 0.717087 0.286835 1.003922 0.430252 0.573669 1.434174 0.717087 2.007843 0.286835l167.22465-134.812325-162.061625-117.315406z" fill="#94C3E2" ></path></symbol><symbol id="icon-lianjie" viewBox="0 0 1079 1024"><path d="M695.355535 432.666896c-0.553495-1.10699-0.885592-2.186305-1.383737-3.265619-0.193723-0.193723-0.193723-0.359772-0.359771-0.719543-12.508983-26.318678-39.436506-43.366319-69.325226-41.013966-39.076734 3.265619-68.439634 39.021384-65.312388 79.841627 0.857917 10.516401 3.653066 20.147211 7.998 28.83708 19.78744 46.659613 11.097571 103.448181-25.377737 141.750022l-191.094085 199.950001a118.088119 118.088119 0 0 1-171.998513 0c-47.434506-49.537786-47.434506-130.098956 0-179.636742l71.234782-74.389703-0.52582-0.553494a75.911814 75.911814 0 0 0 24.326097-61.880721c-3.127246-40.820243-37.3609-71.51153-76.437634-68.24591a69.463599 69.463599 0 0 0-46.908685 23.966325l-0.166049-0.193723-72.618519 75.856464c-103.226783 107.793115-103.226783 282.36538 0 390.158495 103.171433 107.793115 270.299193 107.793115 373.498301 0l191.619904-200.1714c80.256748-83.992838 97.636485-208.307773 52.83108-310.289193z" fill="#5c8add" ></path><path d="M1002.047012 80.865592c-103.226783-107.82079-270.382217-107.82079-373.581325 0l-191.619905 200.199075c-80.284423 83.854464-97.66416 208.197074-52.997128 310.233843 0.52582 1.079315 0.857917 2.15863 1.383737 3.26562 0.166048 0.166048 0.166048 0.359772 0.332097 0.719543 12.536658 26.291004 39.46418 43.366319 69.3529 41.013966 39.076734-3.265619 68.439634-39.021384 65.312388-79.869302a78.679288 78.679288 0 0 0-7.998-28.864755c-19.78744-46.631938-11.097571-103.448181 25.377737-141.750022l191.287808-199.839302a118.088119 118.088119 0 0 1 172.026188 0c47.434506 49.537786 47.434506 130.126631 0 179.692091l-71.234782 74.417378 0.52582 0.553495a75.939489 75.939489 0 0 0-24.353772 61.88072c3.15492 40.847917 37.3609 71.51153 76.465309 68.245911a69.463599 69.463599 0 0 0 46.908685-23.938651l0.166049 0.166048 72.646194-75.856464c103.03306-107.82079 103.03306-282.642127 0-390.269194z" fill="#5c8add" ></path></symbol><symbol id="icon-liaotian" viewBox="0 0 1171 1024"><path d="M1068.71699 0.243751H102.193768C46.228437 0.243751 0.500666 45.045267 0.500666 99.74309v696.251622c0 54.697824 45.727771 99.450589 101.693102 99.450589h329.113198l120.851966 114.465677a48.652788 48.652788 0 0 0 66.641644 0l120.851966-114.465677h329.064448c55.965331 0 101.741852-44.752765 101.741852-99.450589V99.74309C1170.458842 45.045267 1124.682321 0.243751 1068.71699 0.243751z m-439.776354 596.849784h-370.989696c-27.933915 0-50.846551-22.425133-50.846551-49.774045 0-27.348912 22.912636-49.725294 50.846551-49.725294h370.989696c27.933915 0 50.846551 22.376382 50.846551 49.725294 0 27.348912-22.912636 49.774045-50.846551 49.774045z m287.18795-211.381252H254.782171a50.456549 50.456549 0 0 1-50.846551-49.725294c0-27.397662 22.912636-49.774045 50.846551-49.774045h661.346415c27.933915 0 50.846551 22.376382 50.846551 49.774045 0 27.348912-22.912636 49.725294-50.846551 49.725294z" fill="#5C8ADD" ></path></symbol><symbol id="icon-xinfeng" viewBox="0 0 1400 1024"><path d="M1301.63733163 214.78520234a207.81921797 207.81921797 0 0 1 7.02423018 52.42036465v489.73590176a205.10753818 205.10753818 0 0 1-205.05853125 205.05853125H283.05853124A205.15654424 205.15654424 0 0 1 77.99999999 756.79444971V267.20556699a201.36672685 201.36672685 0 0 1 7.02423106-52.42036465L586.24393329 562.1905874c69.44187217 51.96297217 146.36536612 49.13694404 214.1736961 0zM1103.60303056 62.0000167H283.05853124A204.50312753 204.50312753 0 0 0 106.37462518 163.41030547l489.71956641 335.75823018c62.43397646 50.77048623 127.85733457 50.31309463 194.62019765 0L1280.28693749 163.41030547A204.68281729 204.68281729 0 0 0 1103.60303056 62.0000167z m0 0" fill="#5c8add" ></path></symbol><symbol id="icon-QQ1" viewBox="0 0 1024 1024"><path d="M0 512a512 512 0 1 0 1024 0A512 512 0 1 0 0 512z" fill="#18ACFC" ></path><path d="M500.113 228.39c118.396-1.518 178.924 61.004 201 156 3.497 15.048 0.15 34.807 0 50 27.143 5.682 33.087 60.106 10 75v1h1c8.26 14.33 19.04 28.125 26 44 7.332 16.723 9.306 35.16 14 55 4.024 17.01-2.287 51.505-10 57-0.771 0.683-2.231 1.312-3 2-14.601-3.016-30.377-16.865-38-27-3.065-4.074-5.275-9.672-10-12-0.395 21.568-12.503 41.15-22 55-3.514 5.123-14.073 13.217-14 18 3.691 2.836 8.305 2.956 13 5 10.513 4.577 25.449 13.168 32 22 2.334 3.146 5.548 7.555 7 11 16.193 38.414-36.527 48.314-63 54-27.185 5.839-77.818-10.224-92-19-8.749-5.414-16.863-18.573-29-19-3.666 2.389-14.438 1.132-20 1-16.829 32.804-101.913 47.868-148 31-14.061-5.146-43.398-17.695-38-40 4.437-18.327 19.947-29.224 35-37 5.759-2.975 18.915-4.419 22-10-13.141-8.988-24.521-28.659-31-44-3.412-8.077-4.193-25.775-9-32-7.789 12.245-32.097 36.91-52 33-3.071-4.553-7.213-9.097-9-15-4.792-15.835-1.81-40.379 2-54 8.117-29.02 16.965-50.623 32-72 4.672-6.643 11.425-12.135 16-19-8.945-9.733-6.951-37.536-1-49 4.002-7.709 9.701-7.413 10-20-1.92-3.022-0.071-8.604-1-13-4.383-20.75 3.273-47.552 9-63 19.8-53.421 53.712-90.466 105-112 11.986-5.033 25.833-7.783 39-11 5.322-1.3 11.969 0.518 16-2z" fill="#FFFFFF" ></path></symbol><symbol id="icon-rss" viewBox="0 0 1024 1024"><path d="M749.61196492 908.06119793C749.61196492 560.41848146 463.58151854 274.36328126 115.93880207 274.36328126V115.93880207c434.50388795 0 792.12239584 357.61850789 792.12239586 792.12239586zM224.55858562 690.72261555a108.91682943 108.91682943 0 0 1 108.69404499 108.74355267C333.25263061 859.29616292 284.24005737 908.06119793 224.31104736 908.06119793 164.48105265 908.06119793 115.96355592 859.41993206 115.96355592 799.46616822s48.69077351-108.71879883 108.61978351-108.74355267zM641.01693522 908.06119793h-153.96879069c0-203.60020956-167.50913289-371.13409627-371.10934246-371.13409629v-153.96879068c288.03550619 0 525.07813313 237.11688843 525.07813315 525.10288697z" fill="#FFA500" ></path></symbol><symbol id="icon-youxiang" viewBox="0 0 1024 1024"><path d="M583.60666667 972h-68.08c-8.43333333 0-15.33333333-6.9-15.33333334-15.33333333V609.52c0-8.43333333 6.9-15.33333333 15.33333334-15.33333333h68.08c8.43333333 0 15.33333333 6.9 15.33333333 15.33333333V956.66666667c0 8.43333333-6.9 15.33333333-15.33333333 15.33333333z" fill="#629FF9" ></path><path d="M294.42 167c-113.62 0-205.77333333 92-205.77333333 205.31333333v336.72h411.39333333V372.31333333c0.15333333-113.31333333-92-205.31333333-205.62-205.31333333z" fill="#2166CC" ></path><path d="M519.97333333 627H216.98666667c-25.45333333 0-46-20.54666667-46-46V393.78c0-25.45333333 20.54666667-46 46-46h302.98666666c25.45333333 0 46 20.54666667 46 46V581c0 25.45333333-20.54666667 46-46 46z" fill="#D2E4FF" ></path><path d="M565.97333333 397a49.22 49.22 0 0 0-49.37333333-49.22H220.36c-27.29333333 0-49.37333333 22.08-49.37333333 49.22v10.27333333l179.4 94.60666667c11.34666667 5.98 24.84 5.98 36.18666666 0l179.4-94.60666667v-10.27333333z" fill="#FFFFFF" ></path><path d="M730.5 167h-427.8v0.46c109.78666667 4.29333333 197.49333333 94.3 197.49333333 205.00666667v336.72h411.39333334c27.29333333 0 49.37333333-22.08 49.37333333-49.22V397c0-126.96-103.19333333-230-230.46-230z" fill="#4E8DF6" ></path><path d="M845.80666667 52H681.12666667c-9.04666667 0-16.40666667 7.36-16.40666667 16.40666667v336.72a24.67133333 24.67133333 0 1 0 49.37333333 0V134.18666667h131.71333334c9.04666667 0 16.40666667-7.36 16.40666666-16.40666667V68.40666667c0-9.04666667-7.36-16.40666667-16.40666666-16.40666667z" fill="#2166CC" ></path><path d="M896.25333333 659.81333333h-35.11333333c-8.43333333 0-15.33333333-6.9-15.33333333-15.33333333v-35.11333333c0-8.43333333 6.9-15.33333333 15.33333333-15.33333334h35.11333333c8.43333333 0 15.33333333 6.9 15.33333334 15.33333334v35.11333333c0 8.58666667-6.9 15.33333333-15.33333334 15.33333333z" fill="#FFFFFF" ></path><path d="M88.8 709.18666667l-24.22666667 131.40666666c-9.66 54.43333333 26.83333333 98.59333333 81.26666667 98.59333334h213.9c54.58666667 0 106.56666667-44.16 116.22666667-98.59333334l23.15333333-131.40666666H88.8z" fill="#2974CE" ></path></symbol><symbol id="icon-gitHub" viewBox="0 0 1049 1024"><path d="M523.6581816 52C262.83923907 52 52 262.8401375 52 523.6581816c0 208.49703047 135.09433812 384.97758117 322.50789391 447.44906532 23.42658172 4.68531653 32.01647887-10.15136894 32.01647796-22.64584583 0-10.93210574-0.78163433-48.41463703-0.78163433-87.45953855-131.18885996 28.11189824-158.5200223-56.22379738-158.52002231-56.22379739-21.08437312-54.66232469-52.3201152-68.71827336-52.3201152-68.71827335-42.94858371-28.89353348 3.12384382-28.89353348 3.12384384-28.89353348 47.63479867 3.12384382 72.62285398 48.41643391 72.62285398 48.4164339 42.16784782 71.84121875 110.10538527 51.53758242 137.43654672 39.04400399 3.90457972-30.45500618 16.3990566-51.5393793 29.67427028-63.25222094-104.64023039-10.93300418-214.74561566-51.53848086-214.74561657-232.70524742 0-51.53848086 18.74126609-93.70632867 48.4164339-126.50444187-4.68621496-11.71284164-21.08527156-60.12837711 4.6844181-124.94207075 0 0 39.82563922-12.49447688 129.62738726 48.41463704 37.48253129-10.15136894 78.08980484-15.61742227 117.91454562-15.61742137s80.43201433 5.46605242 117.91454473 15.61742137c89.80264648-60.90911391 129.62828571-48.41463703 129.62828571-48.41463704 25.76879122 64.81369363 9.37063305 113.22922911 4.68531651 124.94207075 30.45410773 32.79721477 48.41463703 74.96506258 48.41463703 126.50444187 0 181.16676656-110.10538527 220.99150644-215.52545401 232.70524742 17.1797934 14.83668547 32.01647887 42.94858371 32.01647886 87.45953946 0 63.25222094-0.78163433 114.009965-0.78163523 129.62738636 0 12.49447688 8.59079468 27.33116234 32.01737731 22.64584583 187.41265734-62.4705866 322.50699547-238.95203574 322.50699546-447.44996375C995.31636231 262.8401375 783.69369203 52 523.6581816 52z" fill="#663399" ></path><path d="M230.82365863 729.03136735c-0.7807359 2.34310703-4.68531653 3.12384382-7.80916035 1.56237113s-5.46605242-4.68531653-3.90368129-7.02842356c0.7807359-2.34220859 4.68531653-3.12384382 7.80826192-1.56147269s4.68531653 4.68531653 3.90457972 7.02752512z m18.7412661 21.08437312c-2.34220859 2.34220859-7.02752512 0.78163433-9.37063305-2.34310703-3.12294539-3.12294539-3.90457972-7.80826192-1.5614727-10.15136894 2.34220859-2.34220859 6.24678922-0.7807359 9.37063305 2.34310702 3.12384382 3.90457972 3.90457972 8.58899782 1.5614727 10.15136895zM268.30618992 777.44690281c-3.12294539 2.34220859-7.80826192 0-10.15136895-3.90457972-3.12384382-3.90457972-3.12384382-9.37063305 0-10.93210574 3.12384382-2.34310703 7.80916035 0 10.15226739 3.90457972 3.12294539 3.90368129 3.12294539 8.58899782 0 10.93210574z m25.76968965 26.55042555c-2.34220859 3.12294539-7.80916035 2.34220859-12.49447688-1.56237113-3.90457972-3.90368129-5.46605242-9.37063305-2.34220859-11.71284164 2.34220859-3.12384382 7.80826192-2.34310703 12.49447687 1.56147269 3.90368129 3.12384382 4.68531653 8.58989625 2.3422086 11.71374008z m35.1403227 14.83668637c-0.78163433 3.90457972-6.24768766 5.46605242-11.71374008 3.90457972-5.46605242-1.5614727-8.58899782-6.24768766-7.80916036-9.37063305 0.78163433-3.90457972 6.24768766-5.46605242 11.71374009-3.90457972 5.46605242 1.5614727 8.58899782 5.46605242 7.80916035 9.37063305z m38.26416562 3.12384382c0 3.90457972-4.68621496 7.02752512-10.15226738 7.02752512-5.46605242 0-10.15226738-3.12294539-10.15226739-7.02752512s4.68621496-7.02842356 10.15226739-7.02842445c5.46605242 0 10.15226738 3.12384382 10.15226738 7.02842445z m35.92016106-6.24768766c0.78163433 3.90457972-3.12384382 7.80916035-8.58899872 8.58989625-5.46695086 0.78163433-10.15226738-1.5614727-10.93390172-5.46605241-0.77983747-3.90457972 3.12384382-7.80916035 8.5907947-8.58899872 5.46605242-0.78163433 10.15136894 1.56057426 10.93210574 5.46515488z m0 0" fill="#663399" ></path></symbol><symbol id="icon-bilibili" viewBox="0 0 1024 1024"><path d="M832.61667555 181.33447111h-164.32545185l74.45617778-74.45617778c12.84020148-12.84020148 12.84020148-30.8140563 0-43.65425778-12.84020148-12.84020148-30.8140563-12.84020148-43.65425778 0L573.2882963 189.04101925H450.04420741L324.2272237 63.23617185c-10.26730667-12.84020148-25.68040297-15.40096-41.08136295-7.70654815-2.57289482 0-2.57289482 2.57289482-5.13365334 5.13365333-12.84020148 12.84020148-12.84020148 30.8140563 0 43.65425779l77.02907259 77.02907259h-164.32545185c-89.86927408 0-164.32545185 74.45617778-164.32545185 164.32545184v408.24073483c0 87.29637925 74.45617778 161.75255703 164.32545185 161.75255703h25.68040296c0 30.8140563 25.68040297 53.92156445 53.92156444 53.92156444s53.92156445-25.68040297 53.92156445-53.92156444H704.23893333c2.57289482 30.8140563 28.24116148 53.92156445 59.05521778 51.34866964 28.24116148-2.57289482 48.78791111-23.10750815 51.34866964-51.34866964h20.53461333c89.86927408 0 164.32545185-74.45617778 164.32545184-164.32545186V343.09916445c-2.56075852-89.86927408-77.02907259-161.76469333-166.88621037-161.76469334z m-5.13365333 634.19429926H200.99527111c-33.37481482 0-59.05521778-28.24116148-61.61597629-61.61597629l-2.57289482-415.94728297c0-33.37481482 28.24116148-61.6159763 61.6159763-61.61597629h626.48775111c33.37481482 0 59.05521778 28.24116148 61.61597629 61.61597629l2.57289482 415.94728297c-2.57289482 35.93557333-28.24116148 61.6159763-61.6159763 61.61597629z" fill="#ff7299" ></path><path d="M403.82919111 417.55534222l15.40096 77.0290726-205.40681481 38.50846815-15.40096-77.0290726 205.40681481-38.50846815z m197.70026667 77.0290726l15.40096-77.0290726 205.40681481 38.50846815-15.40096 77.0290726-205.40681481-38.50846815z m41.08136297 161.75255703c0 2.57289482 0 7.70654815-2.57289483 10.26730667-12.84020148 28.24116148-41.08136297 46.2150163-74.45617777 48.78791111-20.53461333 0-41.08136297-10.26730667-53.92156445-25.68040296-15.40096 15.40096-33.37481482 25.68040297-53.92156445 25.68040296-30.8140563-2.57289482-59.05521778-20.53461333-74.45617777-48.78791111 0-2.57289482-2.57289482-5.13365333-2.57289481-10.26730667 0-10.26730667 7.70654815-17.97385482 17.97385481-20.53461333h2.57289482c7.70654815 0 12.84020148 2.57289482 15.40096 10.26730666 0 0 20.53461333 28.24116148 38.50846815 28.24116149 35.94770963 0 35.94770963-30.8140563 56.48232296-53.92156445 23.10750815 25.68040297 23.10750815 53.92156445 56.48232296 53.92156445 23.10750815 0 38.50846815-28.24116148 38.50846815-28.24116149 2.57289482-5.13365333 10.26730667-10.26730667 15.40096-10.26730666 10.26730667-2.57289482 17.97385482 5.13365333 20.53461333 15.40096v5.13365333h0.0364089z" fill="#ff7299" ></path></symbol></svg>',o=(o=document.getElementsByTagName("script"))[o.length-1].getAttribute("data-injectcss"),p=function(c,l){l.parentNode.insertBefore(c,l)};if(o&&!c.__iconfont__svg__cssinject__){c.__iconfont__svg__cssinject__=!0;try{document.write("<style>.svgfont {display: inline-block;width: 1em;height: 1em;fill: currentColor;vertical-align: -0.1em;font-size:16px;}</style>")}catch(c){console&&console.log(c)}}function d(){i||(i=!0,a())}function m(){try{t.documentElement.doScroll("left")}catch(c){return void setTimeout(m,50)}d()}l=function(){var c,l=document.createElement("div");l.innerHTML=v,v=null,(l=l.getElementsByTagName("svg")[0])&&(l.setAttribute("aria-hidden","true"),l.style.position="absolute",l.style.width=0,l.style.height=0,l.style.overflow="hidden",l=l,(c=document.body).firstChild?p(l,c.firstChild):c.appendChild(l))},document.addEventListener?~["complete","loaded","interactive"].indexOf(document.readyState)?setTimeout(l,0):(h=function(){document.removeEventListener("DOMContentLoaded",h,!1),l()},document.addEventListener("DOMContentLoaded",h,!1)):document.attachEvent&&(a=l,t=c.document,i=!1,m(),t.onreadystatechange=function(){"complete"==t.readyState&&(t.onreadystatechange=null,d())})}(window);]]></content>
      
    </entry>
    
    
  
</search>
