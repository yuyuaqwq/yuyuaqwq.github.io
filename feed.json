{
    "version": "https://jsonfeed.org/version/1",
    "title": "鹿鹿鱼鱼",
    "description": "人为什么要起床？",
    "home_page_url": "http://yuyuaqwq.github.io",
    "items": [
        {
            "id": "http://yuyuaqwq.github.io/posts/7ee4.html",
            "url": "http://yuyuaqwq.github.io/posts/7ee4.html",
            "title": "1.通过网线直连的两台终端设备",
            "date_published": "2024-04-29T04:26:30.000Z",
            "content_html": "<h2 id=\"连接它们\"><a class=\"markdownIt-Anchor\" href=\"#连接它们\">#</a> 连接它们</h2>\n<p>连接两台终端设备最简单的方式是什么？其一当然是直接通过一条网线来连接。</p>\n<p>假设我们准备了两台 PC，并用铜交叉线连接了它们：</p>\n<ul>\n<li>\n<img src=\"/posts/7ee4/1.png\" class=\"\" title=\"这是一张图片\">\n</li>\n</ul>\n<p>仅是如此还是不够的，我们还需要为他们配置一下 IP 地址：</p>\n<ul>\n<li>\n<img src=\"/posts/7ee4/2.png\" class=\"\" title=\"这是一张图片\">\n</li>\n</ul>\n<h2 id=\"ping\"><a class=\"markdownIt-Anchor\" href=\"#ping\">#</a> Ping</h2>\n<p>相信你应该对 Ping 这个命令有所耳闻，其作用是探测本机与网络中另一主机之间是否可达，基于 ICMP 协议 (现在不清楚这些协议也没关系，后面会讲)。<br>\n如果配置正确，我们的两台设备应该是能够 Ping 通的。</p>\n<p>配置完 IP 地址之后，我们尝试一下用 <code>192.168.1.10</code>  这台设备 Ping <code>192.168.1.11</code> 。</p>\n<ul>\n<li>\n<img src=\"/posts/7ee4/3.gif\" class=\"\" title=\"这是一张动图\">\n</li>\n</ul>\n",
            "tags": [
                "计算机网络"
            ]
        },
        {
            "id": "http://yuyuaqwq.github.io/posts/54a8.html",
            "url": "http://yuyuaqwq.github.io/posts/54a8.html",
            "title": "1.VsCode环境配置",
            "date_published": "2023-10-29T03:39:42.000Z",
            "content_html": "<h1 id=\"visual-studio-code-安装\"><a class=\"markdownIt-Anchor\" href=\"#visual-studio-code-安装\">#</a> Visual Studio Code 安装</h1>\n<p>这一块应该没什么好细说的，到<a href=\"https://code.visualstudio.com/\">官网</a>上下载就可以了。</p>\n<h1 id=\"虚拟机-安装\"><a class=\"markdownIt-Anchor\" href=\"#虚拟机-安装\">#</a> 虚拟机 安装</h1>\n<p>我个人的开发环境是，物理机 <code>Windows</code>  + 虚拟机 <code>Ubuntu</code> ，因此需要安装一个虚拟机应用。<br>\n可以看你个人选择自己喜好的虚拟机应用，例如 <code>VMWare Workstation</code>  或 <code>VirtualBox</code> 。<br>\n这里我使用的是 <code>VMWare Workstation</code> 。</p>\n<h1 id=\"ubuntu-安装\"><a class=\"markdownIt-Anchor\" href=\"#ubuntu-安装\">#</a> Ubuntu 安装</h1>\n<p>虚拟机上安装 <code>Ubuntu</code>  的话，网上的教程也很多，也不赘述了，我这里装的是桌面版的。</p>\n<h1 id=\"配置vscode的远程开发\"><a class=\"markdownIt-Anchor\" href=\"#配置vscode的远程开发\">#</a> 配置 VsCode 的远程开发</h1>\n<p>我们需要在 <code>Windows</code>  上进行 <code>Linux</code>  下的开发， <code>VsCode</code>  给我们提供了一个很好的方案，使用 <code>SSH</code>  进行远程开发。</p>\n<h2 id=\"vscode扩展\"><a class=\"markdownIt-Anchor\" href=\"#vscode扩展\">#</a> VsCode 扩展</h2>\n<p>这是 <code>VsCode</code>  中，微软提供的一个扩展。<br>\n首先启动 <code>VsCode</code> ，选择 <code>Extensions(Ctrl+Shift+X)</code>  选项卡，搜索 <code>Remote</code> 。<br>\n安装 <code>Remote - SSH</code>  扩展：</p>\n<ol>\n<li><code>Remote - SSH</code></li>\n<li><code>Remote Explorer</code>\n<ul>\n<li>会被自动安装</li>\n</ul>\n</li>\n<li><code>Remote - SSH: Editing Configuration Files</code>\n<ul>\n<li>会被自动安装</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"openssh\"><a class=\"markdownIt-Anchor\" href=\"#openssh\">#</a> OpenSSH</h2>\n<p>在 <code>Windows</code>  和 <code>Ubuntu</code>  中都需要安装。</p>\n<h3 id=\"windows\"><a class=\"markdownIt-Anchor\" href=\"#windows\">#</a> Windows</h3>\n<p>在虚拟机中测试了一下，似乎 <code>Windows 10</code>  上已经预置了。</p>\n<h3 id=\"ubuntu\"><a class=\"markdownIt-Anchor\" href=\"#ubuntu\">#</a> Ubuntu</h3>\n<p><code>Ubuntu</code>  下的安装相当简单：<br>\n <code>sudo apt-get install openssh-server</code></p>\n<p>以下命令启动 <code>ssh 服务</code> ：<br>\n <code>sudo /etc/init.d/ssh start</code></p>\n<p>以下命令查看 <code>ssh 服务</code> 是否启用：<br>\n <code>ps -e|grep ssh</code></p>\n<p>有进程 <code>sshd</code>  在运行就是 ok 了。</p>\n<h3 id=\"配置免密登录\"><a class=\"markdownIt-Anchor\" href=\"#配置免密登录\">#</a> 配置免密登录</h3>\n<p>我们需要让 <code>Linux端的OpenSSH服务</code> 识别我们的身份，以实现免密登录。</p>\n<h4 id=\"生成密钥对\"><a class=\"markdownIt-Anchor\" href=\"#生成密钥对\">#</a> 生成密钥对</h4>\n<p><code>Windows PowerShell</code>  中输入以下命令：<br>\n <code>ssh-keygen</code></p>\n<p>随后第一个待输入：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Generating public/private rsa key pair.</span><br><span class=\"line\">Enter file in which to save the key (C:\\Users\\yuyu/.ssh/id_rsa):</span><br></pre></td></tr></table></figure>\n<p>直接回车。</p>\n<p>第二个待输入，可以直接回车不设置密码，如果为了安全你也可以设置：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Created directory &#x27;C:\\Users\\yuyu/.ssh&#x27;.</span><br><span class=\"line\">Enter passphrase (empty for no passphrase):</span><br></pre></td></tr></table></figure>\n<p>接下来要求重复输入密码，忽略了密码就继续回车：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Enter same passphrase again:</span><br></pre></td></tr></table></figure>\n<p>完成生成：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+---[RSA 3072]----+</span><br><span class=\"line\">|                .|</span><br><span class=\"line\">|        . o o . o|</span><br><span class=\"line\">|     . E +o= X .o|</span><br><span class=\"line\">|    . = ++*+= X.o|</span><br><span class=\"line\">|     o .S==o.o.B |</span><br><span class=\"line\">|       ooB.. .o o|</span><br><span class=\"line\">|        +oo    .=|</span><br><span class=\"line\">|          .    oo|</span><br><span class=\"line\">|              .  |</span><br><span class=\"line\">+----[SHA256]-----+</span><br></pre></td></tr></table></figure>\n<p>接下来在以下用户路径中即可找到生成的公钥和私钥文件：<br>\n <code>C:\\Users\\yuyu\\.ssh</code></p>\n<p>其中 <code>yuyu</code>  替换成你自己的用户名。</p>\n<h4 id=\"配置公钥\"><a class=\"markdownIt-Anchor\" href=\"#配置公钥\">#</a> 配置公钥</h4>\n<p>如果你是安装的桌面版 <code>Ubuntu</code> ，就可以很轻松的在 <code>VMWare Workstation</code>  中通过拖动来传输文件。</p>\n<p>在 <code>Ubuntu桌面</code> 中打开文件浏览器，会显示在 Home 目录下 (实际路径是 <code>/Home/你的用户名</code> 、 <code>~</code> )，按下 <code>Ctrl + H</code> ，即可显示隐藏文件。<br>\n可以看到一个目录 <code>.ssh</code> ，进入。</p>\n<p>将 <code>Windows</code>  下生成的公钥文件 <code>id_rsa.pub</code>  复制到 Linux 的 <code>.ssh</code>  目录下。</p>\n<p>在该目录中复制一份 <code>id_rsa.pub</code> ，并更名为 <code>authorized_keys</code> 。</p>\n<h2 id=\"vscode远程连接\"><a class=\"markdownIt-Anchor\" href=\"#vscode远程连接\">#</a> VsCode 远程连接</h2>\n<h3 id=\"查看ip\"><a class=\"markdownIt-Anchor\" href=\"#查看ip\">#</a> 查看 ip</h3>\n<p><code>Linux终端</code> 下输入：<br>\n <code>hostname -I</code></p>\n<p>记下此 ip</p>\n<h3 id=\"配置连接目标\"><a class=\"markdownIt-Anchor\" href=\"#配置连接目标\">#</a> 配置连接目标</h3>\n<p>回到 <code>VsCode</code>  中，由于我们安装了扩展，侧边选项卡新增了一个图标 ( <code>Remote Explorer</code> )。</p>\n<p>选择该选项卡，随后点击 <code>齿轮</code> 按钮。</p>\n<ul>\n<li>\n<img src=\"/posts/54a8/1.png\" class=\"\" title=\"这是一张图片\">\n</li>\n</ul>\n<p>选择第 1 项：</p>\n<ul>\n<li>\n<img src=\"/posts/54a8/2.png\" class=\"\" title=\"这是一张图片\">\n</li>\n</ul>\n<p>配置如下：</p>\n<ul>\n<li>\n<img src=\"/posts/54a8/3.png\" class=\"\" title=\"这是一张图片\">\n</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Read more about SSH config files: https://linux.die.net/man/5/ssh_config</span></span><br><span class=\"line\"><span class=\"comment\"># Host alias</span></span><br><span class=\"line\"><span class=\"comment\">#     HostName hostname</span></span><br><span class=\"line\"><span class=\"comment\">#     User user</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">Host</span> <span class=\"string\">Ubuntu</span></span><br><span class=\"line\">    <span class=\"string\">HostName</span> <span class=\"number\">192.168</span><span class=\"number\">.229</span><span class=\"number\">.132</span></span><br><span class=\"line\">    <span class=\"string\">User</span> <span class=\"string\">yuyu</span></span><br><span class=\"line\">    <span class=\"string\">Port</span> <span class=\"number\">22</span></span><br></pre></td></tr></table></figure>\n<p>将 ip 和用户名 (都是 <code>linux</code>  的) 修改为你的，保存即可。</p>\n<p>配置完成后即出现了你添加的主机，开始连接吧！</p>\n<ul>\n<li>\n<img src=\"/posts/54a8/4.png\" class=\"\" title=\"这是一张图片\">\n</li>\n</ul>\n<p>这里选择 <code>Linux</code> 。</p>\n<ul>\n<li>\n<img src=\"/posts/54a8/5.png\" class=\"\" title=\"这是一张图片\">\n</li>\n</ul>\n<p>继续。</p>\n<ul>\n<li>\n<img src=\"/posts/54a8/6.png\" class=\"\" title=\"这是一张图片\">\n</li>\n</ul>\n<p>由于我们配置了免密登录，此时我们成功连接了！</p>\n<ul>\n<li>\n<img src=\"/posts/54a8/7.png\" class=\"\" title=\"这是一张图片\">\n</li>\n</ul>\n<p>接下来可以打开一个文件夹了，这里我创建了一个 project 的目录来管理我的项目。</p>\n<ul>\n<li>\n<img src=\"/posts/54a8/8.png\" class=\"\" title=\"这是一张图片\">\n</li>\n</ul>\n<p>至此，我们的远程开发环境就已经配置完毕了。</p>\n<h1 id=\"在vscode中构建与调试项目\"><a class=\"markdownIt-Anchor\" href=\"#在vscode中构建与调试项目\">#</a> 在 VsCode 中构建与调试项目</h1>\n<h2 id=\"cmake\"><a class=\"markdownIt-Anchor\" href=\"#cmake\">#</a> CMake</h2>\n<p>先前我就纠结过是选择 CMake 还是 XMake 来管理项目工程，最后还是选择了 CMake，因为用的人比较多吧，学习一下总不是坏事。</p>\n<h3 id=\"安装\"><a class=\"markdownIt-Anchor\" href=\"#安装\">#</a> 安装</h3>\n<p><code>Linux终端</code> 输入命令：<br>\n <code>sudo apt install cmake</code></p>\n<h3 id=\"资料\"><a class=\"markdownIt-Anchor\" href=\"#资料\">#</a> 资料</h3>\n<p>这里推荐两篇文章：<br>\n1.<a href=\"https://subingwen.cn/cmake/CMake-primer/index.html\">CMake 保姆级教程（上）</a><br>\n2.<a href=\"https://subingwen.cn/cmake/CMake-advanced/\">CMake 保姆级教程（下）</a></p>\n<p>能够快速上手 CMake 并了解到足够在当前阶段使用的知识。</p>\n<h2 id=\"vscode扩展-2\"><a class=\"markdownIt-Anchor\" href=\"#vscode扩展-2\">#</a> VsCode 扩展</h2>\n<ol>\n<li><code>C/C++</code>\n<ul>\n<li>语法、浏览等辅助扩展。</li>\n</ul>\n</li>\n<li><code>CMake</code>  &amp;  <code>CMake Tools</code>\n<ul>\n<li>cmake</li>\n</ul>\n</li>\n<li><code>Native Debug</code>\n<ul>\n<li>调试辅助扩展。</li>\n</ul>\n</li>\n<li><code>C/C++ Compile Run</code>\n<ul>\n<li>单文件运行扩展，按 f6 即可直接编译运行当前浏览的源文件。</li>\n</ul>\n</li>\n<li><code>clangd</code>\n<ul>\n<li>这个和 <code>C/C++</code>  是差不多的作用，两个扩展是不能同时启用的 (存在冲突)，我尝试了一下还是 <code>C/C++</code>  更好用一点。</li>\n</ul>\n</li>\n<li><code>Catppuccin Noctis</code>\n<ul>\n<li>非必须，感觉还行的主题。</li>\n</ul>\n</li>\n<li><code>Remote - SSH</code>\n<ul>\n<li>远程开发，已经安装了。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"hello-world\"><a class=\"markdownIt-Anchor\" href=\"#hello-world\">#</a> Hello world！</h2>\n<p>好了，接下来是喜闻乐见的 <code>Hello world</code>  环节。<br>\n咱们来学习如何构建和调试项目。</p>\n<p>我这里在 <code>VsCode</code>  的远程连接状态中打开目录：<br>\n <code>/home/yuyu/project/hello_world</code></p>\n<h3 id=\"编写源代码\"><a class=\"markdownIt-Anchor\" href=\"#编写源代码\">#</a> 编写源代码</h3>\n<p>新建源文件：</p>\n<ul>\n<li>\n<img src=\"/posts/54a8/9.png\" class=\"\" title=\"这是一张图片\">\n</li>\n</ul>\n<p>敲上代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;hello world&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"构建与调试\"><a class=\"markdownIt-Anchor\" href=\"#构建与调试\">#</a> 构建与调试</h3>\n<p>代码是写完了，接下来我们如何构建和调试呢？<br>\n我们这里用 <code>CMake</code>  做示例，尽管只有一个文件，杀鸡用牛刀的感觉，但我们真正开发项目自然是需要更加现代的项目管理方式的。</p>\n<p>同目录下新建 <code>CMakeLists.txt</code>  文件，输入以下内容：</p>\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">cmake_minimum_required</span>(VERSION <span class=\"number\">3.0</span>.<span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"keyword\">project</span>(hello_world)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Output path of the library</span></span><br><span class=\"line\"><span class=\"keyword\">set</span>(EXECUTABLE_OUTPUT_PATH <span class=\"variable\">$&#123;PROJECT_SOURCE_DIR&#125;</span>/bin)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># We need to enable debugging information.</span></span><br><span class=\"line\"><span class=\"keyword\">SET</span>(CMAKE_BUILD_TYPE <span class=\"string\">&quot;Debug&quot;</span>) </span><br><span class=\"line\"><span class=\"keyword\">SET</span>(CMAKE_CXX_FLAGS_DEBUG <span class=\"string\">&quot;$ENV&#123;CXXFLAGS&#125; -O0 -Wall -g2 -ggdb&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">SET</span>(CMAKE_CXX_FLAGS_RELEASE <span class=\"string\">&quot;$ENV&#123;CXXFLAGS&#125; -O3 -Wall&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># All original files in the current path.</span></span><br><span class=\"line\"><span class=\"keyword\">aux_source_directory</span>(<span class=\"variable\">$&#123;PROJECT_SOURCE_DIR&#125;</span> SRC_LIST)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># build</span></span><br><span class=\"line\"><span class=\"keyword\">add_executable</span>(hello_world <span class=\"variable\">$&#123;SRC_LIST&#125;</span>)</span><br></pre></td></tr></table></figure>\n<h4 id=\"构建方法一\"><a class=\"markdownIt-Anchor\" href=\"#构建方法一\">#</a> 构建方法一</h4>\n<p>在终端中输入：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir build</span><br><span class=\"line\">cd build</span><br><span class=\"line\">cmake ..</span><br><span class=\"line\">make all</span><br></pre></td></tr></table></figure>\n<h4 id=\"构建方法二\"><a class=\"markdownIt-Anchor\" href=\"#构建方法二\">#</a> 构建方法二</h4>\n<p>右键 <code>CMakeLists.txt</code>  文件<br>\n 1.Configure All Projects<br>\n2.Build All Projects</p>\n<p>顺利的话都能够看到出现了一个 bin 目录，目录中就有我们编译的文件了。</p>\n<h4 id=\"调试\"><a class=\"markdownIt-Anchor\" href=\"#调试\">#</a> 调试</h4>\n<p>菜单栏中选择 <code>Run</code> -&gt; <code>Add Configuration</code> ，在弹出的菜单中选择 <code>GDB</code> ：</p>\n<ul>\n<li>\n<img src=\"/posts/54a8/10.png\" class=\"\" title=\"这是一张图片\">\n</li>\n</ul>\n<p>将此处的 <code>executable</code>  修改成 <code>hello_world</code></p>\n<ul>\n<li>\n<img src=\"/posts/54a8/11.png\" class=\"\" title=\"这是一张图片\">\n</li>\n</ul>\n<p>回到 <code>hello_world.cpp</code> ，在第 4 行处按下 <code>f9</code>  设置断点， <code>f7</code>  编译， <code>f5</code>  运行。<br>\n成功断下！</p>\n<ul>\n<li>\n<img src=\"/posts/54a8/12.png\" class=\"\" title=\"这是一张图片\">\n</li>\n</ul>\n<h1 id=\"gcc升级至132\"><a class=\"markdownIt-Anchor\" href=\"#gcc升级至132\">#</a> GCC 升级至 13.2</h1>\n<p>由于 Ubuntu22.04 自带的 GCC 版本是 11 的，这里因为个人需要需要升级成 13，特意记录一下。</p>\n<h2 id=\"下载gcc\"><a class=\"markdownIt-Anchor\" href=\"#下载gcc\">#</a> 下载 GCC</h2>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget http://ftp.gnu.org/gnu/gcc/gcc-13.2.0/gcc-13.2.0.tar.gz</span><br></pre></td></tr></table></figure>\n<h2 id=\"解压\"><a class=\"markdownIt-Anchor\" href=\"#解压\">#</a> 解压</h2>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar xf gcc-13.2.0.tar.gz</span><br></pre></td></tr></table></figure>\n<h2 id=\"安装组件\"><a class=\"markdownIt-Anchor\" href=\"#安装组件\">#</a> 安装组件</h2>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd gcc-13.2.0/</span><br><span class=\"line\">./contrib/download_prerequisites</span><br></pre></td></tr></table></figure>\n<h2 id=\"构建\"><a class=\"markdownIt-Anchor\" href=\"#构建\">#</a> 构建</h2>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir build &amp;&amp; cd build</span><br><span class=\"line\">../configure -enable-checking=release -enable-languages=c,c++ -disable-multilib</span><br><span class=\"line\">sudo make -j2</span><br></pre></td></tr></table></figure>\n<h2 id=\"安装-2\"><a class=\"markdownIt-Anchor\" href=\"#安装-2\">#</a> 安装</h2>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo make install</span><br></pre></td></tr></table></figure>\n<h2 id=\"更新c库\"><a class=\"markdownIt-Anchor\" href=\"#更新c库\">#</a> 更新 C++ 库</h2>\n<p>不更新的话编译出来的程序会无法运行。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo add-apt-repository ppa:ubuntu-toolchain-r/test</span><br><span class=\"line\">sudo apt-get update</span><br><span class=\"line\">sudo apt-get install --only-upgrade libstdc++6</span><br></pre></td></tr></table></figure>\n<h2 id=\"查看更新结果\"><a class=\"markdownIt-Anchor\" href=\"#查看更新结果\">#</a> 查看更新结果</h2>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">strings /usr/lib/x86_64-linux-gnu/libstdc++.so.6 | grep GLIBCXX</span><br></pre></td></tr></table></figure>\n<p>以下是新的 C++ 库</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">GLIBCXX_3.4.31</span><br><span class=\"line\">GLIBCXX_3.4.32</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<h1 id=\"参考\"><a class=\"markdownIt-Anchor\" href=\"#参考\">#</a> 参考</h1>\n<ol>\n<li><a href=\"https://www.cnblogs.com/x_wukong/p/4475567.html\">Linux 上安装使用 SSH (ubuntu&amp;&amp;redhat)</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/68577071\">VS Code Remote SSH 配置</a></li>\n<li><a href=\"https://blog.csdn.net/weixin_48617416/article/details/131729829\">Linux 系统 ubuntu22.04 安装最新版的 gcc13.1.0 编译器，支持 c++20、23</a></li>\n<li><a href=\"https://stackoverflow.com/questions/76974555/glibcxx-3-4-32-not-found-error-at-runtime-gcc-13-2-0\">“`GLIBCXX_3.4.32’ not found” error at runtime. GCC 13.2.0</a></li>\n</ol>\n",
            "tags": [
                "C++",
                "Linux"
            ]
        },
        {
            "id": "http://yuyuaqwq.github.io/posts/c23d.html",
            "url": "http://yuyuaqwq.github.io/posts/c23d.html",
            "title": "0.前言",
            "date_published": "2023-10-28T14:25:37.000Z",
            "content_html": "<p>好久没写博客了…</p>\n<p>嗯… 因为某些原因，打算转 Linux 下做 C++ 开发，Windows 的东西就当成业余的兴趣去研究吧。</p>\n<p>这个系列的文章就记录一下我在学习过程中的一些思考，想法，以及备忘吧，就这样吧。</p>\n",
            "tags": [
                "C++",
                "Linux"
            ]
        },
        {
            "id": "http://yuyuaqwq.github.io/posts/f54c.html",
            "url": "http://yuyuaqwq.github.io/posts/f54c.html",
            "title": "【保护模式】2.基于段的保护",
            "date_published": "2023-02-17T14:57:07.000Z",
            "content_html": "<h1 id=\"段寄存器的扩展\"><a class=\"markdownIt-Anchor\" href=\"#段寄存器的扩展\">#</a> 段寄存器的扩展</h1>\n<p>我们需要划分权限，让操作系统和应用处在不同的权限中，以保证系统安全；<br>\n并且决定基于段机制进行延展。</p>\n<p>相较于实模式的 1MB 寻址 (2<sup>20)，保护模式下的寻址范围已经达到了 4GB (2</sup>32)，在汇编指令上可以直接书写 4 字节的内存地址。</p>\n<p>此时，段寄存器的 16 位宽度已经显得有些相形见绌了。<br>\n为了扩展，段寄存器在保护模式下，不再直接存放段的基址，而是存放了<strong>索引</strong>。</p>\n<h2 id=\"全局描述符表-global-descriptor-table\"><a class=\"markdownIt-Anchor\" href=\"#全局描述符表-global-descriptor-table\">#</a> 全局描述符表 (Global Descriptor Table)</h2>\n<p>具体是索引什么呢？<br>\n这里引入了一张表，叫做<strong>全局描述符表</strong>，其实就是在内存中存放的数组。<br>\n其元素叫做<strong>段描述符</strong>，在内存中顺序组织起来，也就是一张表。</p>\n<ul>\n<li>简称<strong> GDT</strong></li>\n</ul>\n<h2 id=\"段选择子\"><a class=\"markdownIt-Anchor\" href=\"#段选择子\">#</a> 段选择子</h2>\n<p>段寄存器由于有了新的用途，因此也有了新的名字，叫做<strong>段选择子</strong>。</p>\n<blockquote>\n<p>大概是意为用于选择段的寄存器吧</p>\n</blockquote>\n<h2 id=\"段描述符\"><a class=\"markdownIt-Anchor\" href=\"#段描述符\">#</a> 段描述符</h2>\n<p>那么说回段描述符，它究竟有什么作用呢？为什么会有这么一个东西呢？</p>\n<blockquote>\n<p>段描述符是 GDT 或 LDT (暂时忽略) 中的元素；<br>\n它为处理器提供诸如段基址，段大小，访问权限及状态等信息。</p>\n</blockquote>\n<ul>\n<li>先来看英特尔白皮书上对段描述符的图示\n<ul>\n<li>\n\n</li>\n</ul>\n</li>\n</ul>\n<p>每个段描述符是 8 字节，由多个字段组成。<br>\n我们发现，字段的排列有些混乱，基址 (Base)、界限 (Limit) 甚至需要跨几个字段组合。</p>\n<blockquote>\n<p>据说是英特尔为了兼容，这里也不做探究。</p>\n</blockquote>\n<p>字段这么多，咱们先来看最熟悉的基址字段。<br>\n还记得 <strong>4. 段寄存器</strong> 小节中的 <strong>CPU 对内存的访问</strong> 那部分吗？<br>\n<strong>在实模式下，cpu 访问任何在汇编指令中显式书写的地址，都会将地址视作偏移 (逻辑地址)，加上段基地址形成真正的物理地址。</strong></p>\n<p>在这里也不例外，只不过段寄存器并不直接存放段基址了，而是存放用于了在 GDT 中选择段描述符的索引值。</p>\n<h2 id=\"访问内存\"><a class=\"markdownIt-Anchor\" href=\"#访问内存\">#</a> 访问内存</h2>\n<p>至此，我们也能初步设想在保护模式下，CPU 是如何基于段访问内存的：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov eax, dword ptr ds:[0x12345678]</span><br></pre></td></tr></table></figure>\n<ol>\n<li>汇编指令中的内存地址 (偏移，<strong>offset</strong>) 是<strong> 0x12345678</strong>；</li>\n<li>汇编指令中指定使用的段寄存器是 <strong>ds</strong>；</li>\n<li>访问 ds 段寄存器，得到<strong>索引 (index)</strong>；</li>\n<li>访问<strong> GDT [index]</strong>，得到段描述符；</li>\n<li>解析段描述符中的<strong> Base</strong> 字段；</li>\n<li><strong>ds.Base</strong> + <strong>offset</strong> = <strong>最终的物理地址</strong>；</li>\n<li>通过物理地址访问内存。</li>\n</ol>\n<h1 id=\"地址分类\"><a class=\"markdownIt-Anchor\" href=\"#地址分类\">#</a> 地址分类</h1>\n<p>至此我们基本了解了，保护模式下 CPU 如何基于段描述符进行寻址。<br>\n并且在上文，我列出了 CPU 将汇编指令中书写的地址转换为物理地址的猜想。</p>\n<p>在保护模式下，实际寻址过程的各个阶段的地址也都是有命名的。<br>\n为了向下深入学习，先了解一下还是有必要的。</p>\n<h2 id=\"逻辑地址相对地址\"><a class=\"markdownIt-Anchor\" href=\"#逻辑地址相对地址\">#</a> 逻辑地址 / 相对地址</h2>\n<p>百度百科的解释是：</p>\n<blockquote>\n<p>指在计算机体系结构中是指应用程序角度看到的内存单元（memory cell）、存储单元（storage element）、网络主机（network host）的地址。 逻辑地址往往不同于物理地址（physical address），通过地址翻译器（address translator）或映射函数可以把逻辑地址转化为物理地址。</p>\n</blockquote>\n<p>咱们简单一点，<strong>还是理解成在汇编指令中显式书写的地址。</strong></p>\n<p>如上一节举例的汇编指令：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov eax, dword ptr ds:[0x12345678]</span><br></pre></td></tr></table></figure>\n<p>我们在当时把它叫做偏移 (offset)，其实它应该叫做<strong>逻辑地址</strong>。</p>\n<p>在实模式下，<strong>逻辑地址 + 段基地址 = 物理地址</strong>；<br>\n在保护模式下， <strong>逻辑地址 + 段基地址 = 线性地址</strong>。</p>\n<h2 id=\"线性地址虚拟地址\"><a class=\"markdownIt-Anchor\" href=\"#线性地址虚拟地址\">#</a> 线性地址 / 虚拟地址</h2>\n<p>摘自百度百科：</p>\n<blockquote>\n<p>线性地址（Linear Address）是逻辑地址到物理地址变换之间的中间层。在分段部件中逻辑地址是段中的偏移地址，然后加上基地址就是线性地址。</p>\n</blockquote>\n<p>线性地址是在保护模式下出现的，通过<strong>页表</strong>将<strong>线性地址</strong>转换成<strong>物理地址</strong>。</p>\n<ul>\n<li><strong>在上节举例时，我们将 &quot;线性地址&quot; 称为 &quot;物理地址&quot;；</strong></li>\n<li><strong>线性地址到物理地址的转换涉及到分页机制，在未学习分页机制之前，请暂时将笔记中所有 &quot;线性地址&quot; 视作 &quot;物理地址&quot;。</strong></li>\n</ul>\n<h2 id=\"物理地址\"><a class=\"markdownIt-Anchor\" href=\"#物理地址\">#</a> 物理地址</h2>\n<p>摘自百度百科：</p>\n<blockquote>\n<p>在存储器里以字节为单位存储信息，为正确地存放或取得信息，每一个字节单元给以一个唯一的存储器地址，称为物理地址（Physical Address），又叫实际地址或绝对地址。</p>\n</blockquote>\n<p>CPU 最终通过<strong>物理地址</strong>去访问<strong>真正的存储单元</strong>。</p>\n<h1 id=\"段描述符缓存\"><a class=\"markdownIt-Anchor\" href=\"#段描述符缓存\">#</a> 段描述符缓存</h1>\n<h2 id=\"gdtr\"><a class=\"markdownIt-Anchor\" href=\"#gdtr\">#</a> GDTR</h2>\n<p>我们说到，既然 CPU 访问内存，需要先访问 GDT，那么 GDT 的地址又是从哪里来的呢？</p>\n<p>CPU 提供了一个 48bit、名为<strong> GDTR</strong> 的寄存器。</p>\n<blockquote>\n<p>高 32bit 存放 GDT 的首地址（线性地址）；<br>\n低 16bit 存放 GDT 的界限，即整个 GDT 表的长度。</p>\n</blockquote>\n<ul>\n<li>通过 windbg 调试 Windows XP，查看<strong> GDTR</strong> 的内容：\n<ul>\n<li>\n\n</li>\n</ul>\n<blockquote>\n<p>关于 windbg 的使用，在内核的学习阶段是非常重要的，所学的知识都需要自己动手实验、验证；<br>\n如果有需要的话，我会考虑再找时间写一篇关于环境配置的文章。</p>\n</blockquote>\n</li>\n</ul>\n<p>在 windbg 下：<br>\n查询<strong> gdtr</strong>，即查询 GDT 的首地址；<br>\n查询<strong> gdtl</strong>，即查询 GDT 的界限。</p>\n<p>CPU 每次访问<strong> GDT</strong> 时，都是从<strong> GDTR</strong> 中获取<strong>线性地址</strong>。</p>\n<p>而 GDTR 的值，是由操作系统在初始化阶段填入的。</p>\n<h2 id=\"不可见寄存器\"><a class=\"markdownIt-Anchor\" href=\"#不可见寄存器\">#</a> 不可见寄存器</h2>\n<p>解决了一个问题，当然又会出现新的问题。<br>\n通过引入<strong> GDT</strong>，我们解决了<strong>段寄存器</strong>宽度太小无法满足保护模式需求的问题。</p>\n<p>但是每次访问内存，都要先查<strong> GDT</strong>，这是不是有点浪费 CPU 的性能了？</p>\n<p>是的，内存访问对于 CPU 而言，是很慢的行为，为了避免这种性能浪费，引入了名为<strong>描述符缓存</strong>的寄存器。<br>\n实际上，<strong>描述符缓存</strong>是不可见的，它在保护模式下是属于<strong>段寄存器</strong>的一部分。</p>\n<p>保护模式下的段寄存器，就分为了<strong>两个部分</strong>：</p>\n<ul>\n<li>段选择子\n<ul>\n<li>原先的段寄存器，可见。</li>\n</ul>\n</li>\n<li>描述符缓存\n<ul>\n<li>对段寄存器进行扩展，不可见。</li>\n</ul>\n</li>\n</ul>\n<p>虽然它不可见，无法直接操作，但是是真实存在的。</p>\n<h2 id=\"段寄存器\"><a class=\"markdownIt-Anchor\" href=\"#段寄存器\">#</a> 段寄存器</h2>\n<ul>\n<li><strong>保护模式下，将段选择子与描述符缓存部分 合称为段寄存器</strong></li>\n</ul>\n<h3 id=\"加载段寄存器\"><a class=\"markdownIt-Anchor\" href=\"#加载段寄存器\">#</a> 加载段寄存器</h3>\n<p>在<strong>加载段选择子</strong>时，CPU 会通过我们给定的段选择子，查询 GDT，得到描述符。</p>\n<p>解析描述符，将字段填入<strong>描述符缓存</strong>中。</p>\n<p>未来每次发生内存访问，都不会去查询 GDT，而是直接从<strong>描述符缓存</strong>中获取字段。</p>\n<p>那么，段选择子是由谁加载的呢？为什么我们平时没有见到过相关的代码呢？<br>\n我们可以在 windows 下打开随意 x64dbg、od 之类的调试器，拖入一个程序，就可以看到，段选择子是存在初始值的，而加载的工作是由操作系统负责的。<br>\n我们也应该明白，所谓的<strong>加载段选择子</strong>，实际上也是<strong>加载描述符缓存</strong>，合称为<strong>加载段寄存器</strong>。</p>\n<h2 id=\"访问内存-2\"><a class=\"markdownIt-Anchor\" href=\"#访问内存-2\">#</a> 访问内存</h2>\n<p>至此，我们可以将上一节的设想进行改进：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov eax, dword ptr ds:[0x12345678]</span><br></pre></td></tr></table></figure>\n<ol>\n<li><strong>逻辑地址</strong>是<strong> 0x12345678</strong>；</li>\n<li>汇编指令中指定使用的段寄存器是 <strong>ds</strong>；</li>\n<li>从<strong>描述符缓存</strong>中取得<strong> Base</strong> 字段</li>\n<li><strong>ds.Base</strong> + <strong>逻辑地址</strong> = <strong>线性地址</strong>；</li>\n<li>通过<strong>线性地址</strong>访问内存。</li>\n</ol>\n<h1 id=\"访问控制\"><a class=\"markdownIt-Anchor\" href=\"#访问控制\">#</a> 访问控制</h1>\n<p>那么，说了这么久保护，究竟应该怎样才能做到所谓的保护呢？</p>\n<p>在第 5 节我们简单提及了权限的建立，通过为不同的段设置权限级别，以<strong>控制不同程序对内存的访问</strong>。</p>\n<h2 id=\"特权级划分\"><a class=\"markdownIt-Anchor\" href=\"#特权级划分\">#</a> 特权级划分</h2>\n<p>接下来咱们想一下，既然是权限，那自然是有高有低，就像身份一样，我是排长，你是士卒，那我的级别自然就比你高。</p>\n<p>接下来我们尝试用两个数字表示两种权限级别：</p>\n<ul>\n<li>0\n<ul>\n<li>最高权限级别，表示当前的 CPU 是以<strong>系统</strong>身份在跑的，操作系统运行在此级别下；</li>\n</ul>\n</li>\n<li>3\n<ul>\n<li>最低权限级别，表示当前的 CPU 是以<strong>用户</strong>身份在跑的，应用程序运行在此级别下。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"再次构思\"><a class=\"markdownIt-Anchor\" href=\"#再次构思\">#</a> 再次构思</h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">地址</th>\n<th style=\"text-align:left\">程序</th>\n<th style=\"text-align:left\">基地址 (Base)</th>\n<th style=\"text-align:left\">访问此段需要权限 (DPL)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">0x00 ~ 0x3f</td>\n<td style=\"text-align:left\">提供给操作系统内核存放数据</td>\n<td style=\"text-align:left\">0x00</td>\n<td style=\"text-align:left\">0</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">0x40 ~ 0x7f</td>\n<td style=\"text-align:left\">提供给操作系统内核存放代码</td>\n<td style=\"text-align:left\">0x40</td>\n<td style=\"text-align:left\">0</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">0x80 ~ 0xcf</td>\n<td style=\"text-align:left\">提供给程序 A 存放数据</td>\n<td style=\"text-align:left\">0x80</td>\n<td style=\"text-align:left\">3</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">0xd0 ~ 0xff</td>\n<td style=\"text-align:left\">提供给程序 A 存放代码</td>\n<td style=\"text-align:left\">0xd0</td>\n<td style=\"text-align:left\">3</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">…</td>\n<td style=\"text-align:left\">…</td>\n<td style=\"text-align:left\">…</td>\n<td style=\"text-align:left\">…</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>内核是指操作系统驻留在内存中的最基本的部分。</p>\n</blockquote>\n<ul>\n<li>同时，我们已经学习过段描述符了，<strong>段基址</strong>是放到段描述符中的，那么<strong>访问权限</strong>自然也可以放到段描述符中。</li>\n</ul>\n<h2 id=\"基本控制\"><a class=\"markdownIt-Anchor\" href=\"#基本控制\">#</a> 基本控制</h2>\n<p>假定我是 CPU，此刻我的 ip 指针指向了应用程序中的指令序列，并且我的<strong>当前身份是用户</strong>。<br>\n一旦我试图<strong>访问我不应该访问的内存</strong> (如提供给操作系统内核存放数据的段)，因为我没有那么高的特权，<strong>就应当受到制止。</strong></p>\n<h3 id=\"表明当前程序的身份\"><a class=\"markdownIt-Anchor\" href=\"#表明当前程序的身份\">#</a> 表明当前程序的身份</h3>\n<p>既然我们知道，访问内存中的段增加了一项对权限的例行检查，那么自然就需要有一项能表示我们当前身份的东西了。</p>\n<h3 id=\"dpl\"><a class=\"markdownIt-Anchor\" href=\"#dpl\">#</a> DPL</h3>\n<p>组成段描述符的字段之一，表明段描述符的特权级，访问该段应具备的权限。</p>\n<ul>\n<li>Descriptor Privilege Level，描述符特权级</li>\n</ul>\n<h3 id=\"rpl\"><a class=\"markdownIt-Anchor\" href=\"#rpl\">#</a> RPL</h3>\n<p>还记得我们之前学过的段选择子吗？当时我们只说了，段选择子用于从 GDT 中选择段描述符并加载，实际上，段选择子一共有 16bit，其中高 13bit，才是 GDT 的索引。</p>\n<p>在段选择子中，低 3bit 是另作他用的，其中低 2bit，用于表示 CPU 加载段描述符时的请求权限。</p>\n<ul>\n<li><strong>即 RPL，Requested Privilege Level ，请求特权级</strong></li>\n</ul>\n<p><strong>意为发起访问请求时的特权级</strong></p>\n<h3 id=\"cpl\"><a class=\"markdownIt-Anchor\" href=\"#cpl\">#</a> CPL</h3>\n<p>cs 段选择子与 ss 段选择子的 RPL 字段。</p>\n<ul>\n<li><strong>又称为 CPL，Current Privilege Level，当前特权级</strong></li>\n</ul>\n<h3 id=\"示例\"><a class=\"markdownIt-Anchor\" href=\"#示例\">#</a> 示例</h3>\n<ul>\n<li>接下来我们通过使用机密文档来举个栗子，尝试理解它。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">文档</th>\n<th style=\"text-align:center\">最低阅读准许级别</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">文档 A</td>\n<td style=\"text-align:center\">排长</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">文档 B</td>\n<td style=\"text-align:center\">连长</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>\n<p>首先，假定军官可以申请阅读机密文档，并且每个机密文档都有对应的权限要求；</p>\n</li>\n<li>\n<p>又假定我是排长，想阅读排长级别才能阅读的机密文件，于是我写了一份申请报告 (请求)，上面写着 **“排长级别”<strong>，并且对审核人员说，我希望能阅读</strong>文档 A**，审核人员在查看了报告上的请求级别，再与文档 A 的级别进行比较，如果报告上的级别达到了文档 A 的阅读准许级别，审核人员则会批准，我就可以阅读了。</p>\n</li>\n<li>\n<p>但是当我想阅读具有连长身份才能阅读的机密文档时，于是我依旧提交申请报告，填写 **“排长级别”<strong>，并告诉他我希望阅读</strong>文档 B**，负责审批的人一看，你这不对啊，你这申请报告上写的是排长级别，但你想阅读的文档是连长级别才能阅读的机密文档，拒绝也就是理所当然的事。</p>\n</li>\n</ul>\n<blockquote>\n<p>此处 以军官的身份与阅读机密文件进行比喻 仅出于个人认为易于理解的想法，无其他意义，我尊敬军人，热爱祖国。</p>\n</blockquote>\n<p><strong>既然有 RPL 了，那么为什么要多此一举，弄出来一个 CPL，这个 CPL 又是个什么东西呢？</strong></p>\n<p>在上面我们强调的是<strong>请求</strong>，那么为什么要划分<strong>请求</strong>和<strong>当前</strong>呢？</p>\n<p>就好比阅读机密文档，需要有足够的身份，才能拥有对应的权限。</p>\n<ul>\n<li>请求\n<ul>\n<li>即我希望阅读的机密文档的级别；</li>\n</ul>\n</li>\n<li>当前\n<ul>\n<li>表示我现在的身份。</li>\n</ul>\n</li>\n</ul>\n<p>如果没有对<strong>当前身份</strong>的检查，那么即便我是排长，我也可以<strong>提交一个 &quot;连长级别&quot; 的申请报告</strong>。</p>\n<ul>\n<li><strong>只校验请求是不够的，更重要的是当前的身份</strong>。</li>\n</ul>\n<blockquote>\n<p>程序的运行是依赖于 CPU 的，而 CPU 通过 CPL，辨认当前被 CPU 取指执行的程序的身份；通过 RPL，确定当前程序发起的请求时指定的特权级。</p>\n</blockquote>\n<p>可能有的同学又要发炎啦，啊那我直接看身份级别不就行了，为什么还要多此一举，弄出来一个请求级别。</p>\n<h3 id=\"arpl\"><a class=\"markdownIt-Anchor\" href=\"#arpl\">#</a> ARPL</h3>\n<p>咱们再看一个例子，假设我有一个朋友，他是团长，在平时我抽不开身的时候，就干脆让他帮我递交<strong>申请报告</strong>，并且告诉他我想查看什么文档，让他替我带回文档。</p>\n<p>而 RPL 的意义在于此，假设我想阅读<strong>文档 B</strong>，但是我转交给他的申请报告写的是 &quot;排长级别&quot;，就算他<strong>以团长的身份递交申请报告，因为申请报告中填写的级别不足，依旧会被拒绝</strong>。</p>\n<p>这个时候新的问题又来了，如果我转交给他的是一个 &quot;连长级别&quot; 的申请报告呢？这个时候的检查工作就落在团长的身上，他必须<strong>先检查我的身份和我的申请报告</strong>，如果我的申请报告与我的身份存在问题，那么他就会将我递交的申请报告进行修改，虽然他依旧会原样传达我的话 (我想阅读<strong>文档 B</strong>)，但是审核人员可以通过查阅申请报告，以及团长传递的话，从而选择拒绝与否。</p>\n<h4 id=\"检查工作\"><a class=\"markdownIt-Anchor\" href=\"#检查工作\">#</a> 检查工作</h4>\n<p>而这个检查与修改的过程就是 ARPL 指令所做的工作</p>\n<ul>\n<li>\n<p>我们的<strong>应用 (连长)<strong> 委托</strong>操作系统 (团长)<strong> 访问指定的</strong>段 (机密文档)</strong>；</p>\n</li>\n<li>\n<p>应用的<strong> RPL (申请报告)</strong>，以及应用的<strong> CPL (身份)</strong>，<strong>操作系统</strong>通过 ARPL 指令进行校验以及修改，以保证操作系统不会不小心替应用访问了不应该访问的段。</p>\n</li>\n<li>\n<p>最后由<strong> cpu (审核员)<strong> 检查段的访问权限</strong> DPL (机密文档的阅读权限)</strong>；</p>\n</li>\n<li>\n<p><strong>而 应用是如何委托操作系统 等内容，请在学习权限切换后，再次回来复习。</strong></p>\n</li>\n</ul>\n<h1 id=\"权限检查\"><a class=\"markdownIt-Anchor\" href=\"#权限检查\">#</a> 权限检查</h1>\n<p>我们讲述了基于段机制的内存访问是如何受到控制的。</p>\n<p>我想，各位看完之后依旧会存在不少疑惑，比如所谓的<strong>访问</strong>，对权限的检查，具体是发生在什么时候呢？</p>\n<h2 id=\"段的分类\"><a class=\"markdownIt-Anchor\" href=\"#段的分类\">#</a> 段的分类</h2>\n<p>我们知道，由地址上连续的多个内存单元组织而成的内存区域，就可以将其称之为段。<br>\n为了减少错误的出现与降低开发难度，在实模式时，就已经开始将内存划分为多个段，并且根据用途为段进行了分类。</p>\n<p>在前面的笔记我们粗略提及过段的分类，本篇再对保护模式下的段的分类进行讲述。</p>\n<h2 id=\"实模式\"><a class=\"markdownIt-Anchor\" href=\"#实模式\">#</a> 实模式</h2>\n<p>在实模式下，段的分类更偏向于程序设计者自主安排，我不强求，你想怎么安排，就可以怎么安排，重要的是哪个段寄存器指向了那块内存区域。</p>\n<p>如将 x8000 这个地址作为段的基址，我可以将其赋值给 cs，也可以将其赋值给 ds，取决于我如何使用它。</p>\n<h2 id=\"保护模式\"><a class=\"markdownIt-Anchor\" href=\"#保护模式\">#</a> 保护模式</h2>\n<p>为何我会说实模式的段分类下是程序设计者的自主安排，难道保护模式就不是了吗？<br>\n实际上，对于应用程序设计者而言，确实是的。</p>\n<p>你也许会想，实模式的段寄存器我可以随便加载，保护模式的段选择子就不可以了吗？</p>\n<p>很遗憾，应用程序设计者确实没有这么大的权限，要不为何会着重<strong>保护</strong>二字呢？</p>\n<h2 id=\"段描述符相关字段\"><a class=\"markdownIt-Anchor\" href=\"#段描述符相关字段\">#</a> 段描述符相关字段</h2>\n<p>咱们还是要看英特尔白皮书中对段描述符的解释，在往后的笔记中还会经常与它见面。</p>\n<pre><code>- &#123;% asset_img 1.png 这是一张图片 %&#125;\n</code></pre>\n<h3 id=\"s字段\"><a class=\"markdownIt-Anchor\" href=\"#s字段\">#</a> S 字段</h3>\n<ul>\n<li>S 字段为 1\n<ul>\n<li>当前段描述符描述的段是代码段或数据段</li>\n</ul>\n</li>\n<li>S 字段为 0\n<ul>\n<li>当前段描述符描述的段是系统段</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"数据段\"><a class=\"markdownIt-Anchor\" href=\"#数据段\">#</a> 数据段</h3>\n<p>数据段是指用于存放数据的内存区域，向下还能再细分为<strong>只读数据段</strong>、<strong>栈段</strong>等，供 CPU 读或写。</p>\n<h3 id=\"代码段\"><a class=\"markdownIt-Anchor\" href=\"#代码段\">#</a> 代码段</h3>\n<p>代码段是指用于存放指令序列的内存区域，供 CPU 执行。</p>\n",
            "tags": [
                "保护模式",
                "Windows内核"
            ]
        },
        {
            "id": "http://yuyuaqwq.github.io/posts/4aaf.html",
            "url": "http://yuyuaqwq.github.io/posts/4aaf.html",
            "title": "【保护模式】1.初探保护模式与分段机制",
            "date_published": "2023-02-17T14:34:48.000Z",
            "content_html": "<h1 id=\"保护模式\"><a class=\"markdownIt-Anchor\" href=\"#保护模式\">#</a> 保护模式</h1>\n<ul>\n<li>保护模式是在硬件层面提供的 CPU 运行机制，是现代操作系统的根本。</li>\n<li>没有保护模式，操作系统是没有安全性可言的。</li>\n</ul>\n<h2 id=\"何为保护\"><a class=\"markdownIt-Anchor\" href=\"#何为保护\">#</a> 何为保护</h2>\n<ul>\n<li>\n<p>指令是存放在内存中的</p>\n</li>\n<li>\n<p>假定你的程序试图对操作系统的关键代码进行破坏：</p>\n<ul>\n<li><code>mov byte ptr ds:[kernel], 0x90</code></li>\n</ul>\n</li>\n<li>\n<p>操作系统应该如何制止？</p>\n</li>\n<li>\n<p>也许这个时候有同学发炎了：</p>\n<ul>\n<li>“也许操作系统它能监控呢？”</li>\n</ul>\n</li>\n<li>\n<p>答案是，监控你程序的并不是操作系统，这种工作必须在硬件层完成</p>\n<ul>\n<li>很简单的道理，实际上运行指令的是 CPU，只有 CPU 知道当前 CPU 正在做什么事，操作系统是不可能知道的\n<ul>\n<li>操作系统也是由 CPU 运行的指令序列。</li>\n</ul>\n</li>\n<li>除非 CPU 提供了一种回调机制，运行任何指令都先运行操作系统的指令，但这是不现实的，对性能影响过于严重\n<ul>\n<li>实现一套虚拟机也可以保证安全性，但是依旧存在性能问题，也不在本文讨论范围之内。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"模式之分\"><a class=\"markdownIt-Anchor\" href=\"#模式之分\">#</a> 模式之分</h2>\n<ul>\n<li>\n<p>我们得到了结论，保证 操作系统的安全性 这种机制，必须是硬件提供的。</p>\n<ul>\n<li>在早期，CPU 并未提供这种保护模式，为此才划分出了 “实模式” 与 “保护模式”</li>\n<li>在保护模式出现时，为了兼容，因此也诞生了 “虚拟 8086 模式”，但已经不重要了，也不在本文讨论范围内。</li>\n</ul>\n</li>\n<li>\n<p><strong>在学习保护模式时也需要牢记，保护模式是硬件层的东西，切勿与操作系统混淆。</strong></p>\n</li>\n</ul>\n<h1 id=\"物理内存\"><a class=\"markdownIt-Anchor\" href=\"#物理内存\">#</a> 物理内存</h1>\n<ul>\n<li>我们都知道，我们可见的物理内存，其实就是<strong>连续的、对每一个单元进行了地址编号的很大的存储器。</strong></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">地址</th>\n<th style=\"text-align:left\">数据</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">0x00</td>\n<td style=\"text-align:left\">0xff</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">0x01</td>\n<td style=\"text-align:left\">0x00</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">…</td>\n<td style=\"text-align:left\">…</td>\n</tr>\n</tbody>\n</table>\n<p><em>表格仅为举例，与真实物理内存布局无关</em></p>\n<ul>\n<li>\n<p>程序必须是存放在内存中，才能被 CPU<strong> 取指执行</strong>。</p>\n</li>\n<li>\n<p>假定你是操作系统 (给你管理硬件资源)，那么多个程序又如何存放比较好呢？</p>\n</li>\n</ul>\n<hr>\n<h2 id=\"多个程序的安置\"><a class=\"markdownIt-Anchor\" href=\"#多个程序的安置\">#</a> 多个程序的安置</h2>\n<ul>\n<li>可能有同学回答了：\n<ul>\n<li>我<strong>顺序加载</strong>嘛，第一个程序从哪里占用到哪里，第二个程序从哪里占用到哪里</li>\n</ul>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">地址</th>\n<th style=\"text-align:left\">程序</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">0x00 ~ 0x7f</td>\n<td style=\"text-align:left\">提供给程序 A</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">0x80 ~ 0xff</td>\n<td style=\"text-align:left\">提供给程序 B</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">…</td>\n<td style=\"text-align:left\">…</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>\n<p>如表格所述，我们成功将两个程序分别放到了不同的位置。</p>\n</li>\n<li>\n<p>这样子他们就互不干扰了，我们真是个小天才。</p>\n</li>\n</ul>\n<h2 id=\"问题仍在\"><a class=\"markdownIt-Anchor\" href=\"#问题仍在\">#</a> 问题仍在</h2>\n<ul>\n<li>\n<p>很遗憾，这样子的程序，运行依旧存在困难</p>\n<ul>\n<li>在编写程序的时候，无法预知程序在运行时究竟会被加载到内存的哪个位置。</li>\n<li>假设<strong> B</strong> 选择 <code>0x40</code>  这个地址存放一些数据，那不是正好破坏了<strong> A</strong> 的指令序列？</li>\n</ul>\n</li>\n<li>\n<p>为此，<strong>内存分段</strong>诞生了</p>\n</li>\n</ul>\n<hr>\n<h1 id=\"内存分段\"><a class=\"markdownIt-Anchor\" href=\"#内存分段\">#</a> 内存分段</h1>\n<ul>\n<li>\n<p>如果我们在编写程序的时候，任何使用内存的指令，填写的内存地址，都是一个<strong>偏移值</strong>，让 CPU 替我们去与<strong>基地址</strong>相加，最终得到真正的<strong>物理地址</strong>。</p>\n</li>\n<li>\n<p>那么不管我们的程序被加载到内存的哪个位置，只要提供一个正确的<strong>基地址</strong>，就可以让多个程序互不干扰了！</p>\n</li>\n</ul>\n<h2 id=\"示例\"><a class=\"markdownIt-Anchor\" href=\"#示例\">#</a> 示例</h2>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">地址</th>\n<th style=\"text-align:left\">程序</th>\n<th style=\"text-align:left\">基地址</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">0x00 ~ 0x7f</td>\n<td style=\"text-align:left\">提供给程序 A</td>\n<td style=\"text-align:left\">0x00</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">0x80 ~ 0xff</td>\n<td style=\"text-align:left\">提供给程序 B</td>\n<td style=\"text-align:left\">0x80</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">…</td>\n<td style=\"text-align:left\">…</td>\n<td style=\"text-align:left\">…</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>\n<p>假设<strong> B</strong> 选择 <code>0x40</code>  这个地址存放一些数据，我们还会破坏<strong> A</strong> 的指令序列吗？</p>\n</li>\n<li>\n<p>这样看上去，是不是像给<strong>内存分段</strong>了一样？</p>\n<ul>\n<li><code>0x00 ~ 0x7f</code>  看作一段，分给<strong>程序 A</strong></li>\n<li><code>0x80 ~ 0xff</code>  看作一段，分给<strong>程序 B</strong></li>\n</ul>\n</li>\n</ul>\n<hr>\n<p>实模式下的分段机制大抵如此。</p>\n<h1 id=\"段寄存器\"><a class=\"markdownIt-Anchor\" href=\"#段寄存器\">#</a> 段寄存器</h1>\n<ul>\n<li>\n<p>想来各位读者对寄存器都有所了解，既然我们需要一个容器来存放<strong>段的基地址</strong>，寄存器自然是不错的选择。</p>\n</li>\n<li>\n<p>但是通用寄存器本身数量也不够多，再想腾出来存放<strong>段基址</strong>，也是心有余而力不足了。</p>\n</li>\n<li>\n<p>因此，理所当然的，就有了以<strong>段</strong>为名的<strong>段寄存器</strong>。</p>\n</li>\n</ul>\n<h2 id=\"ds寄存器\"><a class=\"markdownIt-Anchor\" href=\"#ds寄存器\">#</a> ds 寄存器</h2>\n<ul>\n<li>ds，即 data segment，意为数据段</li>\n<li>咱们一看就知道，这个东西就是和<strong>数据</strong>、<strong>段</strong> 相关的。</li>\n<li>它也十分简单，16 位的宽度，作用就是存放数据段的基址</li>\n</ul>\n<blockquote>\n<p>注解</p>\n<blockquote>\n<p>实际在实模式下，物理地址的转换公式略微复杂一些<br>\n (ds &lt;&lt; 4) + address = 最终的物理地址</p>\n</blockquote>\n</blockquote>\n<h3 id=\"结合先前的示例\"><a class=\"markdownIt-Anchor\" href=\"#结合先前的示例\">#</a> 结合先前的示例</h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">地址</th>\n<th style=\"text-align:left\">程序</th>\n<th style=\"text-align:left\">基地址</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">0x00 ~ 0x7f</td>\n<td style=\"text-align:left\">提供给程序 A</td>\n<td style=\"text-align:left\">0x00</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">0x80 ~ 0xff</td>\n<td style=\"text-align:left\">提供给程序 B</td>\n<td style=\"text-align:left\">0x80</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">…</td>\n<td style=\"text-align:left\">…</td>\n<td style=\"text-align:left\">…</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>我们选择让<strong> B</strong> 在 <code>0x40</code>  这个位置存放一些数据</li>\n<li>而现在我们有了 ds 寄存器，只要在程序运行前初始化 ds 寄存器，就可以做到不破坏<strong> A</strong> 的程序了。</li>\n</ul>\n<h2 id=\"根据段的用途进行划分\"><a class=\"markdownIt-Anchor\" href=\"#根据段的用途进行划分\">#</a> 根据段的用途进行划分</h2>\n<ul>\n<li>但是这样子明显我们还需要小心翼翼，毕竟虽然不会破坏其他程序了，但不代表不会破坏自己的指令序列啊！</li>\n<li><strong>代码</strong>和<strong>数据</strong>都放在一个段里，是不是不便管理？</li>\n<li>如果我们对代码和数据再做进一步的<strong>划分</strong>，是不是更好？</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">地址</th>\n<th style=\"text-align:left\">程序</th>\n<th style=\"text-align:left\">基地址</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">0x00 ~ 0x3f</td>\n<td style=\"text-align:left\">提供给程序 A 存放数据</td>\n<td style=\"text-align:left\">0x00</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">0x40 ~ 0x7f</td>\n<td style=\"text-align:left\">提供给程序 A 存放代码</td>\n<td style=\"text-align:left\">0x40</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">0x80 ~ 0xcf</td>\n<td style=\"text-align:left\">提供给程序 B 存放数据</td>\n<td style=\"text-align:left\">0x80</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">0xd0 ~ 0xff</td>\n<td style=\"text-align:left\">提供给程序 B 存放代码</td>\n<td style=\"text-align:left\">0xd0</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">…</td>\n<td style=\"text-align:left\">…</td>\n<td style=\"text-align:left\">…</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>\n<p>为此，自然是可以存在更多的段寄存器</p>\n<ul>\n<li>cs(code segment)</li>\n<li>ss(stack segment)</li>\n<li>ds(data segment)</li>\n<li>…</li>\n</ul>\n</li>\n<li>\n<p>还是先前的问题，程序<strong> B</strong> 试图在 <code>0x40</code>  这个地址存放数据，我们只需要让 cpu 知道，<strong>数据段基址</strong>是 <code>0x80</code></p>\n<ul>\n<li><code>0x80 + 0x40 = 0xc0</code></li>\n</ul>\n</li>\n<li>\n<p>我们只需要划分好各个段，就可以很好的让程序工作了！</p>\n</li>\n</ul>\n<h2 id=\"cpu对内存的访问\"><a class=\"markdownIt-Anchor\" href=\"#cpu对内存的访问\">#</a> CPU 对内存的访问</h2>\n<ul>\n<li>为此，cpu 也被设计为，在<strong>访问任何汇编指令中显式书写的内存地址时</strong>，都会先根据<strong>用途</strong>选择<strong>段寄存器</strong>，得到<strong>段基地址</strong>，<strong>指令中的地址</strong>视作<strong>偏移 (逻辑地址)</strong>，<strong>运算后</strong>得到<strong>真正的物理地址</strong>，再进行<strong>访问</strong>。</li>\n</ul>\n<blockquote>\n<p>注解</p>\n<blockquote>\n<p>读写内存，可以划分为对数据段的访问<br>\n执行指令，可以划分为对代码段的访问<br>\n…</p>\n</blockquote>\n</blockquote>\n<h1 id=\"初探基于段的保护\"><a class=\"markdownIt-Anchor\" href=\"#初探基于段的保护\">#</a> 初探基于段的保护</h1>\n<ul>\n<li>\n<p>在实模式下，对于任何存在于内存中的指令序列，cpu 是<strong>一视同仁</strong>的，ip 指哪它跑哪，埋头苦干。</p>\n</li>\n<li>\n<p>操作系统将我们的程序加载到内存，使得 cs:ip 指向我们程序的入口点之后，<strong>我们想干什么，就不是操作系统能说了算了</strong>。</p>\n<ul>\n<li>当然我们也可以反手来一波背刺，<strong>捅死操作系统</strong>。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"尝试分段\"><a class=\"markdownIt-Anchor\" href=\"#尝试分段\">#</a> 尝试分段</h2>\n<ul>\n<li>\n<p>你可能想到了，啊，我们先前不是才讲过，分段不就好了吗？</p>\n</li>\n<li>\n<p>其实所谓的分段，也是建立在大家都<strong>规规矩矩</strong>，<strong>和睦相处</strong>的情况下，才能最大程度上避免 &quot;不小心&quot; 出现的问题。</p>\n<ul>\n<li>简单地说，全看编写程序的人自觉不自觉。</li>\n<li>既然操作系统能<strong>修改 cs、ds 段寄存器</strong>，我们有何不可呢？</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"权限的建立\"><a class=\"markdownIt-Anchor\" href=\"#权限的建立\">#</a> 权限的建立</h2>\n<ul>\n<li>\n<p>首先，咱们既然要保证<strong>安全</strong>，那自然就要划分哪些是应用能做的，哪些是应用不能做的。</p>\n</li>\n<li>\n<p>其次，总归要有程序去管理软硬件的，操作系统的不受限制也理所应当了。</p>\n</li>\n</ul>\n<h3 id=\"权限划分\"><a class=\"markdownIt-Anchor\" href=\"#权限划分\">#</a> 权限划分</h3>\n<ul>\n<li>\n<p>既然有了<strong>不能做</strong>和<strong>能做</strong>之分，并且还有了 &quot;区别对待&quot;，<strong>权限</strong>自然也就建立起来了。</p>\n</li>\n<li>\n<p>至此，咱们初步确定了<strong>权限</strong>的划分。</p>\n<ul>\n<li>常规应用，拥有<strong>部分权限</strong>；</li>\n<li>操作系统，拥有<strong>所有权限</strong>。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"段机制的延展\"><a class=\"markdownIt-Anchor\" href=\"#段机制的延展\">#</a> 段机制的延展</h2>\n<ul>\n<li>\n<p>咱们最先想到的，最不能让应用去乱搞的是什么呢？</p>\n</li>\n<li>\n<p>首先就是不能让应用去破坏咱们的操作系统，咱们首先要把自己<strong>保护</strong>起来。</p>\n<ul>\n<li><strong>如果应用能随意修改操作系统的指令序列，那么所谓的保护将毫无意义</strong>。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"初步构想\"><a class=\"markdownIt-Anchor\" href=\"#初步构想\">#</a> 初步构想</h3>\n<ul>\n<li>\n<p>我们可以沿用实模式下存在的段机制，为段设立权限。</p>\n<ul>\n<li>应用的指令序列处在一个<strong>权限受限</strong>的段中，<strong>不允许访问除自己段内的任何内存。</strong></li>\n</ul>\n</li>\n<li>\n<p>而操作系统就处在拥有<strong>最高特权</strong>的段中，<strong>掌有生杀大权</strong>。</p>\n</li>\n</ul>\n",
            "tags": [
                "保护模式",
                "Windows内核"
            ]
        },
        {
            "id": "http://yuyuaqwq.github.io/posts/91e5.html",
            "url": "http://yuyuaqwq.github.io/posts/91e5.html",
            "title": "【Git】远程仓库登录",
            "date_published": "2023-01-31T01:05:39.000Z",
            "content_html": "<h2 id=\"github身份验证\"><a class=\"markdownIt-Anchor\" href=\"#github身份验证\">#</a> Github 身份验证</h2>\n<p>Github 通过 SSH 登录，通过提前在 Github 上设置公钥，以及本地存储的私钥，使得 Github 能够验证身份的合法性。</p>\n<h2 id=\"配置用户名和邮箱\"><a class=\"markdownIt-Anchor\" href=\"#配置用户名和邮箱\">#</a> 配置用户名和邮箱</h2>\n<ul>\n<li><code>git config --global user.name &quot;&lt;用户名&gt;&quot;</code></li>\n<li><code>git config --global user.email &quot;&lt;邮箱地址&gt;&quot;</code></li>\n</ul>\n<h2 id=\"查看配置\"><a class=\"markdownIt-Anchor\" href=\"#查看配置\">#</a> 查看配置</h2>\n<ul>\n<li><code>git config --list</code></li>\n</ul>\n<h2 id=\"密钥\"><a class=\"markdownIt-Anchor\" href=\"#密钥\">#</a> 密钥</h2>\n<p>生成密钥对：</p>\n<ul>\n<li><code>ssh-keygen -t rsa -C &quot;&lt;邮箱地址|用户名|...&gt;&quot;</code></li>\n</ul>\n<p>放置在～/.ssh 目录中</p>\n<ul>\n<li>config 文件指定有效的密钥文件</li>\n<li>Windows 下可以在 Git Bash 中查看路径</li>\n</ul>\n<p>默认公钥文件</p>\n<ul>\n<li>id_rsa.pub</li>\n</ul>\n<p>默认私钥文件</p>\n<ul>\n<li>id_rsa</li>\n</ul>\n<p>打开公钥文件，将其复制。</p>\n<h2 id=\"设置公钥\"><a class=\"markdownIt-Anchor\" href=\"#设置公钥\">#</a> 设置公钥</h2>\n<ol>\n<li>打开 Github</li>\n<li>在个人设置 -&gt; SSH and GPG keys -&gt; SSH keys 中，添加刚刚复制的公钥。</li>\n</ol>\n<h2 id=\"验证登录\"><a class=\"markdownIt-Anchor\" href=\"#验证登录\">#</a> 验证登录</h2>\n<ul>\n<li><code>ssh -T git@github.com</code></li>\n</ul>\n<p>出现 “Hi xxxx! …” 表示配置完成</p>\n",
            "tags": [
                "Git",
                "版本管理"
            ]
        },
        {
            "id": "http://yuyuaqwq.github.io/posts/75b5.html",
            "url": "http://yuyuaqwq.github.io/posts/75b5.html",
            "title": "【C/C++逆向】AMD64架构下MSVC编译器的调用约定与栈帧分析",
            "date_published": "2022-12-19T03:36:37.000Z",
            "content_html": "",
            "tags": []
        },
        {
            "id": "http://yuyuaqwq.github.io/posts/5d13.html",
            "url": "http://yuyuaqwq.github.io/posts/5d13.html",
            "title": "【密码学】PKI体系：谁来保证我的通信安全？",
            "date_published": "2022-12-08T07:31:19.000Z",
            "content_html": "<h1 id=\"PKI概述\"><a href=\"#PKI概述\" class=\"headerlink\" title=\"PKI概述\"></a>PKI概述</h1><p><strong>Public Key Infrastructure，即公钥基础设施。</strong></p>\n<p>以下摘自百度百科：</p>\n<blockquote>\n<p>公钥基础设施是一个包括硬件、软件、人员、策略和规程的集合，用来实现基于公钥密码体制的密钥和证书的产生、管理、存储、分发和撤销等功能。<br>PKI体系是计算机软硬件、权威机构及应用系统的结合。它为实施电子商务、电子政务、办公自动化等提供了基本的安全服务，从而使那些彼此不认识或距离很远的用户能通过信任链安全地交流。</p>\n</blockquote>\n<p>当然，要是光看定义能看懂的话，想必各位也不会见到这一篇文章了，贴出定义只是个人习惯，咱们往下看。</p>\n<h1 id=\"明文与密文\"><a href=\"#明文与密文\" class=\"headerlink\" title=\"明文与密文\"></a>明文与密文</h1><p>首先咱们要知道，咱们能够阅读理解的东西是<code>明文</code>，比如远在天边的网友给你发的一条qq消息，你看到的时候它就是明文，这样你才能看得懂你的网友想和你说些什么。</p>\n<p>当然，你看得懂，别人也看得懂，中文嘛，大家都学过。<br>你想着，我要是不想赤裸裸的让别人窥探我的聊天内容是吧，咱们多少还是希望能有些隐私的。</p>\n<p><strong>加密</strong>自然而然的出现了。</p>\n<p>我们通过某种方法对明文原本的信息进行可逆的改变，别人只要不知道我们是如何改变的，就无法还原，只有我们才能够还原为明文。<br>加密后无法直接理解的信息，我们就叫做<code>密文</code>。</p>\n<h1 id=\"前置知识\"><a href=\"#前置知识\" class=\"headerlink\" title=\"前置知识\"></a>前置知识</h1><h2 id=\"密钥\"><a href=\"#密钥\" class=\"headerlink\" title=\"密钥\"></a>密钥</h2><p>通常也是一组数据，就像现实世界的钥匙，是<strong>加锁/解锁</strong>的关键。</p>\n<h2 id=\"对称加密\"><a href=\"#对称加密\" class=\"headerlink\" title=\"对称加密\"></a>对称加密</h2><p>首先创建一把<strong>密钥</strong>。</p>\n<p>通过这把密钥可以加密明文；<br>对密文的解密也需要<strong>同样的一把密钥</strong>。<br><em>如同常见的钥匙和锁一般，加锁和解锁都是同一把钥匙。</em></p>\n<blockquote>\n<p>缺陷：在公共的网络环境中，密钥难以安全传递。</p>\n</blockquote>\n<h2 id=\"非对称加密\"><a href=\"#非对称加密\" class=\"headerlink\" title=\"非对称加密\"></a>非对称加密</h2><p>创建两把密钥，一把公钥，一把私钥，<strong>这两把密钥是对应关系</strong>。<br>公钥是公开的，任何人都可以获得。<br>私钥是私有的，只有创建者持有。</p>\n<p><strong><em>公钥加密的东西，只有对应的私钥能够解密；</em></strong><br><strong><em>私钥加密的东西，只有对应的公钥能够解密。</em></strong></p>\n<p><em>相对对称加密而言，不存在密钥无法安全传递的问题。</em></p>\n<blockquote>\n<p>缺陷：基本上基于数学难题，加密速度十分缓慢。</p>\n</blockquote>\n<h2 id=\"信息摘要\"><a href=\"#信息摘要\" class=\"headerlink\" title=\"信息摘要\"></a>信息摘要</h2><p><strong>数据的指纹，具有不可逆的性质。</strong></p>\n<p>一般输出的指纹数据长度都是固定的，便于传输。<br>通常可以用于验证数据是否被篡改。<br><strong><em>数据被篡改一位，都会导致计算出来的信息摘要不同。</em></strong></p>\n<h1 id=\"安全通信\"><a href=\"#安全通信\" class=\"headerlink\" title=\"安全通信\"></a>安全通信</h1><p>有了上述基础，你能否在公共网络中构建安全通信信道呢？<br>我们来尝试一下。</p>\n<h2 id=\"基本框架：非对称加密\"><a href=\"#基本框架：非对称加密\" class=\"headerlink\" title=\"基本框架：非对称加密\"></a>基本框架：非对称加密</h2><p>当然，我们的数据不能在公网上裸奔，因此首先就需要对明文进行加密。</p>\n<p>但此时我们难以解决密钥安全传输的问题，故需要引入<code>非对称加密</code>。<br><em>你可能会想到，如果我把密钥也加密呢？那如何解密加密后的密钥呢？是不是也需要一把新的密钥？这把密钥如何传输呢？</em><br><em>往复下去也不会有变化，并没有改变无法安全传输密钥的根本问题。</em></p>\n<h3 id=\"通信过程\"><a href=\"#通信过程\" class=\"headerlink\" title=\"通信过程\"></a>通信过程</h3><ol>\n<li><p>假设A、B需要通信，各自创建私钥与公钥，并且交换公钥；</p>\n<ul>\n<li>公钥是可以公开的，任何人都可以持有。</li>\n</ul>\n</li>\n<li><p>A向B发送消息之前，使用B的公钥加密，再发送给B；</p>\n<ul>\n<li>密文只有B能够解密，因为只有B持有对应的私钥。</li>\n</ul>\n</li>\n<li><p>B向A发送消息也是如此，使用A的公钥加密，再发送给A。</p>\n</li>\n</ol>\n<h3 id=\"第一个问题：计算效率\"><a href=\"#第一个问题：计算效率\" class=\"headerlink\" title=\"第一个问题：计算效率\"></a>第一个问题：计算效率</h3><p>在基础中提及到，非对称加密的计算缓慢，假设传输的数据较多，那么需要消耗大量的时间进行计算。</p>\n<h2 id=\"性能提高：引入对称加密\"><a href=\"#性能提高：引入对称加密\" class=\"headerlink\" title=\"性能提高：引入对称加密\"></a>性能提高：引入对称加密</h2><p>此时，对称加密计算效率高的特性能够完美弥补这个缺陷，故我们还是需要引入<code>对称加密</code>：<br><em>加密方案基本上都会首先基于流行的<code>加密算法</code>，只有这种经过全世界密码学家考验的加密算法才是可靠的。</em></p>\n<h3 id=\"通信过程改进\"><a href=\"#通信过程改进\" class=\"headerlink\" title=\"通信过程改进\"></a>通信过程改进</h3><ol>\n<li>A、B交换公钥；</li>\n<li>A生成本次通信的密钥，使用B的公钥加密，再将加密后的密钥发送给B；</li>\n<li>B生成本次通信的密钥，使用A的公钥加密，再将加密后的密钥发送给A；<ul>\n<li>此步并不一定需要，可以共用一把对称加密密钥。</li>\n</ul>\n</li>\n<li>各自用私钥解密密钥，往后的通信都使用这把密钥加密/解密。</li>\n</ol>\n<h3 id=\"第二个问题：中间人攻击\"><a href=\"#第二个问题：中间人攻击\" class=\"headerlink\" title=\"第二个问题：中间人攻击\"></a>第二个问题：中间人攻击</h3><ol>\n<li>A、B交换公钥；<ul>\n<li>假设A、B交换公钥的通信信道被C窃听了，C也生成了自己的公钥与私钥对，将A、B的公钥保存起来，并将信道上的A、B的公钥替换为C的公钥发给对方；</li>\n<li>A收到的是C的公钥，B收到的也是C的公钥。</li>\n</ul>\n</li>\n<li>A、B交换密钥；<ul>\n<li>A使用C的公钥加密密钥，发往B；<ul>\n<li>依旧被C劫持，C通过私钥解密，得到原始密钥，再将其通过B的公钥加密，替换后发往B。</li>\n</ul>\n</li>\n<li>B收到B的公钥加密的密钥，用B的私钥解密，得到密钥。</li>\n<li>B发往A同理。</li>\n</ul>\n</li>\n</ol>\n<p>这个过程中，A和B看似正常安全的通信，实际上自以为隐私的通信信道早已被C看得干干净净。</p>\n<ul>\n<li>对于A而言，<strong>C伪造身份为B与A通信</strong>；</li>\n<li>对于B而言，<strong>C伪造身份为A与B通信</strong>。</li>\n</ul>\n<h2 id=\"避免篡改：数据指纹\"><a href=\"#避免篡改：数据指纹\" class=\"headerlink\" title=\"避免篡改：数据指纹\"></a>避免篡改：数据指纹</h2><p>你可能会想到，既然信息摘要可以避免数据被篡改，那么能不能在发送公钥的时候顺带发送信息摘要来避免中间人伪造身份？</p>\n<p>实际上是不行的，因为<strong>中间人完全可以重新使用相同的信息摘要算法重新计算被替换的公钥，得到新的指纹，将信息摘要也替换。</strong><br><em>而接收者无法辨别信息摘要是否已被替换。</em></p>\n<h2 id=\"验明身份：数字证书\"><a href=\"#验明身份：数字证书\" class=\"headerlink\" title=\"验明身份：数字证书\"></a>验明身份：数字证书</h2><p>首先想一下，现实世界咱们是如何证明你是你呢？<br>多数情况下都是亮出身份证，对吧，我们有国家颁发的身份证。<br>因为是国家颁发的，有<code>权威性</code>和<code>公信力</code>，大家伙都相信和认可。</p>\n<p>在公网上证明你是你的话，也得拿出证据说话，随便说说我是不认的，谁知道你是不是中间人那个坏蛋呢？</p>\n<p>因此，证书自然就出现了。</p>\n<hr>\n<h3 id=\"证书\"><a href=\"#证书\" class=\"headerlink\" title=\"证书\"></a>证书</h3><p>证书类似”身份证”，用于证明某个人(公司)的身份，如：</p>\n<p>所有者：ABC, www.abc.com<br>公钥：xxxxxx<br>颁发CA机构：XXX<br>…</p>\n<hr>\n<p>证书当中记录了一些必要的信息，当然，就简简单单的在证书里写我是XXX，那肯定也不行，因为一点可信度都没有，中间人也可以给你发这么一串数据，说他也是XXX，你是信还是不信呢？</p>\n<p>因此引入证书也不可避免的产生了一个问题：<strong>证书也能被替换</strong>。</p>\n<h2 id=\"拒绝伪造：数字签名\"><a href=\"#拒绝伪造：数字签名\" class=\"headerlink\" title=\"拒绝伪造：数字签名\"></a>拒绝伪造：数字签名</h2><p>上面我们提到过，私钥加密的东西，只有公钥才能解密。<br>咋一看好像没什么鸡蛋饼用，我这私钥加密，所有人都能解密，这有个啥用啊？<br>实际上，这也是验证身份的核心关键：<code>不可抵赖性</code>。</p>\n<p>如果我们将这个特性应用到证书上呢？</p>\n<p>A的私钥只有A持有，那么A用私钥加密的A证书，只有用A的公钥才能正确解密。<br>B想要判断A的身份，只需要用A的公钥解密A证书，如果能够正确解密的话，那么这个证书就一定是A的，别人无法伪造的东西，A自然无法抵赖，也就验明了A的身份。</p>\n<p>我们就把经过公钥加密的证书叫做<code>数字证书</code>。</p>\n<p>而用私钥加密数据的过程就叫做<code>数字签名</code><br><strong>数字签名具备不可抵赖性</strong>。</p>\n<p>咋一看好像已经完结撒花了，实际上还是无法真正避免中间人攻击。<br>因为A的公钥需要在公网上传播，就存在被C偷天换日，替换为C的公钥的可能。</p>\n<p>B以为拿到的是A的公钥，实际上还是C的公钥，因此C用C的私钥伪造数字证书再发给B，B当然能够正确解密，这也给了B一个错觉：和我通信的A的身份没有问题。<br>所以A和B见面后：</p>\n<blockquote>\n<p>B：就是你，A！你为什么要骂我？我要和你绝交！<br>A：？？？？啥啊，我说啥了！<br>B：还想抵赖？我都能用你的公钥解开你的数字证书！</p>\n</blockquote>\n<h2 id=\"无奈之举：本地预装\"><a href=\"#无奈之举：本地预装\" class=\"headerlink\" title=\"无奈之举：本地预装\"></a>无奈之举：本地预装</h2><p>哪里都有C这个小人，咱们实在是没法子了，干脆直接在本地计算机中预先存放公钥吧，这样C就没有替换公钥的机会了。</p>\n<p>但是这样又会出现其他的问题：</p>\n<ul>\n<li>如何提前预装需要与其通信的对象的公钥？这就跟如何安全交换对称加密密钥是一个难度了，属于物理层面的难题。</li>\n</ul>\n<h2 id=\"最终解法：权威机构\"><a href=\"#最终解法：权威机构\" class=\"headerlink\" title=\"最终解法：权威机构\"></a>最终解法：权威机构</h2><p>人们怎么能被C这个小人打败呢？于是，这么一套验证体系出现了：<br><strong>在本地计算机中预装<code>权威机构CA</code>颁发的<code>数字证书</code>，通过CA的数字证书来验证经过了公网的数字证书是否可信，避免中间人攻击。</strong></p>\n<h3 id=\"CA证书授权中心\"><a href=\"#CA证书授权中心\" class=\"headerlink\" title=\"CA证书授权中心\"></a>CA证书授权中心</h3><p><strong><code>CA证书授权(CertificateAuthority)中心</code>是数字证书发行的唯一机构。</strong></p>\n<p>CA机构持有自己的公钥与私钥</p>\n<ul>\n<li>公钥是公开的，会包含在<strong>数字证书</strong>内，预置到操作系统/浏览器中。<ul>\n<li>即CA机构会生成一份自己的明文证书(里面的公钥就是公开的公钥)，然后自己用私钥<strong>签名</strong>(又或者是交给其他CA机构去签名)，自签发的数字证书就应该是根证书，不管是自签发还是其他CA机构签发的，最后都会得到<strong>数字证书</strong>。</li>\n</ul>\n</li>\n<li>私钥由CA机构自行保存。<ul>\n<li>这样子就保证了数字签名的可靠，因为别人是无法得到CA机构的私钥的，也就无法伪造该CA机构所签发的数字证书。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"签发数字证书\"><a href=\"#签发数字证书\" class=\"headerlink\" title=\"签发数字证书\"></a>签发数字证书</h2><p>B假定是服务器，他如果想和客户端建立安全信道，得到客户端的信任，就需要先向CA机构申请数字证书。</p>\n<ul>\n<li>B提交证书；</li>\n<li>CA机构对证书进行签名，得到数字证书，交回给B。</li>\n</ul>\n<p>签发后的数字证书包含了：<strong>证书内容</strong>、<strong>摘要算法</strong>、<strong>加密摘要信息</strong> 三部分。</p>\n<p>CA机构使用摘要算法对证书内容进行计算，得到摘要信息，再对摘要信息使用私钥进行加密。<br><em>为什么不直接加密证书内容？因为加密摘要信息可以减少计算量，同样也可以保证数字证书不被篡改。</em></p>\n<p>客户端收到B的数字证书时，就会先使用预装的CA数字证书(包含了CA的公钥)对加密摘要信息进行解密，同时用摘要算法对证书内容进行计算，得到摘要信息。<br>最后比较解密后的摘要信息与计算得出的摘要信息，相同则表示数据并未被篡改。</p>\n<p>看到这里想必有些读者就迷糊了：<br><strong><em>CA机构颁发的数字证书和服务器的数字证书到底是不是一回事呢？</em></strong><br>可以说是一回事，他们是逐层签发的关系。<br>我先信任我计算机中的数字证书，而服务器发过来的数字证书又是我所信任的数字证书对应的私钥(CA机构持有)签发的(通过我所信任的数字证书进行验证)，故我再信任服务器发过来的数字证书。</p>\n<p><strong><em>可为什么预装的是数字证书，而不是直接是公钥呢？</em></strong><br>有更多的信息需要存放，因此将其封装是更好的选择。</p>\n<p><strong><em>为什么是服务器申请数字证书，客户端不需要吗？</em></strong><br>首先数字证书通常需要向权威机构申请，并且是需要钱的；<br>其次也很难为全世界所有计算机都分配数字证书；<br>最后通常也无需验证客户端的身份，因为服务器所服务的对象绝大多数应用场景下并不特指某个客户端(不管你是正常用户还是坏蛋，我都一视同仁)，只需要客户端认证服务器的身份就足够了。</p>\n<h1 id=\"验证过程\"><a href=\"#验证过程\" class=\"headerlink\" title=\"验证过程\"></a>验证过程</h1><h2 id=\"签名：\"><a href=\"#签名：\" class=\"headerlink\" title=\"签名：\"></a>签名：</h2><ol>\n<li>A生成证书(填好个人信息)，发给CA机构。</li>\n<li>CA机构通过散列函数对明文证书进行计算，得到明文证书的信息摘要。</li>\n<li>CA机构通过持有的私钥加密信息摘要，其结果即<strong>数字签名</strong>。</li>\n<li>将明文证书以及数字签名打包，即得到<strong>数字证书</strong>，再发给申请者A。</li>\n</ol>\n<h2 id=\"验签：\"><a href=\"#验签：\" class=\"headerlink\" title=\"验签：\"></a>验签：</h2><ol>\n<li>B收到A发来的<strong>数字证书</strong>，包含了明文证书与CA机构签发的<strong>数字签名</strong>。</li>\n<li>B通过本地预置的CA机构<strong>数字证书</strong>中的公钥，对<strong>数字签名</strong>进行解密，得到信息摘要</li>\n<li>B通过散列函数对明文证书进行计算，得到明文证书的信息摘要。</li>\n<li>比较计算明文证书得到的信息摘要与解密<strong>数字签名</strong>得到的信息摘要，不同则表示明文证书被篡改了。</li>\n</ol>\n<h2 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h2><ul>\n<li><p>CA是有能力进行中间人攻击的，因为CA持有大家伙本地计算机预置公钥的私钥。</p>\n<ul>\n<li>CA叫做CA的意义就在这里，CA机构必须是权威公信的，不能做出这种行为，否则将会失去大家伙的信任。</li>\n</ul>\n</li>\n<li><p><strong>数字签名并非只能用于签名明文证书得到数字证书，可以用于签名任何数据防止篡改。</strong></p>\n</li>\n</ul>\n<h1 id=\"证书信任链\"><a href=\"#证书信任链\" class=\"headerlink\" title=\"证书信任链\"></a>证书信任链</h1><p>如公司ABC的数字证书，就是由A机构签发的，需要用A机构的数字证书来验签；<br>而A机构的数字证书又是B机构签发的，需要用B机构的数字证书来验签；<br>这样就形成了信任链。</p>\n<p><strong>信任过程就是逐层向上的验签，直到根证书(Root，即自签名的证书)为止；</strong><br><strong><em>对根证书只能无条件信任。</em></strong></p>\n<h1 id=\"WindowsPE文件数字签名简述\"><a href=\"#WindowsPE文件数字签名简述\" class=\"headerlink\" title=\"WindowsPE文件数字签名简述\"></a>WindowsPE文件数字签名简述</h1><p>Windows的PE文件如果存在数字签名，那么在其安全目录中，即包含了数字证书，再将PE文件散列值进行数字签名(由PE文件数字证书的所有者签名)，同样也包含在内。<br>首先通过本地预置数字证书证明PE文件中数字证书的可靠性，再通过PE文件中的数字证书的公钥解密(验签)数字签名，得到正确的散列值，再计算PE文件的散列值进行比较。</p>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><blockquote>\n<p><a href=\"https://blog.csdn.net/sky8336/article/details/113696551\">https://blog.csdn.net/sky8336/article/details/113696551</a><br><a href=\"https://zhuanlan.zhihu.com/p/43789231\">https://zhuanlan.zhihu.com/p/43789231</a></p>\n</blockquote>\n",
            "tags": [
                "密码学",
                "PKI",
                "证书",
                "签名"
            ]
        },
        {
            "id": "http://yuyuaqwq.github.io/posts/819.html",
            "url": "http://yuyuaqwq.github.io/posts/819.html",
            "title": "【动手写ToyLang】6-虚拟机设计",
            "date_published": "2022-12-07T16:24:27.000Z",
            "content_html": "<h1 id=\"所谓解释器\"><a class=\"markdownIt-Anchor\" href=\"#所谓解释器\">#</a> 所谓 &quot;解释器&quot;</h1>\n<p>我们除了能对遵循 ToyLang 语法的源文件编译之外，还要能够执行编译的结果。<br>\n若编译结果需要由其他程序负责执行，该程序便可称之为解释器。</p>\n<ul>\n<li>如先前提及的 AST 解释器。</li>\n</ul>\n<p>百度百科上对解释器的定义也较为模糊：</p>\n<blockquote>\n<p>解释器（英语：Interpreter），又译为直译器，是一种电脑程序，能够把高级编程语言一行一行直接转译运行。解释器不会一次把整个程序转译出来，只像一位 “中间人”，每次运行程序时都要先转成另一种语言再作运行，因此解释器的程序运行速度比较缓慢。它每转译一行程序叙述就立刻运行，然后再转译下一行，再运行，如此不停地进行下去。</p>\n</blockquote>\n<p>按照百度百科的定义，一行一行动态执行高级编程语言的程序，才能算解释器。<br>\n但是以现在常见的编程语言，如 Python、Java 等也在某些情况下会被定义为解释型语言来看，已经与 &quot;解释器&quot; 的定义相违背了。<br>\n因为 Python 和 Java 并不是逐行解释源代码的，实际上得以 &quot;解释&quot; 的是字节码，而执行字节码的程序又被称为 &quot;虚拟机&quot;。</p>\n<p>我的个人理解是，“解释器”、&quot;解释型语言&quot; 等名词的诞生，或许是为了与在当时已成体系的本地编译型语言进行区分，不过历史是否如此我也不好追溯了。</p>\n<p>因此，不必过度纠结 &quot;解释器&quot; 和 &quot;虚拟机&quot;，可以简单理解成解释器是一种笼统的统称，虚拟机是一种具体的实现，AST 解释器则是另一种实现，最终目标都是为了使得源代码得以以某种方式运行起来。</p>\n<h1 id=\"虚拟机简述\"><a class=\"markdownIt-Anchor\" href=\"#虚拟机简述\">#</a> 虚拟机简述</h1>\n<p>想必各位读者读者也经常见过<strong>虚拟机</strong>这个词。</p>\n<p>咱们的 ToyLang 不选择直接解释 AST，而是设计虚拟机以执行编译结果。</p>\n<blockquote>\n<p>虚拟机在不同场景下，所代指的东西存在差异，此处仅解释在编译原理中虚拟机的定义。</p>\n</blockquote>\n<p><em>实际上，虚拟机的开发应该是在更靠后一些的章节中讲述，在编写指令生成时顺带完成虚拟机。</em><br>\n<em>不过虚拟机的编写并不复杂，并且相对独立，因此就提前将其设计好，代码生成时以我们所设计的虚拟机为准去生成代码，有需要再对虚拟机进行修改与补充。</em></p>\n<p>我们并不选择生成本地代码 (与机器相关的机器指令)，而是生成一种被称为 <code>字节码</code> 的编译产物。</p>\n<p>如果读者曾经学习过 <code>Java</code> ，应该或多或少听过这种说法：</p>\n<blockquote>\n<p>Java 并不直接生成 <code>机器指令</code> ，而是生成 <code>字节码</code> ，交给 <code>JVM</code>  去执行。</p>\n</blockquote>\n<p>以我个人的理解看来， <code>机器指令</code> 和 <code>字节码</code> 并没有特别多的区别，只不过负责执行的对象不一样：</p>\n<ul>\n<li>一个是直接由硬件执行</li>\n<li>一个是模拟了硬件执行指令的流程的程序，自己设计了一套指令集。</li>\n</ul>\n<p>是的，我们所做的也与 <code>Java</code>  类似，我们也会设计 ToyLang 所生成的字节码，以及执行字节码的虚拟机。<br>\n当然这个虚拟机你要叫什么都可以，我在这里就把它叫成 <code>TVM(Toy Virtual Machine)</code> ，</p>\n<h1 id=\"tvm\"><a class=\"markdownIt-Anchor\" href=\"#tvm\">#</a> TVM</h1>\n<p>我们的 <code>TVM</code>  设计十分简单，只有十几条指令，但也足够我们使用了。</p>\n<p>为了实现更加简单， <code>TVM</code>  被设计为基于栈的虚拟机。</p>\n<h2 id=\"指令集设计\"><a class=\"markdownIt-Anchor\" href=\"#指令集设计\">#</a> 指令集设计</h2>\n<h3 id=\"指令结构\"><a class=\"markdownIt-Anchor\" href=\"#指令结构\">#</a> 指令结构</h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">字段</th>\n<th style=\"text-align:left\">长度</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">Reserved</td>\n<td style=\"text-align:left\">1bit</td>\n<td style=\"text-align:left\">保留位</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Opcode</td>\n<td style=\"text-align:left\">7bit</td>\n<td style=\"text-align:left\">操作码</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Immediate</td>\n<td style=\"text-align:left\">4byte</td>\n<td style=\"text-align:left\">立即数，可选</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"opcode\"><a class=\"markdownIt-Anchor\" href=\"#opcode\">#</a> Opcode</h3>\n<p>Opcode，即操作码，是指令的一部分，在虚拟机的指令解码器在会根据指令的 Opcode 来进行不同的操作。<br>\n以下是 TVM 指令集的 Opcode 表：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">助记符</th>\n<th style=\"text-align:left\">编码</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">stop</td>\n<td style=\"text-align:left\">0x00</td>\n<td style=\"text-align:left\">停止虚拟机</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">nop</td>\n<td style=\"text-align:left\">0x01</td>\n<td style=\"text-align:left\">空指令</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">pushk</td>\n<td style=\"text-align:left\">0x02</td>\n<td style=\"text-align:left\">将常量推入栈顶</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">pushv</td>\n<td style=\"text-align:left\">0x03</td>\n<td style=\"text-align:left\">将变量推入栈顶</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">pop</td>\n<td style=\"text-align:left\">0x04</td>\n<td style=\"text-align:left\">弹出栈顶值并抛弃</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">popv</td>\n<td style=\"text-align:left\">0x05</td>\n<td style=\"text-align:left\">弹出栈顶值并保存到变量中</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">add</td>\n<td style=\"text-align:left\">0x06</td>\n<td style=\"text-align:left\">依次弹出栈顶的值，stack2 + stack1，压入结果</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">sub</td>\n<td style=\"text-align:left\">0x07</td>\n<td style=\"text-align:left\">依次弹出栈顶的值，stack2 - stack1，压入结果</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">mul</td>\n<td style=\"text-align:left\">0x08</td>\n<td style=\"text-align:left\">依次弹出栈顶的值，stack2 * stack1，压入结果</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">div</td>\n<td style=\"text-align:left\">0x09</td>\n<td style=\"text-align:left\">依次弹出栈顶的值，stack2 /stack1，压入结果</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">call</td>\n<td style=\"text-align:left\">0x0a</td>\n<td style=\"text-align:left\">函数调用</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ret</td>\n<td style=\"text-align:left\">0x0b</td>\n<td style=\"text-align:left\">函数调用返回</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ne</td>\n<td style=\"text-align:left\">0x0c</td>\n<td style=\"text-align:left\">不等于比较</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">eq</td>\n<td style=\"text-align:left\">0x0d</td>\n<td style=\"text-align:left\">等于比较</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">lt</td>\n<td style=\"text-align:left\">0x0e</td>\n<td style=\"text-align:left\">小于比较</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">le</td>\n<td style=\"text-align:left\">0x0f</td>\n<td style=\"text-align:left\">小于等于比较</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">gt</td>\n<td style=\"text-align:left\">0x10</td>\n<td style=\"text-align:left\">大于比较</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ge</td>\n<td style=\"text-align:left\">0x11</td>\n<td style=\"text-align:left\">大于等于比较</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">jcf</td>\n<td style=\"text-align:left\">0x12</td>\n<td style=\"text-align:left\">条件为否则跳转</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">jmp</td>\n<td style=\"text-align:left\">0x13</td>\n<td style=\"text-align:left\">无条件跳转</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"toylang-源码-最终转换为-虚拟机指令的简单示例\"><a class=\"markdownIt-Anchor\" href=\"#toylang-源码-最终转换为-虚拟机指令的简单示例\">#</a> ToyLang 源码 最终转换为 虚拟机指令的简单示例</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if a == 1 &#123;</span><br><span class=\"line\">    print(&quot;a==1&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">else &#123;</span><br><span class=\"line\">    print(&quot;a!=1&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">pushv a</span><br><span class=\"line\">pushk 1</span><br><span class=\"line\">eq</span><br><span class=\"line\">jcf .else</span><br><span class=\"line\">...</span><br><span class=\"line\">jmp .end</span><br><span class=\"line\">...</span><br><span class=\"line\">.end:</span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>",
            "tags": [
                "编译原理",
                "动手写ToyLang"
            ]
        },
        {
            "id": "http://yuyuaqwq.github.io/posts/41fe.html",
            "url": "http://yuyuaqwq.github.io/posts/41fe.html",
            "title": "【保护模式】x64下定位随机页表基址的思路",
            "date_published": "2022-12-02T08:21:05.000Z",
            "content_html": "<h1 id=\"前言\"><a class=\"markdownIt-Anchor\" href=\"#前言\">#</a> 前言</h1>\n<p><em>昨天在看周哥讲 x64 内核的时候，得知了 windows10 的某个版本开始，页表基址不再固定了。</em><br>\n<em>今天晚上突然有了个思路，就动手把他敲出来了，这种思路是不是已经烂大街了我也不确定，就当发出来学习交流吧。</em></p>\n<h1 id=\"随机页表基址原理\"><a class=\"markdownIt-Anchor\" href=\"#随机页表基址原理\">#</a> 随机页表基址原理</h1>\n<p>这里用 x86 的 10-10-12 分页举例吧，比较好理解，理解了 x64 的也差不多的</p>\n<p>启用了保护模式和分页机制后，咱就不能直接访问物理地址了，都会被 MMU 当作虚拟地址进行转换。</p>\n<p>但是 cr3 存的又是物理地址，不能直接操作页表了，那咋办呢？</p>\n<p>聪明的前辈们，选择在页目录表中选择一项 (共 1024 项，每一项 4 字节)，使其存储的物理地址与页目录表的基址 (cr3) 相同，这样子就可以构造一个访问页表的虚拟地址了，大概就是<strong>让 cpu 在地址转换的过程中绕圈圈</strong>。</p>\n<ul>\n<li>画个图吧</li>\n<li>\n<img src=\"/posts/41fe/1.png\" class=\"\" title=\"这是一张图片\">\n</li>\n</ul>\n<h2 id=\"定位思路\"><a class=\"markdownIt-Anchor\" href=\"#定位思路\">#</a> 定位思路</h2>\n<ul>\n<li>x64 也必然是随机选择 PXT 的其中一项 PXE 来存储 PXT 的物理地址，实现的随机页表基址</li>\n<li>那么就可以通过<strong>构造所有可能指向 PXT 的虚拟地址 (共 512 项)</strong>，转换为物理地址，再与 cr3 比较，最终得到正确的 PXT 基址。</li>\n<li>只要知道了存储 PXT 的物理地址的 PXE 的 PXI，构造 PPT/PDT/PTT 基址都很简单了</li>\n</ul>\n<h1 id=\"实现\"><a class=\"markdownIt-Anchor\" href=\"#实现\">#</a> 实现</h1>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">PVOID <span class=\"title\">GetPXTBase</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tUINT64 cr3 = __readcr3();</span><br><span class=\"line\">\t<span class=\"built_in\">KdPrint</span>((<span class=\"string\">&quot;yuyu:cr3:%p\\n&quot;</span>, cr3));</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (UINT64 i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">512</span>; i++) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 通过PXI构造虚拟地址</span></span><br><span class=\"line\">\t\tPVOID pxtBase = (PVOID)(<span class=\"number\">0xffff000000000000</span> | (i &lt;&lt; <span class=\"number\">12</span>) | (i &lt;&lt; <span class=\"number\">21</span>) | (i &lt;&lt; <span class=\"number\">30</span>) | (i &lt;&lt; <span class=\"number\">39</span>));</span><br><span class=\"line\">\t\tPHYSICAL_ADDRESS physical = <span class=\"built_in\">MmGetPhysicalAddress</span>(pxtBase);</span><br><span class=\"line\">\t\t<span class=\"built_in\">KdPrint</span>((<span class=\"string\">&quot;yuyu:i:%d 物理:%p 虚拟:%p\\n&quot;</span>, i, physical.QuadPart, pxtBase));</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (cr3 == physical.QuadPart) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> pxtBase;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>\n<img src=\"/posts/41fe/2.png\" class=\"\" title=\"这是一张图片\">\n</li>\n</ul>\n<h1 id=\"结尾\"><a class=\"markdownIt-Anchor\" href=\"#结尾\">#</a> 结尾</h1>\n<p>理解有限，如有错误，还请指正</p>\n<h1 id=\"2022514补充\"><a class=\"markdownIt-Anchor\" href=\"#2022514补充\">#</a> 2022/5/14 补充</h1>\n<ul>\n<li>其实除开这个之外，我先想到的是另一个思路，即<strong>构造所有可能存储 PXT 的物理地址的 PXE 的虚拟地址</strong>。\n<ul>\n<li>依旧是 512 项，探测地址是否可访问，读取 8 字节；</li>\n<li>将其当作 PXE，取出物理页面基址，再与 cr3 进行比较。</li>\n</ul>\n</li>\n<li>但是这种方法有概率出现问题，即存放的数据可能正好与 cr3 相同，但所在页面并不是 PXT。\n<ul>\n<li>因此我就没有写出来，不过我想了一下，还是贴出来了，也算是一种思路嘛。</li>\n</ul>\n</li>\n</ul>\n",
            "tags": [
                "保护模式",
                "Windows内核"
            ]
        },
        {
            "id": "http://yuyuaqwq.github.io/posts/329c.html",
            "url": "http://yuyuaqwq.github.io/posts/329c.html",
            "title": "【动手写ToyLang】5.四则表达式解析与运算",
            "date_published": "2022-11-22T16:10:11.333Z",
            "content_html": "<h1 id=\"准备冻手\"><a class=\"markdownIt-Anchor\" href=\"#准备冻手\">#</a> 准备冻手</h1>\n<p>理论讲那么多，想必大家也犯困了，马上就到冻手环节了，本节我们会实现一个支持括号的四则表达式编译器 &amp; AST 解释器，用以验证我们所学习的知识。</p>\n<h1 id=\"ebnf文法\"><a class=\"markdownIt-Anchor\" href=\"#ebnf文法\">#</a> EBNF 文法</h1>\n<p>这里把本节代码所参考的 EBNF 文法贴上。</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">exp</span> = addexp</span><br><span class=\"line\">addexp = mulexp &#123;oper2 mulexp&#125;</span><br><span class=\"line\">oper2 = <span class=\"string\">&#x27;+&#x27;</span> | <span class=\"string\">&#x27;-&#x27;</span></span><br><span class=\"line\">mulexp = parenexp &#123;oper1 parenexp&#125;</span><br><span class=\"line\">oper1 = <span class=\"string\">&#x27;*&#x27;</span> | <span class=\"string\">&#x27;/&#x27;</span></span><br><span class=\"line\">parenexp = <span class=\"string\">&#x27;(&#x27;</span> addexp <span class=\"string\">&#x27;)&#x27;</span> | numexp</span><br><span class=\"line\">numexp = number</span><br></pre></td></tr></table></figure>\n<p>我们在上节文法的基础上稍作修改，支持了括号。</p>\n<h1 id=\"ast\"><a class=\"markdownIt-Anchor\" href=\"#ast\">#</a> AST</h1>\n<p>在编写语法分析器之前，我们需要先定义好每个 AST 节点 (符号) 的结构。</p>\n<details class=\"folding-tag\" blue><summary> \\ToyLang\\ast\\exp.h </summary>\n              <div class='content'>\n              <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> AST_EXP_H_</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> AST_EXP_H_</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;memory&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;lexer/token.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> toylang &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">enum class</span> <span class=\"title class_\">ExpType</span> &#123;</span><br><span class=\"line\">    kAdd,</span><br><span class=\"line\">    kMul,</span><br><span class=\"line\">    kNum,</span><br><span class=\"line\">    kParen,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 表达式抽象基类</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Exp</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> ExpType <span class=\"title\">GetType</span><span class=\"params\">()</span> <span class=\"type\">const</span> <span class=\"keyword\">noexcept</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 加法表达式节点</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">MulExp</span>;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">AddExp</span> : <span class=\"keyword\">public</span> Exp &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> ExpType <span class=\"title\">GetType</span><span class=\"params\">()</span> <span class=\"type\">const</span> <span class=\"keyword\">noexcept</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">AddExp</span>(std::unique_ptr&lt;MulExp&gt; t_leftMulExp, <span class=\"type\">const</span> std::vector&lt;TokenType&gt;&amp; t_operList, std::vector&lt;std::unique_ptr&lt;MulExp&gt;&gt;&amp;&amp; t_mulExpList);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    std::unique_ptr&lt;MulExp&gt; leftMulExp;</span><br><span class=\"line\">    std::vector&lt;TokenType&gt; operList;</span><br><span class=\"line\">    std::vector&lt;std::unique_ptr&lt;MulExp&gt;&gt; mulExpList;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 乘法表达式类</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">ParenExp</span>;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">MulExp</span> : <span class=\"keyword\">public</span> Exp &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> ExpType <span class=\"title\">GetType</span><span class=\"params\">()</span> <span class=\"type\">const</span> <span class=\"keyword\">noexcept</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">MulExp</span>(std::unique_ptr&lt;ParenExp&gt; t_leftParenExp, <span class=\"type\">const</span> std::vector&lt;TokenType&gt;&amp; t_operList, std::vector&lt;std::unique_ptr&lt;ParenExp&gt;&gt;&amp;&amp; t_parenExpList);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    std::unique_ptr&lt;ParenExp&gt; leftParenExp;</span><br><span class=\"line\">    std::vector&lt;TokenType&gt; operList;</span><br><span class=\"line\">    std::vector&lt;std::unique_ptr&lt;ParenExp&gt;&gt; parenExpList;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 括号表达式类</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">ParenExp</span> : <span class=\"keyword\">public</span> Exp &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> ExpType <span class=\"title\">GetType</span><span class=\"params\">()</span> <span class=\"type\">const</span> <span class=\"keyword\">noexcept</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">ParenExp</span>(std::unique_ptr&lt;Exp&gt; texp);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    std::unique_ptr&lt;Exp&gt; exp;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 数值表达式类</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">NumExp</span> : <span class=\"keyword\">public</span> Exp &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> ExpType <span class=\"title\">GetType</span><span class=\"params\">()</span> <span class=\"type\">const</span> <span class=\"keyword\">noexcept</span></span>;</span><br><span class=\"line\">    <span class=\"built_in\">NumExp</span>(<span class=\"type\">int</span> t_num);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> num;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125; <span class=\"comment\">// namespace ast</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span> <span class=\"comment\">// AST_EXP_H_</span></span></span><br></pre></td></tr></table></figure>\n              </div>\n            </details>\n<p>我们创建了四个类用于描述 AST 节点：<br>\n <code>Exp</code>  是抽象基类，只是为了让我们的实现更加优雅，实际描述节点的是下列四个类；<br>\n <code>AddExp</code> 、 <code>MulExp</code> 、 <code>ParenExp</code> 、 <code>NumExp</code>  皆继承自 <code>Exp</code> ，各自表示三个终结符节点和一个非终结符节点。</p>\n<p>其中，派生类的成员变量存储了节点的连接关系与值。<br>\n暂时看不懂也没关系，你可以先拷贝代码，理解的关键在于语法分析器。</p>\n<p>接下来是 AST 节点的实现，就是类的构造与析构，并没有什么特别的代码，大致浏览下即可。</p>\n<details class=\"folding-tag\" blue><summary> \\ToyLang\\ast\\exp.cpp </summary>\n              <div class='content'>\n              <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;exp.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> toylang &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> std::unique_ptr;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">ExpType <span class=\"title\">AddExp::GetType</span><span class=\"params\">()</span> <span class=\"type\">const</span> <span class=\"keyword\">noexcept</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ExpType::kAdd;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">AddExp::<span class=\"built_in\">AddExp</span>(unique_ptr&lt;MulExp&gt; t_leftMulExp, <span class=\"type\">const</span> std::vector&lt;TokenType&gt;&amp; t_operList, std::vector&lt;unique_ptr&lt;MulExp&gt;&gt;&amp;&amp; t_mulExpList) :</span><br><span class=\"line\">    <span class=\"built_in\">leftMulExp</span>(std::<span class=\"built_in\">move</span>(t_leftMulExp)), <span class=\"built_in\">operList</span>(t_operList), <span class=\"built_in\">mulExpList</span>(std::<span class=\"built_in\">move</span>(t_mulExpList)) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">ExpType <span class=\"title\">MulExp::GetType</span><span class=\"params\">()</span> <span class=\"type\">const</span> <span class=\"keyword\">noexcept</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ExpType::kMul;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">MulExp::<span class=\"built_in\">MulExp</span>(unique_ptr&lt;ParenExp&gt; t_leftParenExp, <span class=\"type\">const</span> std::vector&lt;TokenType&gt;&amp; t_operList, std::vector&lt;unique_ptr&lt;ParenExp&gt;&gt;&amp;&amp; t_parenExoList) :</span><br><span class=\"line\">    <span class=\"built_in\">leftParenExp</span>(std::<span class=\"built_in\">move</span>(t_leftParenExp)), <span class=\"built_in\">operList</span>(t_operList), <span class=\"built_in\">parenExpList</span>(std::<span class=\"built_in\">move</span>(t_parenExoList)) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">ExpType <span class=\"title\">ParenExp::GetType</span><span class=\"params\">()</span> <span class=\"type\">const</span> <span class=\"keyword\">noexcept</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ExpType::kParen;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">ParenExp::<span class=\"built_in\">ParenExp</span>(unique_ptr&lt;Exp&gt; t_exp) : <span class=\"built_in\">exp</span>(std::<span class=\"built_in\">move</span>(t_exp)) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">ExpType <span class=\"title\">NumExp::GetType</span><span class=\"params\">()</span> <span class=\"type\">const</span> <span class=\"keyword\">noexcept</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ExpType::kNum;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">NumExp::<span class=\"built_in\">NumExp</span>(<span class=\"type\">int</span> t_num) : <span class=\"built_in\">num</span>(t_num) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125; <span class=\"comment\">// namespace ast</span></span><br></pre></td></tr></table></figure>\n              </div>\n            </details>\n<h1 id=\"parser\"><a class=\"markdownIt-Anchor\" href=\"#parser\">#</a> Parser</h1>\n<p>我们在第 2 节已经实现了一个词法分析器，接下来我们继续完成语法分析器。</p>\n<p>以下是头文件，接下来我们把重心放到实现上。</p>\n<details class=\"folding-tag\" blue><summary> \\ToyLang\\parser\\parser.h </summary>\n              <div class='content'>\n              <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> PARSER_PARSER_H_</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PARSER_PARSER_H_</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;memory&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;lexer/lexer.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;ast/exp.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> toylang &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 语法分析时发生的异常</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ParserException</span> : <span class=\"keyword\">public</span> std::exception &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">ParserException</span>(<span class=\"type\">const</span> <span class=\"type\">char</span>* t_msg);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Parser</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Parser</span>(Lexer* t_lexer);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">std::unique_ptr&lt;Exp&gt; <span class=\"title\">ParseExp</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\">std::unique_ptr&lt;AddExp&gt; <span class=\"title\">ParseAddExp</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\">std::unique_ptr&lt;MulExp&gt; <span class=\"title\">ParseMulExp</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\">std::unique_ptr&lt;ParenExp&gt; <span class=\"title\">ParseParenExp</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\">std::unique_ptr&lt;NumExp&gt; <span class=\"title\">ParseNumExp</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    Lexer* m_lexer;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125; <span class=\"comment\">// namespace parser</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span> <span class=\"comment\">// PARSER_PARSER_H_</span></span></span><br></pre></td></tr></table></figure>\n              </div>\n            </details>\n<h2 id=\"解析exp\"><a class=\"markdownIt-Anchor\" href=\"#解析exp\">#</a> 解析 <code>exp</code></h2>\n<p>首先我们知道，我们所编写的是四则表达式运算器，那么接收到的用户输入就是一个表达式，即非终结符 <code>exp</code> ，因此，解析就是从 <code>exp</code>  开始层层下降的。</p>\n<details class=\"folding-tag\" blue><summary> \\ToyLang\\parser\\parser.cpp </summary>\n              <div class='content'>\n              <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">unique_ptr&lt;Exp&gt; <span class=\"title\">Parser::ParseExp</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> exp = <span class=\"built_in\">ParseAddExp</span>();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!m_lexer-&gt;<span class=\"built_in\">LookAHead</span>().<span class=\"built_in\">Is</span>(TokenType::kEof)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"built_in\">ParserException</span>(<span class=\"string\">&quot;Incomplete parsing&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> exp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n              </div>\n            </details>\n<p>代码非常简单，根据 EBNF 描述的文法来看， <code>exp</code>  由一个 <code>addexp</code>  组成；<br>\n因此我们调用 <code>ParseAddExp</code>  去解析 <code>addexp</code> ，返回一个 <code>AddExp</code>  类对象，返回就表示解析完成了。</p>\n<p>接下来我们前瞻一个 token，看看是不是已经将所有 token 都吃完了，还有可用 token 就表示输入串有错误，抛出一个异常即可。</p>\n<p>最后直接返回 <code>AddExp</code>  对象，到这里你可能有些疑惑，我们解析的不是 <code>exp</code>  吗？为什么不是返回一个 <code>Exp</code>  对象，而是返回一个 <code>AddExp</code>  对象？<br>\n因为实际上 EBNF 文法描述上， <code>exp</code>  就只由 <code>addexp</code>  组成，它们基本上可以看作是等价的，为了省事，我就直接让 <code>AddExp</code>  对象成为 AST 的根节点。</p>\n<p>而我们实际上没有实现描述非终结符 <code>exp</code>  的类， <code>Exp</code>  并不是描述 <code>exp</code>  的类，只是看起来很像。<br>\n <code>Exp</code>  是我们另外定义的基类，基类指针自然可以指向派生类对象。</p>\n<h2 id=\"解析addexp\"><a class=\"markdownIt-Anchor\" href=\"#解析addexp\">#</a> 解析 <code>addexp</code></h2>\n<p>接下来我们需要解析 <code>addexp</code> ，对应的类自然就是 <code>AddExp</code> ，返回它的实例化对象。</p>\n<details class=\"folding-tag\" blue><summary> \\ToyLang\\parser\\parser.cpp </summary>\n              <div class='content'>\n              <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">unique_ptr&lt;AddExp&gt; <span class=\"title\">Parser::ParseAddExp</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> leftMulExp = <span class=\"built_in\">ParseMulExp</span>();    <span class=\"comment\">// 解析左边的mulexp，保存解析的结果</span></span><br><span class=\"line\"></span><br><span class=\"line\">    std::vector&lt;TokenType&gt; operList;</span><br><span class=\"line\">    std::vector&lt;unique_ptr&lt;MulExp&gt;&gt; mulExpList;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 循环解析右边的mulexp</span></span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 前瞻一下，如果后面已经不是加法符号或者减法符号了，就可以返回了。</span></span><br><span class=\"line\">        <span class=\"keyword\">auto</span> token = m_lexer-&gt;<span class=\"built_in\">LookAHead</span>();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!token.<span class=\"built_in\">Is</span>(TokenType::kOpAdd) &amp;&amp; !token.<span class=\"built_in\">Is</span>(TokenType::kOpSub)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 吃掉刚刚前瞻的运算符号</span></span><br><span class=\"line\">        m_lexer-&gt;<span class=\"built_in\">NextToken</span>();</span><br><span class=\"line\">        operList.<span class=\"built_in\">push_back</span>(token.type);   <span class=\"comment\">// 保存符号，因为连接两个mulexp的符号可能是加法，也可能是减法，保存起来供解释时使用</span></span><br><span class=\"line\">        mulExpList.<span class=\"built_in\">push_back</span>(<span class=\"built_in\">ParseMulExp</span>());    <span class=\"comment\">// 解析并保存右侧mulexp</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 构造AddExp对象并返回</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> std::<span class=\"built_in\">make_unique</span>&lt;AddExp&gt;(std::<span class=\"built_in\">move</span>(leftMulExp), operList, std::<span class=\"built_in\">move</span>(mulExpList));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n              </div>\n            </details>\n<p>依旧是按照 EBNF 文法来解析。</p>\n<p>我们先解析最左边的一个 <code>mulexp</code>  非终结符，接下来就可能是多对 <code>oper2</code>  和 <code>mulexp</code>  了，因此用一个循环来解析，分别保存到 <code>vector</code>  容器中。</p>\n<h2 id=\"解析mulexp\"><a class=\"markdownIt-Anchor\" href=\"#解析mulexp\">#</a> 解析 <code>mulexp</code></h2>\n<p>接下来解析 <code>mulexp</code> ，对应的类是 <code>MulExp</code> ，返回它的实例化对象。</p>\n<details class=\"folding-tag\" blue><summary> \\ToyLang\\parser\\parser.cpp </summary>\n              <div class='content'>\n              <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">auto</span> leftParenExp = <span class=\"built_in\">ParseParenExp</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">std::vector&lt;TokenType&gt; operList;</span><br><span class=\"line\">std::vector&lt;unique_ptr&lt;ParenExp&gt;&gt; parenExpList;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> token = m_lexer-&gt;<span class=\"built_in\">LookAHead</span>();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!token.<span class=\"built_in\">Is</span>(TokenType::kOpMul) &amp;&amp; !token.<span class=\"built_in\">Is</span>(TokenType::kOpDiv)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    m_lexer-&gt;<span class=\"built_in\">NextToken</span>();</span><br><span class=\"line\">    operList.<span class=\"built_in\">push_back</span>(token.type);</span><br><span class=\"line\">    parenExpList.<span class=\"built_in\">push_back</span>(<span class=\"built_in\">ParseParenExp</span>());</span><br><span class=\"line\"></span><br><span class=\"line\">&#125; <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">return</span> std::<span class=\"built_in\">make_unique</span>&lt;MulExp&gt;(std::<span class=\"built_in\">move</span>(leftParenExp), operList, std::<span class=\"built_in\">move</span>(parenExpList));</span><br></pre></td></tr></table></figure>\n              </div>\n            </details>\n<p>由于 <code>addexp</code>  和 <code>mulexp</code>  的结构基本相同，他们的解析过程也一般无二。</p>\n<h2 id=\"解析parenexp\"><a class=\"markdownIt-Anchor\" href=\"#解析parenexp\">#</a> 解析 <code>parenexp</code></h2>\n<details class=\"folding-tag\" blue><summary> \\ToyLang\\parser\\parser.cpp </summary>\n              <div class='content'>\n              <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">unique_ptr&lt;ParenExp&gt; <span class=\"title\">Parser::ParseParenExp</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> token = m_lexer-&gt;<span class=\"built_in\">LookAHead</span>();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!token.<span class=\"built_in\">Is</span>(TokenType::kSepLParen)) &#123;        <span class=\"comment\">// (</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> std::<span class=\"built_in\">make_unique</span>&lt;ParenExp&gt;(<span class=\"built_in\">ParseNumExp</span>());   <span class=\"comment\">// 不是以`(`开头的子表达式，直接当成numexp解析。</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    m_lexer-&gt;<span class=\"built_in\">NextToken</span>();</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> exp = <span class=\"built_in\">ParseAddExp</span>();   <span class=\"comment\">// 解析一个addexp</span></span><br><span class=\"line\">    m_lexer-&gt;<span class=\"built_in\">MatchToken</span>(TokenType::kSepRParen);        <span class=\"comment\">// )</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> std::<span class=\"built_in\">make_unique</span>&lt;ParenExp&gt;(std::<span class=\"built_in\">move</span>(exp));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n              </div>\n            </details>\n<p>解析 <code>parenexp</code>  的代码也比较简单，根据 EBNF 所描述的文法，要么就是以 <code>(</code> 开始的子表达式，要么就是数值表达式。</p>\n<h2 id=\"解析numexp\"><a class=\"markdownIt-Anchor\" href=\"#解析numexp\">#</a> 解析 <code>numexp</code></h2>\n<details class=\"folding-tag\" blue><summary> \\ToyLang\\parser\\parser.cpp </summary>\n              <div class='content'>\n              <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">unique_ptr&lt;NumExp&gt; <span class=\"title\">Parser::ParseNumExp</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> token = m_lexer-&gt;<span class=\"built_in\">MatchToken</span>(TokenType::kNumber);   <span class=\"comment\">// 直接匹配一个NumberToken</span></span><br><span class=\"line\">    <span class=\"type\">int</span> num = <span class=\"built_in\">atoi</span>(token.str.<span class=\"built_in\">c_str</span>());    <span class=\"comment\">// 字符串转整数</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> std::<span class=\"built_in\">make_unique</span>&lt;NumExp&gt;(num);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n              </div>\n            </details>\n<p><code>numexp</code>  的解析是最简单的，直接从词法分析器那边匹配一个 <code>Number</code>  类型的 token，就能拿到其字符串。</p>\n<p>至此，语法分析告一段落。</p>\n<h1 id=\"interpreter\"><a class=\"markdownIt-Anchor\" href=\"#interpreter\">#</a> Interpreter</h1>\n<p>经过语法分析阶段，如果一切顺利，我们就将输入串转换成了 AST，接下来我们编写一个解释器，解释这颗树，得到结果。</p>\n<details class=\"folding-tag\" blue><summary> \\ToyLang\\interpreter\\interpreter.h </summary>\n              <div class='content'>\n              <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> INTERPRETER_INTERPRETER_H_</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> INTERPRETER_INTERPRETER_H_</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;ast/exp.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> interpreter &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Interpreter</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">InterpretExp</span><span class=\"params\">(Exp* exp)</span> <span class=\"type\">const</span> <span class=\"keyword\">noexcept</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">InterpretAddExp</span><span class=\"params\">(AddExp* exp)</span> <span class=\"type\">const</span> <span class=\"keyword\">noexcept</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">InterpretMulExp</span><span class=\"params\">(MulExp* exp)</span> <span class=\"type\">const</span> <span class=\"keyword\">noexcept</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">InterpretParenExp</span><span class=\"params\">(ParenExp* exp)</span> <span class=\"type\">const</span> <span class=\"keyword\">noexcept</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">InterpretNumberExp</span><span class=\"params\">(NumExp* exp)</span> <span class=\"type\">const</span> <span class=\"keyword\">noexcept</span></span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125; <span class=\"comment\">// namespace interpreter</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span> <span class=\"comment\">// INTERPRETER_INTERPRETER_H</span></span></span><br></pre></td></tr></table></figure>\n              </div>\n            </details>\n<p>头文件也很简单，就是定义了一个解释器类，其成员函数负责解释不同类型的 AST 节点。</p>\n<details class=\"folding-tag\" blue><summary> \\ToyLang\\interpreter\\interpreter.cpp </summary>\n              <div class='content'>\n              <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;interpreter.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> interpreter &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Interpreter::InterpretExp</span><span class=\"params\">(Exp* exp)</span> <span class=\"type\">const</span> <span class=\"keyword\">noexcept</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">InterpretAddExp</span>(<span class=\"built_in\">static_cast</span>&lt;AddExp*&gt;(exp));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Interpreter::InterpretAddExp</span><span class=\"params\">(AddExp* exp)</span> <span class=\"type\">const</span> <span class=\"keyword\">noexcept</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> res = <span class=\"built_in\">InterpretMulExp</span>(exp-&gt;leftMulExp.<span class=\"built_in\">get</span>());</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; exp-&gt;operList.<span class=\"built_in\">size</span>(); i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (exp-&gt;operList[i] == TokenType::kOpAdd) &#123;</span><br><span class=\"line\">            res += <span class=\"built_in\">InterpretMulExp</span>(exp-&gt;mulExpList[i].<span class=\"built_in\">get</span>());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            res -= <span class=\"built_in\">InterpretMulExp</span>(exp-&gt;mulExpList[i].<span class=\"built_in\">get</span>());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Interpreter::InterpretMulExp</span><span class=\"params\">(MulExp* exp)</span> <span class=\"type\">const</span> <span class=\"keyword\">noexcept</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> res = <span class=\"built_in\">InterpretParenExp</span>(exp-&gt;leftParenExp.<span class=\"built_in\">get</span>());</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; exp-&gt;operList.<span class=\"built_in\">size</span>(); i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (exp-&gt;operList[i] == TokenType::kOpMul) &#123;</span><br><span class=\"line\">            res *= <span class=\"built_in\">InterpretParenExp</span>(exp-&gt;parenExpList[i].<span class=\"built_in\">get</span>());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            res /= <span class=\"built_in\">InterpretParenExp</span>(exp-&gt;parenExpList[i].<span class=\"built_in\">get</span>());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Interpreter::InterpretParenExp</span><span class=\"params\">(ParenExp* exp)</span> <span class=\"type\">const</span> <span class=\"keyword\">noexcept</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (exp-&gt;exp-&gt;<span class=\"built_in\">GetType</span>() == ExpType::kNum) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">InterpretNumberExp</span>(<span class=\"built_in\">static_cast</span>&lt;NumExp*&gt;(exp-&gt;exp.<span class=\"built_in\">get</span>()));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">InterpretAddExp</span>(<span class=\"built_in\">static_cast</span>&lt;AddExp*&gt;(exp-&gt;exp.<span class=\"built_in\">get</span>()));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Interpreter::InterpretNumberExp</span><span class=\"params\">(NumExp* exp)</span> <span class=\"type\">const</span> <span class=\"keyword\">noexcept</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> exp-&gt;num;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125; <span class=\"comment\">// namespace interpreter</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n              </div>\n            </details>\n<p>实现代码能看到些许上述语法分析的代码的影子，实际上就是树的深度优先遍历并向上返回运算结果。<br>\n只要理解了语法分析，解释的过程也很好理解。<br>\n<em>如果你需要考虑四则运算的性能，甚至可以在语法分析阶段就返回数值结果，而不是构造 AST 树。</em></p>\n<h1 id=\"完整测试\"><a class=\"markdownIt-Anchor\" href=\"#完整测试\">#</a> 完整测试</h1>\n<details class=\"folding-tag\" blue><summary> \\ToyLang\\entry.cpp </summary>\n              <div class='content'>\n              <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;lexer/lexer.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;parser/parser.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;interpreter/interpreter.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> lexer;</span><br><span class=\"line\">    <span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> parser;</span><br><span class=\"line\">    <span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> interpreter;</span><br><span class=\"line\"></span><br><span class=\"line\">    Lexer lexer&#123; <span class=\"string\">&quot;1 + 33 - 0 * (33 / 999) + 123&quot;</span> &#125;;</span><br><span class=\"line\">    <span class=\"function\">Parser <span class=\"title\">parser</span><span class=\"params\">(&amp;lexer)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> exp = parser.<span class=\"built_in\">ParseExp</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    Interpreter inter;</span><br><span class=\"line\">    <span class=\"type\">int</span> res = inter.<span class=\"built_in\">InterpretExp</span>(exp.<span class=\"built_in\">get</span>());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>, res);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n              </div>\n            </details>\n<h1 id=\"完整代码\"><a class=\"markdownIt-Anchor\" href=\"#完整代码\">#</a> 完整代码</h1>\n<p>我将本节完整代码放到了 github 上，你可以将其克隆下来亲自调试运行，鉴于 vs 强大的调试能力，你可以一步一步观察 AST 树的构造过程，加深理解。</p>\n<ul>\n<li><a href=\"https://github.com/yuyuaqwq/ToyLang/tree/5.arithmetic\">https://github.com/yuyuaqwq/ToyLang/tree/5.arithmetic</a></li>\n</ul>\n",
            "tags": [
                "编译原理",
                "动手写ToyLang"
            ]
        },
        {
            "id": "http://yuyuaqwq.github.io/posts/f573.html",
            "url": "http://yuyuaqwq.github.io/posts/f573.html",
            "title": "【动手写ToyLang】4.递归下降",
            "date_published": "2022-10-30T08:34:27.524Z",
            "content_html": "<h1 id=\"递归下降\"><a class=\"markdownIt-Anchor\" href=\"#递归下降\">#</a> 递归下降</h1>\n<p>先前用于描述的加减运算表达式的文法，实际上并不能直接通过递归下降分析法来解析。</p>\n<p>说了这么多，递归下降到底是个什么玩意呢？<br>\n接下来我们通过以下能够应用递归下降进行解析的文法来解析输入串，了解其解析过程，读者大概就明白了。</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">block</span> = <span class=\"string\">&#x27;&#123;&#x27;</span> &#123;stat&#125; <span class=\"string\">&#x27;&#125;&#x27;</span></span><br><span class=\"line\">stat = assignExp <span class=\"string\">&#x27;;&#x27;</span></span><br><span class=\"line\">assignExp = ident <span class=\"string\">&#x27;=&#x27;</span> value</span><br><span class=\"line\">value = number | string</span><br></pre></td></tr></table></figure>\n<p><code>&#123;stat&#125;</code>  表示重复 <code>stat</code> ，此处表示可以有 0~n 个 <code>stat</code> 。<br>\n其中， <code>ident</code>  是标识符， <code>number</code> 、 <code>string</code>  是字面量，我们都会放到词法分析中去解析，故不在此列出其文法。</p>\n<p>首先，假设 <code>block</code>  输入串为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    a = 1;</span><br><span class=\"line\">    b = &quot;qwq&quot;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以下是解析的伪代码：</p>\n<h2 id=\"解析block\"><a class=\"markdownIt-Anchor\" href=\"#解析block\">#</a> 解析 <code>block</code></h2>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func ParseBlock(inStr) &#123;</span><br><span class=\"line\">    inStr.match(&#x27;&#123;&#x27;);</span><br><span class=\"line\">    while in.is(&#x27;&#125;&#x27;) == false &#123;</span><br><span class=\"line\">        ParseStat(in);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    inStr.match(&#x27;&#125;&#x27;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>首先从输入串中匹配 <code>&#123;</code> 字符；<br>\n由于语句是可选的，因此需要检查紧接着的符号是否为 <code>&#125;</code>  字符，不是的话就可以匹配 <code>stat</code>  了；<br>\n <code>stat</code>  是一个非终结符，需要继续展开，此处交给 <code>ParseStat</code>  进一步解析；<br>\n <code>ParseStat</code>  返回后，表示一条语句的解析完成了，但语句可能存在多条，因此循环进行；<br>\n最后匹配一个 <code>&#125;</code>  字符；<br>\n <code>block</code>  解析完成。</p>\n<p>抽象语法树如下：</p>\n<ul>\n<li>\n<img src=\"/posts/f573/1.png\" class=\"\" title=\"这是一张图片\">\n</li>\n</ul>\n<p><em>为什么这里没有添加 <code>&#123;</code>  和  <code>&#125;</code>  节点呢？</em><br>\n<em>因为树构建完成后，我们自然可以知道这个节点是 block，在词法阶段的两个符号于语法树而言并无关紧要。</em></p>\n<h2 id=\"解析stat\"><a class=\"markdownIt-Anchor\" href=\"#解析stat\">#</a> 解析 <code>stat</code></h2>\n<p>关于 <code>stat</code>  的解析，在 <code>ParseStat</code>  函数中完成：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func ParseStat(inStr) &#123;</span><br><span class=\"line\">    ParseAssignExp(inStr);</span><br><span class=\"line\">    inStr.match(&#x27;;&#x27;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>\n<img src=\"/posts/f573/2.png\" class=\"\" title=\"这是一张图片\">\n</li>\n</ul>\n<h2 id=\"解析assignexp\"><a class=\"markdownIt-Anchor\" href=\"#解析assignexp\">#</a> 解析 <code>assignExp</code></h2>\n<p>接下来是 <code>assignExp</code> ：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func ParseAssignExp(inStr) &#123;</span><br><span class=\"line\">    inStr.match(kIdent);</span><br><span class=\"line\">    inStr.match(&#x27;=&#x27;);</span><br><span class=\"line\">    ParseValue(inStr);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>\n<img src=\"/posts/f573/3.png\" class=\"\" title=\"这是一张图片\">\n</li>\n</ul>\n<p><em>这里同样没有将符号 <code>=</code>  作为节点添加。</em></p>\n<h2 id=\"解析value\"><a class=\"markdownIt-Anchor\" href=\"#解析value\">#</a> 解析 <code>Value</code></h2>\n<p>最后完成关于 <code>Value</code>  的解析：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func ParseValue(inStr) &#123;</span><br><span class=\"line\">    inStr in.is(kNumber) &#123;</span><br><span class=\"line\">        in.match(kNumber);</span><br><span class=\"line\">        ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    inStr.match(kString);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>\n<img src=\"/posts/f573/4.png\" class=\"\" title=\"这是一张图片\">\n</li>\n</ul>\n<h2 id=\"关键描述文法\"><a class=\"markdownIt-Anchor\" href=\"#关键描述文法\">#</a> 关键：描述文法</h2>\n<p><strong>这种自顶逐层向下解析，以构造语法树的分析法，就叫做递归下降。</strong><br>\n<em>虽然笔者并没有在伪代码中添加构造树的节点相关的代码，但不妨碍读者理解递归下降。</em></p>\n<p>你会发现，只要我们描述好了文法，用递归下降来解析输入串是一件非常简单的事情。</p>\n<h2 id=\"无限递进\"><a class=\"markdownIt-Anchor\" href=\"#无限递进\">#</a> 无限递进</h2>\n<p>还记得我在上一篇文章中所描述的文法吗？</p>\n<p>如果直接编写解析代码，就会形成无限递进：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func ParseExp(inStr) &#123;</span><br><span class=\"line\">    ParseExp(inStr);</span><br><span class=\"line\">    if inStr.is(&#x27;+&#x27;) &#123;</span><br><span class=\"line\">        inStr.match(&#x27;+&#x27;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else &#123;</span><br><span class=\"line\">        inStr.match(&#x27;-&#x27;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ParseNumber(inStr);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"左递归\"><a class=\"markdownIt-Anchor\" href=\"#左递归\">#</a> 左递归</h1>\n<p><strong>如果非终结符 <code>r</code>  被直接或间接推导后，其结果最左边又出现非终结符 <code>r</code>  的情况，便称之为左递归。</strong></p>\n<p>理想解析情况：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">exp = exp + number</span><br><span class=\"line\">-&gt; exp = number + number</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>代码解析情况：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">exp = exp + number</span><br><span class=\"line\">-&gt; exp = exp + number + number</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<h2 id=\"消除左递归\"><a class=\"markdownIt-Anchor\" href=\"#消除左递归\">#</a> 消除左递归</h2>\n<p>为此，我们需要改写文法，以避免出现左递归。</p>\n<h2 id=\"四则表达式文法\"><a class=\"markdownIt-Anchor\" href=\"#四则表达式文法\">#</a> 四则表达式文法</h2>\n<p>首先，我们用 EBNF 描述更加完整的四则表达式文法：</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">exp</span> = addexp</span><br><span class=\"line\">addexp = addexp oper2 mulexp | mulexp</span><br><span class=\"line\">oper2 = <span class=\"string\">&#x27;+&#x27;</span> | <span class=\"string\">&#x27;-&#x27;</span></span><br><span class=\"line\">mulexp = mulexp oper1 number | number</span><br><span class=\"line\">oper1 = <span class=\"string\">&#x27;*&#x27;</span> | <span class=\"string\">&#x27;/&#x27;</span></span><br></pre></td></tr></table></figure>\n<p><em>关于 <code>number</code>  的产生式就不再列出，实际上我们会在词法分析阶段将 <code>number</code>  解析为 <code>token</code> 。</em></p>\n<p>我们现在很容易就能看出，在该文法中，左式为 <code>addexp</code>  和 <code>mulexp</code>  的产生式都存在左递归的问题。</p>\n<p>如何消除呢？<br>\n首先观察产生式 <code>addexp = addexp oper2 mulexp | mulexp</code> <br>\n 我们会发现这么一条规律：</p>\n<ul>\n<li><code>addexp</code>  的推导产生的句型，必然是 <code>mulexp &#123;oper2 mulexp&#125;</code></li>\n</ul>\n<p>于是我们可以重写文法为：</p>\n<figure class=\"highlight bnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">addexp ::= mulexp addexp<span class=\"string\">&#x27;</span></span><br><span class=\"line\"><span class=\"string\">addexp&#x27;</span> ::= oper2 addexp<span class=\"string\">&#x27; | ε</span></span><br></pre></td></tr></table></figure>\n<p>教学时消除左递归时经常用于举例的 BNF 文法；<br>\n其中 <code>ε</code>  表示空。<br>\n<em>事实上关于 BNF 的格式规范，网上许多文章的写法似乎都不尽相同，在这里笔者也不做深究了。</em></p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">addexp</span> = mulexp &#123;oper2 mulexp&#125;</span><br></pre></td></tr></table></figure>\n<p>使用 EBNF 描述的文法，通过 <code>&#123;&#125;</code>  做了简化。</p>\n<p><em>事实上，我们如果直接按照第一种文法编写解析代码，最终构成的语法树会存在结合律的问题。</em><br>\n<em>如果使用第二种文法，以多叉树的形式存储其节点，则会更加简单，因此本系列文章采用第二种文法。</em></p>\n<h1 id=\"构造语法树\"><a class=\"markdownIt-Anchor\" href=\"#构造语法树\">#</a> 构造语法树</h1>\n<p>接下来我们尝试基于此文法与表达式 <code>1 + 5 * 6</code> ，构造其抽象语法树。</p>\n<p>以下是完整文法：</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">exp</span> = addexp</span><br><span class=\"line\">addexp = mulexp &#123;oper2 mulexp&#125;</span><br><span class=\"line\">oper2 = <span class=\"string\">&#x27;+&#x27;</span> | <span class=\"string\">&#x27;-&#x27;</span></span><br><span class=\"line\">mulexp = number &#123;oper1 number&#125;</span><br><span class=\"line\">oper1 = <span class=\"string\">&#x27;*&#x27;</span> | <span class=\"string\">&#x27;/&#x27;</span></span><br></pre></td></tr></table></figure>\n<p>以下是解析过程：</p>\n<ul>\n<li>\n<img src=\"/posts/f573/5.png\" class=\"\" title=\"这是一张图片\">\n</li>\n<li>\n<img src=\"/posts/f573/6.png\" class=\"\" title=\"这是一张图片\">\n</li>\n<li>\n<img src=\"/posts/f573/7.png\" class=\"\" title=\"这是一张图片\">\n</li>\n<li>\n<img src=\"/posts/f573/8.png\" class=\"\" title=\"这是一张图片\">\n</li>\n<li>\n<img src=\"/posts/f573/9.png\" class=\"\" title=\"这是一张图片\">\n</li>\n</ul>\n<p>读者不妨尝试自己编写一些表达式，然后画一画解析图，找找感觉。<br>\n也可以尝试自己在脑中遍历这颗语法树，看看能否能够正确计算出结果。</p>\n<h1 id=\"参考文献\"><a class=\"markdownIt-Anchor\" href=\"#参考文献\">#</a> 参考文献</h1>\n<blockquote>\n<p><em>[1] 消除左递归.<a href=\"https://blog.csdn.net/qq2071114140/article/details/102787831\">https://blog.csdn.net/qq2071114140/article/details/102787831</a></em></p>\n</blockquote>\n",
            "tags": [
                "编译原理",
                "动手写ToyLang"
            ]
        },
        {
            "id": "http://yuyuaqwq.github.io/posts/1571.html",
            "url": "http://yuyuaqwq.github.io/posts/1571.html",
            "title": "【动手写ToyLang】3.语法分析",
            "date_published": "2022-10-30T03:52:33.000Z",
            "content_html": "<h1 id=\"语法分析\"><a class=\"markdownIt-Anchor\" href=\"#语法分析\">#</a> 语法分析</h1>\n<p>按照传统的编译原理教材讲述的编译器结构， <code>词法分析阶段</code> 之后，便是 <code>语法分析阶段</code> 。</p>\n<p>以下摘自百度百科：</p>\n<blockquote>\n<p><em>语法分析是编译过程的一个逻辑阶段。语法分析的任务是在词法分析的基础上将单词序列组合成各类语法短语，如 “程序”，“语句”，“表达式” 等等。语法分析程序判断源程序在结构上是否正确。源程序的结构由上下文无关文法描述。语法分析程序可以用 YACC 等工具自动生成。</em></p>\n</blockquote>\n<p><strong>简而言之，语法分析即要求完成对输入串是否能符合语言文法规定的检查。</strong><br>\n<em>关于文法的定义，参照下文。</em></p>\n<h2 id=\"语法分析器\"><a class=\"markdownIt-Anchor\" href=\"#语法分析器\">#</a> 语法分析器</h2>\n<p>我们需要实现的是语法分析器。<br>\n<strong>语法分析器的主要工作就是接收词法分析器输出的 Token，产出抽象语法树。</strong></p>\n<p><em>本意我是不想讲太多学科中严谨定义的内容，一个是不好懂，容易劝退；一个是我个人的理解也有限。</em><br>\n<em>所以本系列文章就只简单提及我认为的 ToyLang 开发过程中必要的东西。</em></p>\n<h1 id=\"文法\"><a class=\"markdownIt-Anchor\" href=\"#文法\">#</a> 文法</h1>\n<p>这里还是请出百度百科：</p>\n<blockquote>\n<p><em>文法是一个汉语词汇，读音为 wén fǎ ，即文章的书写法规，一般用来指以文字、词语、短句、句子的编排而组成的完整语句和文章的合理性组织。</em></p>\n</blockquote>\n<p>学习编译原理的过程中，确实会有许多概念难以理解。</p>\n<p>我们先简单理解成，<strong>文法就是描述如何将 token 组织成语法树的规则。</strong></p>\n<p>我们的语言自然也需要存在文法，比如 if 语句必须按照下列文法来解析：</p>\n<ul>\n<li><code>if</code>   <code>exp</code>   <code>block</code></li>\n</ul>\n<p>当然，现在我们还是将重心放到四则表达式的解析上。</p>\n<h2 id=\"上下文无关文法\"><a class=\"markdownIt-Anchor\" href=\"#上下文无关文法\">#</a> 上下文无关文法</h2>\n<p><strong>在推导产生式时，正在进行的非终结符展开与前后已经展开的终结符不存在关联的文法。</strong><br>\n可以先继续向下看。</p>\n<h1 id=\"ebnf\"><a class=\"markdownIt-Anchor\" href=\"#ebnf\">#</a> EBNF</h1>\n<p>我们选择通过 <code>EBNF</code>  来描述 <code>ToyLang</code>  的文法。</p>\n<p>EBNF 是什么呢？</p>\n<blockquote>\n<p><em>扩展巴科斯 - 瑙尔范式 (Extended Backus–Naur Form,EBNF) 是一种用于描述计算机编程语言等正式语言的与上下文无关语法的元语法 (metasyntax) 符号表示法。简而言之，它是一种描述语言的语言。它是基本巴科斯范式 (BNF) 元语法符号表示法的一种扩展。</em></p>\n</blockquote>\n<p>只看描述通常很难理解新事物，咱们尝试一下用 EBNF 描述四则运算表达式的文法。</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">exp</span> = exp <span class=\"string\">&#x27;+&#x27;</span> number | exp <span class=\"string\">&#x27;-&#x27;</span> number | number</span><br><span class=\"line\">number = digit &#123;digit&#125;</span><br><span class=\"line\">digit = <span class=\"string\">&#x27;0&#x27;</span> | <span class=\"string\">&#x27;1&#x27;</span> | <span class=\"string\">&#x27;2&#x27;</span> | <span class=\"string\">&#x27;3&#x27;</span> | <span class=\"string\">&#x27;4&#x27;</span> | <span class=\"string\">&#x27;5&#x27;</span> | <span class=\"string\">&#x27;6&#x27;</span> | <span class=\"string\">&#x27;7&#x27;</span> | <span class=\"string\">&#x27;8&#x27;</span> | <span class=\"string\">&#x27;9&#x27;</span></span><br></pre></td></tr></table></figure>\n<p>为了便于理解，这里只描述了加法与减法。</p>\n<h2 id=\"基本规则\"><a class=\"markdownIt-Anchor\" href=\"#基本规则\">#</a> 基本规则</h2>\n<p>读者或许没看明白，没关系，笔者简单讲解一下：</p>\n<ul>\n<li>在 <code>=</code>  左边的，我们称为 <code>左式</code> ；</li>\n<li>在 <code>=</code>  右边的，我们称为 <code>右式</code> ；</li>\n<li>这样一行式子，我们称为 <code>产生式</code> 。</li>\n</ul>\n<h2 id=\"非终结符\"><a class=\"markdownIt-Anchor\" href=\"#非终结符\">#</a> 非终结符</h2>\n<p><strong>是某条产生式的左式，可以用其右式代换。</strong><br>\n如 <code>exp</code> ， <code>number</code> ， <code>digit</code> 。</p>\n<h2 id=\"终结符\"><a class=\"markdownIt-Anchor\" href=\"#终结符\">#</a> 终结符</h2>\n<p><strong>无法被再被代换的符号。</strong><br>\n如 <code>+</code> 、 <code>-</code> 、 <code>0</code> 、 <code>1</code> …。</p>\n<blockquote>\n<p><em>关于更多 EBNF 的语法规则，请参阅相关资料。</em></p>\n</blockquote>\n<h1 id=\"自顶向下\"><a class=\"markdownIt-Anchor\" href=\"#自顶向下\">#</a> 自顶向下</h1>\n<p><strong>已知 <code>输入串</code> 为某条产生式的左式，扫描输入串以不断展开其非终结符，直至只剩下终结符。</strong><br>\n<strong>这个展开的过程我们叫做推导，这属于自顶向下解析的思想。</strong></p>\n<h2 id=\"尝试解析\"><a class=\"markdownIt-Anchor\" href=\"#尝试解析\">#</a> 尝试解析</h2>\n<p>我们先来看第一行产生式：<br>\n <code>exp = exp '+' number | exp '-' number | number</code> <br>\n 它描述了 <code>表达式</code> 可以由：</p>\n<ul>\n<li><code>表达式+数字</code> 组成；</li>\n<li>也可以由 <code>表达式-数字</code> 组成；</li>\n<li>也可以只由 <code>数字</code> 组成。</li>\n</ul>\n<p><em>其中， <code>|</code>  表示或的意思，如果读者学习过正则表达式，应当很容易理解。</em></p>\n<p>假设我们需要解析的 <code>exp</code>  非终结符输入串为 <code>1 + 2</code> ，解析过程如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">exp -&gt; exp &#x27;+&#x27; number</span><br><span class=\"line\">        -&gt; number &#x27;+&#x27; &#x27;number&#x27;</span><br><span class=\"line\">            -&gt; &#x27;1&#x27; &#x27;+&#x27; &#x27;number&#x27;</span><br><span class=\"line\">                -&gt; &#x27;1&#x27; &#x27;+&#x27; &#x27;2&#x27;</span><br></pre></td></tr></table></figure>\n<p>就是在重复将右式中的非终结符展开的过程。<br>\n<em>这里为了节约篇幅，笔者没有将从 number 推导成 digit，再推导成数字的推导过程记录下来，读者明白这一点即可。</em></p>\n<p>再尝试一下解析 <code>exp</code>  非终结符输入串 <code>1</code>   <code>+</code>   <code>2</code>   <code>-</code>   <code>3</code> :</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">exp -&gt; exp &#x27;-&#x27; number</span><br><span class=\"line\">        -&gt; exp &#x27;+&#x27; number &#x27;-&#x27; number</span><br><span class=\"line\">            -&gt; number &#x27;+&#x27; number &#x27;-&#x27; number</span><br><span class=\"line\">                -&gt; &#x27;1&#x27; &#x27;+&#x27; number &#x27;-&#x27; number</span><br><span class=\"line\">                    -&gt; &#x27;1&#x27; &#x27;+&#x27; &#x27;2&#x27; &#x27;-&#x27; number</span><br><span class=\"line\">                        -&gt; &#x27;1&#x27; &#x27;+&#x27; &#x27;2&#x27; &#x27;-&#x27; &#x27;3&#x27;</span><br></pre></td></tr></table></figure>\n<p>当然，这个推导过程我们忽略了很多细节，并不能直接编写代码实现。</p>\n<h1 id=\"尾声\"><a class=\"markdownIt-Anchor\" href=\"#尾声\">#</a> 尾声</h1>\n<p>在下一篇文章，我们会通过 EBNF 来描述完整的四则表达式的文法，并讲解 <code>递归下降</code> 分析法。</p>\n<h1 id=\"参考文献\"><a class=\"markdownIt-Anchor\" href=\"#参考文献\">#</a> 参考文献</h1>\n<blockquote>\n<p><em>[1] 扩展巴科斯范式 (EBNF) 简介.<a href=\"https://blog.csdn.net/lin_strong/article/details/78583543\">https://blog.csdn.net/lin_strong/article/details/78583543</a></em><br>\n<em> [2] 应该如何理解「上下文无关文法」？.<a href=\"https://www.zhihu.com/question/21833944\">https://www.zhihu.com/question/21833944</a></em><br>\n<em> 其他网络上较为零散的资料，无法一一列举，十分抱歉。</em></p>\n</blockquote>\n",
            "tags": [
                "编译原理",
                "动手写ToyLang"
            ]
        },
        {
            "id": "http://yuyuaqwq.github.io/posts/aca7.html",
            "url": "http://yuyuaqwq.github.io/posts/aca7.html",
            "title": "【动手写ToyLang】2.词法分析",
            "date_published": "2022-10-29T04:29:50.000Z",
            "content_html": "<h1 id=\"词法分析\"><a class=\"markdownIt-Anchor\" href=\"#词法分析\">#</a> 词法分析</h1>\n<p>词法分析是整个编译器结构中最简单的一个阶段，所以放轻松，咱们往下看。</p>\n<p>那么，词法分析是什么呢？<br>\n我们知道，程序开发者编写的源代码，也就是编译器最初能够接收到的输入，即连续的字符序列。</p>\n<p><strong>词法分析存在的意义，就是提前将源代码切分成能被后续编译程序直接使用的单词序列。</strong></p>\n<ul>\n<li>如源代码中的变量标识，关键字，字符串字面量，数值字面量等…</li>\n</ul>\n<p>我们上一节课所展示的算术表达式， <code>3 + 2</code> ，也是先将其分成 <code>3</code>   <code>+</code>   <code>2</code>  三个节点，才能用于构成抽象语法树。</p>\n<p><strong>词法分析器产出的单词序列，我们将其称为 <code>Token</code> 。</strong></p>\n<hr>\n<h1 id=\"输入四则运算表达式产出token\"><a class=\"markdownIt-Anchor\" href=\"#输入四则运算表达式产出token\">#</a> 输入四则运算表达式，产出 <code>Token</code></h1>\n<p>我们既然需要将四则运算表达式转成 <code>Token</code> ，也就需要知道其单词序列的规则，当然，关于这一点，我们早已烂熟于心了。<br>\n以下是我通过正则表达式描述的 <code>Token</code>  匹配规则 (以我们将要开发的词法分析器为准)。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">TokenType</th>\n<th style=\"text-align:left\">Regex</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">Eof</td>\n<td style=\"text-align:left\">\\0</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Number</td>\n<td style=\"text-align:left\">\\d+</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">OpAdd</td>\n<td style=\"text-align:left\">+</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">OpSub</td>\n<td style=\"text-align:left\">-</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">OpMul</td>\n<td style=\"text-align:left\">*</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">OpDiv</td>\n<td style=\"text-align:left\">/</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">SepLParen</td>\n<td style=\"text-align:left\">(</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">SepRParen</td>\n<td style=\"text-align:left\">)</td>\n</tr>\n</tbody>\n</table>\n<p><em>此处笔者忽略了运算符在正则表达式中需要转义的情况，做一个参考即可。</em></p>\n<h1 id=\"lexer\"><a class=\"markdownIt-Anchor\" href=\"#lexer\">#</a> Lexer</h1>\n<p>Lexer，即词法分析器。<br>\n接下来我们编写代码实现 Lexer。</p>\n<h2 id=\"token\"><a class=\"markdownIt-Anchor\" href=\"#token\">#</a> Token</h2>\n<details class=\"folding-tag\" blue><summary> \\ToyLang\\lexer\\token.h </summary>\n              <div class='content'>\n              <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> LEXER_TOKEN_H_</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LEXER_TOKEN_H_</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> toylang &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// token类型常量</span></span><br><span class=\"line\"><span class=\"keyword\">enum class</span> <span class=\"title class_\">TokenType</span> &#123;</span><br><span class=\"line\">\tkNil = <span class=\"number\">0</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">\tkEof,</span><br><span class=\"line\">\tkNumber,</span><br><span class=\"line\"></span><br><span class=\"line\">\tkOpAdd,    <span class=\"comment\">// +</span></span><br><span class=\"line\">\tkOpSub,    <span class=\"comment\">// -</span></span><br><span class=\"line\">\tkOpMul,    <span class=\"comment\">// *</span></span><br><span class=\"line\">\tkOpDiv,    <span class=\"comment\">// /</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tkSepLPar,  <span class=\"comment\">// (</span></span><br><span class=\"line\">\tkSepRPar,  <span class=\"comment\">// )</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 描述token的结构体</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Token</span> &#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">Is</span><span class=\"params\">(TokenType t_type)</span> <span class=\"type\">const</span> <span class=\"keyword\">noexcept</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> line;\t\t<span class=\"comment\">// 行号</span></span><br><span class=\"line\">\tTokenType type;\t\t<span class=\"comment\">// token类型</span></span><br><span class=\"line\">\tstd::string str;\t<span class=\"comment\">// 保存必要的信息</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125; <span class=\"comment\">// namespace lexer</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span> <span class=\"comment\">// LEXER_TOKEN_H_</span></span></span><br></pre></td></tr></table></figure>\n              </div>\n            </details>\n<details class=\"folding-tag\" blue><summary> \\ToyLang\\lexer\\token.cpp </summary>\n              <div class='content'>\n              <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;token.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> lexer &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">Token::Is</span><span class=\"params\">(TokenType t_type)</span> <span class=\"type\">const</span> <span class=\"keyword\">noexcept</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> t_type == type;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125; <span class=\"comment\">// namespace lexer</span></span><br></pre></td></tr></table></figure>\n              </div>\n            </details>\n<p>token 这部分十分简单，不赘述了。</p>\n<h2 id=\"lexer-2\"><a class=\"markdownIt-Anchor\" href=\"#lexer-2\">#</a> Lexer</h2>\n<details class=\"folding-tag\" blue><summary> \\ToyLang\\lexer\\lexer.h </summary>\n              <div class='content'>\n              <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> LEXER_LEXER_H_</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LEXER_LEXER_H_</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;exception&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;lexer/token.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> lexer &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 词法分析时发生的异常</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">LexerException</span> : <span class=\"keyword\">public</span> std::exception &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">LexerException</span>(<span class=\"type\">const</span> <span class=\"type\">char</span>* t_msg);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 词法分析器类</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Lexer</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">Lexer</span>(<span class=\"type\">const</span> <span class=\"type\">char</span>* t_src);</span><br><span class=\"line\">\t~<span class=\"built_in\">Lexer</span>() <span class=\"keyword\">noexcept</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">char</span> <span class=\"title\">NextChar</span><span class=\"params\">()</span> <span class=\"keyword\">noexcept</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">SkipChar</span><span class=\"params\">(<span class=\"type\">int</span> count)</span> <span class=\"keyword\">noexcept</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\">Token <span class=\"title\">LookAHead</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">\t<span class=\"function\">Token <span class=\"title\">NextToken</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">\t<span class=\"function\">Token <span class=\"title\">MatchToken</span><span class=\"params\">(TokenType type)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\tstd::string m_src;</span><br><span class=\"line\">\t<span class=\"type\">size_t</span> m_idx;</span><br><span class=\"line\">\tToken m_save;</span><br><span class=\"line\">\t<span class=\"type\">int</span> m_line;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125; <span class=\"comment\">// namespace lexer</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span> <span class=\"comment\">// LEXER_LEXER_H_</span></span></span><br></pre></td></tr></table></figure>\n              </div>\n            </details>\n<details class=\"folding-tag\" blue><summary> \\ToyLang\\lexer\\lexer.cpp </summary>\n              <div class='content'>\n              <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;lexer.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> toylang &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">LexerException::<span class=\"built_in\">LexerException</span>(<span class=\"type\">const</span> <span class=\"type\">char</span>* t_msg) : std::<span class=\"built_in\">exception</span>(t_msg) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Lexer::<span class=\"built_in\">Lexer</span>(<span class=\"type\">const</span> <span class=\"type\">char</span>* t_src) : m_src&#123; t_src &#125;, m_line&#123; <span class=\"number\">0</span> &#125;, m_idx&#123; <span class=\"number\">0</span> &#125;, m_save&#123; <span class=\"number\">0</span>, TokenType::kNil &#125; &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Lexer::~<span class=\"built_in\">Lexer</span>() <span class=\"keyword\">noexcept</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取下一字符</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">char</span> <span class=\"title\">Lexer::NextChar</span><span class=\"params\">()</span> <span class=\"keyword\">noexcept</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (m_idx &lt; m_src.<span class=\"built_in\">size</span>()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> m_src[m_idx++];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 跳过指定字符数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Lexer::SkipChar</span><span class=\"params\">(<span class=\"type\">int</span> count)</span> <span class=\"keyword\">noexcept</span> </span>&#123;</span><br><span class=\"line\">    m_idx += count;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 前瞻下一Token</span></span><br><span class=\"line\"><span class=\"function\">Token <span class=\"title\">Lexer::LookAHead</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (m_save.type == TokenType::kNil) &#123;        <span class=\"comment\">// 如果没有前瞻过</span></span><br><span class=\"line\">        m_save = <span class=\"built_in\">NextToken</span>();       <span class=\"comment\">// 获取</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> m_save;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取下一Token</span></span><br><span class=\"line\"><span class=\"function\">Token <span class=\"title\">Lexer::NextToken</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Token token;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!m_save.<span class=\"built_in\">Is</span>(TokenType::kNil)) &#123;        <span class=\"comment\">// 如果有前瞻保存的token</span></span><br><span class=\"line\">        <span class=\"comment\">// 返回前瞻的结果</span></span><br><span class=\"line\">        token = m_save;</span><br><span class=\"line\">        m_save.type = TokenType::kNil;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> token;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">char</span> c;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 跳过空格</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> ((c = <span class=\"built_in\">NextChar</span>()) &amp;&amp; c == <span class=\"string\">&#x27; &#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    token.line = m_line;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (c == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        token.type = TokenType::kEof;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> token;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 根据字符返回对应类型的Token</span></span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (c) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&#x27;+&#x27;</span>:</span><br><span class=\"line\">        token.type = TokenType::kOpAdd;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> token;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&#x27;-&#x27;</span>:</span><br><span class=\"line\">        token.type = TokenType::kOpSub;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> token;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&#x27;*&#x27;</span>:</span><br><span class=\"line\">        token.type = TokenType::kOpMul;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> token;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&#x27;/&#x27;</span>:</span><br><span class=\"line\">        token.type = TokenType::kOpDiv;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> token;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&#x27;(&#x27;</span>:</span><br><span class=\"line\">        token.type = TokenType::kSepLParen;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> token;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&#x27;)&#x27;</span>:</span><br><span class=\"line\">        token.type = TokenType::kSepRParen;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> token;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (c &gt;= <span class=\"string\">&#x27;0&#x27;</span> || c &lt;= <span class=\"string\">&#x27;9&#x27;</span>) &#123;</span><br><span class=\"line\">        token.type = TokenType::kNumber;</span><br><span class=\"line\">        token.str.<span class=\"built_in\">push_back</span>(c);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (c = <span class=\"built_in\">NextChar</span>()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (c &gt;= <span class=\"string\">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class=\"string\">&#x27;9&#x27;</span>) &#123;</span><br><span class=\"line\">                token.str.<span class=\"built_in\">push_back</span>(c);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"built_in\">SkipChar</span>(<span class=\"number\">-1</span>);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> token;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"built_in\">LexerException</span>(<span class=\"string\">&quot;cannot parse token&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 匹配下一Token</span></span><br><span class=\"line\"><span class=\"function\">Token <span class=\"title\">Lexer::MatchToken</span><span class=\"params\">(TokenType type)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> token = <span class=\"built_in\">NextToken</span>();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (token.<span class=\"built_in\">Is</span>(type)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> token;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"built_in\">LexerException</span>(<span class=\"string\">&quot;cannot match token&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125; <span class=\"comment\">// namespace lexer</span></span><br></pre></td></tr></table></figure>\n              </div>\n            </details>\n<p>我们封装了一个词法分析器类；<br>\n <code>Lexer::LookAHead</code>  前瞻一个 Token。<br>\n <code>Lexer::NextToken</code>  是关键成员函数，用于扫描字符序列，匹配一个完整的 Token 并返回，如果前瞻过则返回前瞻的结果。<br>\n <code>Lexer::MatchToken</code>  要求下一 token 为指定类型，否则会抛出异常。</p>\n<h1 id=\"测试成果\"><a class=\"markdownIt-Anchor\" href=\"#测试成果\">#</a> 测试成果</h1>\n<p>接下来，我们编写测试代码，用于测试新鲜出炉的词法分析器。<br>\n用于测试的表达式是： <code>1 + 33 - 0 * (33 / 999) - 123</code></p>\n<details class=\"folding-tag\" blue><summary> \\entry.cpp </summary>\n              <div class='content'>\n              <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;lexer/lexer.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> toylang;</span><br><span class=\"line\"></span><br><span class=\"line\">    Lexer lexer&#123; <span class=\"string\">&quot;1 + 33 - 0 * (33 / 999) - 123&quot;</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> token = lexer.<span class=\"built_in\">NextToken</span>();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (token.<span class=\"built_in\">Is</span>(TokenType::kEof)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (token.type) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> TokenType::kNumber:&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s\\n&quot;</span>, token.str.<span class=\"built_in\">c_str</span>()); <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> TokenType::kOpAdd: &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;+\\n&quot;</span>); <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> TokenType::kOpDiv: &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;/\\n&quot;</span>); <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> TokenType::kOpMul: &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;*\\n&quot;</span>); <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> TokenType::kOpSub: &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;-\\n&quot;</span>); <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> TokenType::kSepLParen: &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;(\\n&quot;</span>); <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> TokenType::kSepRParen: &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;)\\n&quot;</span>); <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n              </div>\n            </details>\n<details class=\"folding-tag\" blue><summary> 打印结果 </summary>\n              <div class='content'>\n              <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">+</span><br><span class=\"line\">33</span><br><span class=\"line\">-</span><br><span class=\"line\">0</span><br><span class=\"line\">*</span><br><span class=\"line\">(</span><br><span class=\"line\">33</span><br><span class=\"line\">/</span><br><span class=\"line\">999</span><br><span class=\"line\">)</span><br><span class=\"line\">-</span><br><span class=\"line\">123</span><br></pre></td></tr></table></figure>\n              </div>\n            </details>",
            "tags": [
                "编译原理",
                "动手写ToyLang"
            ]
        },
        {
            "id": "http://yuyuaqwq.github.io/posts/56ac.html",
            "url": "http://yuyuaqwq.github.io/posts/56ac.html",
            "title": "【动手写ToyLang】1.从四则运算表达式开始",
            "date_published": "2022-10-28T15:01:12.000Z",
            "content_html": "<h1 id=\"由此开始\"><a class=\"markdownIt-Anchor\" href=\"#由此开始\">#</a> 由此开始</h1>\n<p>如果你曾经接触过《编译原理》的话，不知道是否与我有着同样的困惑呢？</p>\n<p>各种不近人情的名词，公式乱飞，这让我学习起来格外痛苦。</p>\n<p>我在阅读过不少文章、书籍，并且尝试敲下一些代码之后，才逐渐理解了一些较为关键的东西。</p>\n<p><em>实际上，当我真正完成了对四则运算表达式的解析的那一刻，我才真切感受到了编译原理的优雅与美妙之处，这大概就是由人类智慧的伟大之处吧 (偏得有点远了)。</em></p>\n<p><strong>因此，我才会选择先从四则运算表达式开始，将其逐步扩展成为一门 <code>通用编程语言</code> ，也能让读者每一节都能感受到学习有所反馈的喜悦。</strong></p>\n<hr>\n<h1 id=\"初尝构思\"><a class=\"markdownIt-Anchor\" href=\"#初尝构思\">#</a> 初尝构思</h1>\n<p><strong>现在，我来尝试给你出一道题吧，请你用你所熟悉的语言，编写一个模块：</strong></p>\n<ol>\n<li>输入符合四则运算表达式规范的字符串 (可以假定只有整数，不存在括号)；</li>\n<li>输出整型结果；</li>\n<li>要求关键逻辑由自己实现，不可借由库、语言本身提供的功能。</li>\n</ol>\n<p>你能实现吗？</p>\n<p>是否觉得脑子有些空白，难以组织成较为优雅的实现思路呢？</p>\n<pre><code>如果你现在就能想到很棒的解法，那至少你要比我厉害多了。\n</code></pre>\n<p>我曾经因为某些需求做过尝试，虽然最后写出来了，但是具体实现也非常丑陋，这里就不献丑了。</p>\n<p>但是我可以给你大致描述一下我当初的思路：</p>\n<ul>\n<li>\n<p>首先，查找字符串中优先级较高的运算符  <code>*</code>   <code>/</code> ，再前 / 后瞻运算符前后的数字，这个子串也能形成一个表达式；</p>\n</li>\n<li>\n<p>算出结果后，在原表达式中，用结果替换掉子串 (刚刚被计算的表达式)，再继续查找。</p>\n</li>\n<li>\n<p>完成后再从头开始查找优先级更低一级的运算符 <code>+</code>   <code>-</code> ，直到运算完成。</p>\n</li>\n</ul>\n<p><strong>当然，我们不会用这么低效的方法，也不会要求现在就给出实现。</strong></p>\n<p><strong>现在提出这个问题，并不是为了为难你，只是为了让你记住眼下的感觉，当你学完本系列文章后，再回来看看，这一道题，是否真的有那么难呢？</strong></p>\n<hr>\n<h1 id=\"抽象语法树\"><a class=\"markdownIt-Anchor\" href=\"#抽象语法树\">#</a> 抽象语法树</h1>\n<p>咱们先来看百度百科对 <code>抽象语法树</code> 的定义：</p>\n<blockquote>\n<p><em>在计算机科学中，抽象语法树（Abstract Syntax Tree，AST），或简称<a href=\"https://baike.baidu.com/item/%E8%AF%AD%E6%B3%95%E6%A0%91/7031301?fromModule=lemma_inlink\">语法树</a>（Syntax tree），是<a href=\"https://baike.baidu.com/item/%E6%BA%90%E4%BB%A3%E7%A0%81?fromModule=lemma_inlink\">源代码</a><a href=\"https://baike.baidu.com/item/%E8%AF%AD%E6%B3%95?fromModule=lemma_inlink\">语法</a>结构的一种抽象表示。它以树状的形式表现<a href=\"https://baike.baidu.com/item/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80?fromModule=lemma_inlink\">编程语言</a>的语法结构，树上的每个节点都表示源代码中的一种结构。</em></p>\n</blockquote>\n<p>嗯… 不愧是名字就带着抽象的东西，连说明都这么抽象。</p>\n<p>咱们先不整那么多虚头巴脑的，干就完了。</p>\n<h2 id=\"构造四则运算表达式的ast\"><a class=\"markdownIt-Anchor\" href=\"#构造四则运算表达式的ast\">#</a> 构造四则运算表达式的 AST</h2>\n<p><code>3 + 2</code></p>\n<p>这个是大家熟悉的算术表达式，实际上，我们的大脑是如何计算这个表达式的呢？当然需要遵循某些规则：</p>\n<ol>\n<li>先乘除</li>\n<li>再加减</li>\n<li>从左往右结合</li>\n</ol>\n<p>那我们自然是需要先<strong>左往右找</strong>在表达式中找到 <code>*</code> 、 <code>/</code>  两种符号，好消息是，没有，嘿嘿。</p>\n<p>接下来继续<strong>左往右找</strong> <code>+</code> 、 <code>-</code> ，找到之后将其取出，这也是我们需要计算的子表达式。</p>\n<p>我们将其分成三部分，分别是：</p>\n<ul>\n<li>左边的数字  <code>3</code></li>\n<li>加法运算符  <code>+</code></li>\n<li>右边的数字  <code>2</code></li>\n</ul>\n<p>人脑的表达式计算模型，可以归纳成这么一颗树型结构：</p>\n<ul>\n<li>\n<img src=\"/posts/56ac/1.png\" class=\"\" title=\"这是一张图片\">\n</li>\n</ul>\n<p>遍历树与我们的计算过程极度相似：</p>\n<ol>\n<li>根节点，是加法，表明需要将左子节点与右子节点相加；</li>\n<li><code>3 + 2</code> ，返回结果  <code>5</code> ；</li>\n<li>遍历结束；</li>\n</ol>\n<ul>\n<li>\n<img src=\"/posts/56ac/2.png\" class=\"\" title=\"这是一张图片\">\n</li>\n</ul>\n<h3 id=\"多运算符与结合律\"><a class=\"markdownIt-Anchor\" href=\"#多运算符与结合律\">#</a> 多运算符与结合律</h3>\n<p>那么，当一个表达式中，存在多个运算符时，应该如何构造语法树呢？<br>\n接下来我们构造表达式  <code>3 - 2 + 4</code>  的树。</p>\n<p><strong>首先我们应该注意的一点是，需要先被执行运算 (优先级更高) 的子表达式，其节点的相对深度更深：</strong></p>\n<ul>\n<li>\n<img src=\"/posts/56ac/3.png\" class=\"\" title=\"这是一张图片\">\n</li>\n</ul>\n<p>还是先来遍历这颗树：</p>\n<ol>\n<li>根节点，是加法，表明需要将左子节点与右子节点相加；\n<ol>\n<li>左子节点是减法，表明需要用左子节点减去右子节点，需要继续向下展开；</li>\n<li><code>3 - 2</code> ，返回结果  <code>1</code> ；</li>\n</ol>\n</li>\n<li><code>1 + 4</code> ，返回结果  <code>5</code> ；</li>\n<li>遍历结束；</li>\n</ol>\n<p><strong>因此，遍历的过程也符合我们所要求的 <code>左结合律</code> 。</strong></p>\n<ul>\n<li>由左边的运算符开始，向右结合。</li>\n<li>同优先级下，我们需要优先计算左边的运算符组成的子表达式，</li>\n</ul>\n<p>接下来我再给你画一下另一种情况，你也就明白了。</p>\n<ul>\n<li>\n<img src=\"/posts/56ac/4.png\" class=\"\" title=\"这是一张图片\">\n</li>\n</ul>\n<p>你可以尝试一下遍历这棵树，会发现先被执行的一定是加法，这并不符合我们的从一开始就要求的 <code>左结合律</code> 。<br>\n在部分情况下，由于结合律的错误，就会产出错误的结果：</p>\n<ul>\n<li>如我们本次求解的表达式，通过遍历此树得出的结果为 <code>-3</code> 。</li>\n</ul>\n<h2 id=\"目标根据语法规则生成ast\"><a class=\"markdownIt-Anchor\" href=\"#目标根据语法规则生成ast\">#</a> 目标：根据语法规则生成 AST</h2>\n<p>我不说你大概也已经猜到了，其实我们上面所构造的树，在当前的应用场景下，就叫做 <code>抽象语法树</code> 。</p>\n<p><em><strong>遍历抽象语法树并计算的过程，与我们人脑对表达式的计算的过程是十分相似的。</strong></em></p>\n<p><strong>也就是说，我们只需要构造出这么一颗抽象语法树，就已经基本上完成了编译工作的一大半。</strong><br>\n<strong>此时，若需要执行编译产生的结果，只需要遍历我们所生成 AST 即可。</strong></p>\n<p>如下图：</p>\n<ul>\n<li>\n<img src=\"/posts/56ac/5.png\" class=\"\" title=\"这是一张图片\">\n</li>\n</ul>\n<p>在遍历的过程中，我们就能够正确的完成对加法表达式的加法运算，再完成对赋值表达式的赋值运算。</p>\n<hr>\n<h1 id=\"ast解释器\"><a class=\"markdownIt-Anchor\" href=\"#ast解释器\">#</a> AST 解释器</h1>\n<p>最后，笔者向读者展示了有关 &quot;解释器&quot; 的东西，是的，即便你难以置信。<br>\n遍历这棵树的过程，就可以叫做解释；<br>\n如果我们写出代码实现遍历树的过程，即是 <code>AST解释器</code> 。</p>\n<p>当然，解释器是一种比较广泛的概念，即便到后面我们基于 AST 生成了字节码，交给虚拟机执行，我们的程序也依然可以称之为解释器，只不过解释的对象从 AST 换成了字节码。</p>\n<p>我个人觉得，当初造这个词的人只是为了区分所谓的 &quot;编译型语言&quot; 和 &quot;解释型语言&quot;。<br>\n以下是百度百科对解释器的定义：</p>\n<blockquote>\n<p><em>解释器（<a href=\"https://baike.baidu.com/item/%E8%8B%B1%E8%AF%AD/109997?fromModule=lemma_inlink\">英语</a>：Interpreter），又译为直译器，是一种电脑程序，能够把高级<a href=\"https://baike.baidu.com/item/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80?fromModule=lemma_inlink\">编程语言</a>一行一行直接转译运行。解释器不会一次把整个程序转译出来，只像一位 “中间人”，每次运行程序时都要先转成另一种语言再作运行，因此解释器的程序运行速度比较缓慢。它每转译一行程序叙述就立刻运行，然后再转译下一行，再运行，如此不停地进行下去。</em></p>\n</blockquote>\n<ul>\n<li><em>此处关于 <code>每转译一行程序叙述就立刻运行</code> 的说明也不尽然，至少现在很多被称为 <code>解释器</code> 的程序，并非如此 (如 Python 解释器、Java 解释器等)。</em></li>\n</ul>\n",
            "tags": [
                "编译原理",
                "动手写ToyLang"
            ]
        },
        {
            "id": "http://yuyuaqwq.github.io/posts/c4d3.html",
            "url": "http://yuyuaqwq.github.io/posts/c4d3.html",
            "title": "【动手写ToyLang】0.前言",
            "date_published": "2022-10-28T13:18:53.000Z",
            "content_html": "<h1 id=\"关于\"><a class=\"markdownIt-Anchor\" href=\"#关于\">#</a> 关于</h1>\n<p><strong>本系列文章会手把手教你打造一门<emp>玩具</emp>通用编程语言。</strong></p>\n<p>计算机本身就是一门需要动手的学科，在对基本原理有一定程度的理解之后，自己动手实践才是学习的最好捷径，为此制造 &quot;玩具&quot;，并不丢人。</p>\n<p>我对《编译原理》这门学科的学习程度也十分有限，因此本系列文章的读者不仅仅是你们，也包括我，写下的这篇文章也是支撑我继续动手实践的动力。<br>\n学完本系列文章之后，基本上可以对编译原理有所认知，再继续往下学习也就不会那么困难了。</p>\n<p><em>我会尽可能保证文章内容的准确，若还是难以避免的出现了错误，望批评指正，感激不尽。</em></p>\n<hr>\n<h1 id=\"准备工作\"><a class=\"markdownIt-Anchor\" href=\"#准备工作\">#</a> 准备工作</h1>\n<h2 id=\"开发语言\"><a class=\"markdownIt-Anchor\" href=\"#开发语言\">#</a> 开发语言</h2>\n<p>这里笔者选用个人较为常用的 C++ 作为开发语言，风格尽量以《Google C++ Style Guide》为准，在我个人能力范围内尽量写得 &quot;现代 C++&quot; 一点。</p>\n<p>另外，笔者对 C++ 的理解也较为浅薄，代码写得不好，还请理解。</p>\n<h2 id=\"开发环境\"><a class=\"markdownIt-Anchor\" href=\"#开发环境\">#</a> 开发环境</h2>\n<p>笔者基本上只在 <code>Windows</code>  下进行开发工作，因此选择自然是 <code>Visual Studio</code> ，读者可以自由选择自己喜欢的开发环境。</p>\n<h1 id=\"项目地址\"><a class=\"markdownIt-Anchor\" href=\"#项目地址\">#</a> 项目地址</h1>\n<p>最后，笔者已经将完整的项目代码放到了 <code>github</code>  上，另外每一学习阶段的代码会以分支的形式推送，供读者参考学习。</p>\n<ul>\n<li><a href=\"https://github.com/yuyuaqwq/ToyLang\">https://github.com/yuyuaqwq/ToyLang</a></li>\n</ul>\n",
            "tags": [
                "编译原理",
                "动手写ToyLang"
            ]
        },
        {
            "id": "http://yuyuaqwq.github.io/posts/5e1f.html",
            "url": "http://yuyuaqwq.github.io/posts/5e1f.html",
            "title": "【Proxifier】基本配置与使用",
            "date_published": "2022-10-26T16:37:40.000Z",
            "content_html": "<h1 id=\"proxifier\"><a class=\"markdownIt-Anchor\" href=\"#proxifier\">#</a> Proxifier</h1>\n<p><strong>Proxifier 是为其他不支持指定代理服务器的应用进行强制代理的工具。</strong><br>\n<em>其原理 (大致) 是在内核层面通过驱动过滤的形式实现的网络控制。</em></p>\n<h1 id=\"下载\"><a class=\"markdownIt-Anchor\" href=\"#下载\">#</a> 下载</h1>\n<ul>\n<li>官方网站<br>\n<a href=\"http://www.proxifier.com/\"> http://www.proxifier.com/</a></li>\n</ul>\n<p>应用本身是收费的，有能力请支持正版软件。</p>\n<h1 id=\"配置与使用\"><a class=\"markdownIt-Anchor\" href=\"#配置与使用\">#</a> 配置与使用</h1>\n<h2 id=\"准备工作\"><a class=\"markdownIt-Anchor\" href=\"#准备工作\">#</a> 准备工作</h2>\n<p>这里使用 <code>Fiddler</code>  这个软件来担任代理服务器的工作。</p>\n<p>启动 Fiddler 后，请先关闭 Windows 系统代理</p>\n<ul>\n<li>我们需要使用浏览器来测试强制代理，但是 Fiddler 会自动开启系统代理。</li>\n<li>并且浏览器默认会使用系统代理。</li>\n</ul>\n<h2 id=\"启动界面\"><a class=\"markdownIt-Anchor\" href=\"#启动界面\">#</a> 启动界面</h2>\n<ul>\n<li>\n\n</li>\n</ul>\n<h2 id=\"配置代理服务器\"><a class=\"markdownIt-Anchor\" href=\"#配置代理服务器\">#</a> 配置代理服务器</h2>\n<p>工具栏 -&gt; Profile -&gt; Proxy Servers…</p>\n<ul>\n<li>\n\n</li>\n</ul>\n<p>添加代理服务器</p>\n<ul>\n<li>\n\n</li>\n<li>\n\n</li>\n</ul>\n<p>选择否</p>\n<ul>\n<li>\n\n</li>\n</ul>\n<p>点击 OK</p>\n<ul>\n<li>\n\n</li>\n</ul>\n<p>依然选择否</p>\n<ul>\n<li>\n\n</li>\n</ul>\n<h2 id=\"配置代理规则\"><a class=\"markdownIt-Anchor\" href=\"#配置代理规则\">#</a> 配置代理规则</h2>\n<p>工具栏 -&gt; Profile -&gt; Proxification Rules…</p>\n<ul>\n<li>\n\n</li>\n</ul>\n<p>添加代理规则，保持与我一致即可。<br>\n添加了一条代理规则 chrome 并启用。</p>\n<ul>\n<li>\n\n</li>\n<li>\n\n</li>\n</ul>\n<p>这里说明一下选项：<br>\nDirect：</p>\n<ul>\n<li>Proxifier 放行此规则的流量<br>\n Block:</li>\n<li>Proxifier 拦截此规则的流量<br>\n Proxy HTTPS 127.0.0.1:</li>\n<li>这里的选项是我们先前设置的代理服务器</li>\n<li>Proxifier 代理此规则的流量</li>\n</ul>\n<p>点击 OK，继续。</p>\n<h2 id=\"配置域名解析\"><a class=\"markdownIt-Anchor\" href=\"#配置域名解析\">#</a> 配置域名解析</h2>\n<p>工具栏 -&gt; Profile -&gt; Name Rusolution…</p>\n<ul>\n<li>\n\n</li>\n</ul>\n<p>指定通过代理解析域名。</p>\n<ul>\n<li>\n\n</li>\n</ul>\n<p>基本上大功告成。</p>\n<h2 id=\"访问测试\"><a class=\"markdownIt-Anchor\" href=\"#访问测试\">#</a> 访问测试</h2>\n<p>接下来通过浏览器访问网页，Fiddler 中就会看到来自 Proxifier 进程的流量。</p>\n<ul>\n<li>\n\n</li>\n</ul>\n<h1 id=\"仍有缺陷\"><a class=\"markdownIt-Anchor\" href=\"#仍有缺陷\">#</a> 仍有缺陷</h1>\n<p>我们通过 <code>Proxifier</code>  配合 <code>Fiddler</code> ，能实现对应用 http/https 流量的强制抓包 / 解密。<br>\n但是需要注意的是， <code>Fiddler</code>  的原理是在操作系统中安装证书，以实现中间人攻击；<br>\n某些情况下，通过此方法抓包，应用如果无法正常上网，说明应用可能并不信任操作系统的证书，而是自己有一套证书。</p>\n",
            "tags": []
        },
        {
            "id": "http://yuyuaqwq.github.io/posts/5e1f.html",
            "url": "http://yuyuaqwq.github.io/posts/5e1f.html",
            "title": "【Proxifier】基本配置与使用",
            "date_published": "2022-10-26T16:37:40.000Z",
            "content_html": "<h1 id=\"proxifier\"><a class=\"markdownIt-Anchor\" href=\"#proxifier\">#</a> Proxifier</h1>\n<p><strong>Proxifier 是为其他不支持指定代理服务器的应用进行强制代理的工具。</strong><br>\n<em>其原理 (大致) 是在内核层面通过驱动过滤的形式实现的网络控制。</em></p>\n<h1 id=\"下载\"><a class=\"markdownIt-Anchor\" href=\"#下载\">#</a> 下载</h1>\n<ul>\n<li>官方网站<br>\n<a href=\"http://www.proxifier.com/\"> http://www.proxifier.com/</a></li>\n</ul>\n<p>应用本身是收费的，有能力请支持正版软件。</p>\n<h1 id=\"配置与使用\"><a class=\"markdownIt-Anchor\" href=\"#配置与使用\">#</a> 配置与使用</h1>\n<h2 id=\"准备工作\"><a class=\"markdownIt-Anchor\" href=\"#准备工作\">#</a> 准备工作</h2>\n<p>这里使用 <code>Fiddler</code>  这个软件来担任代理服务器的工作。</p>\n<p>启动 Fiddler 后，请先关闭 Windows 系统代理</p>\n<ul>\n<li>我们需要使用浏览器来测试强制代理，但是 Fiddler 会自动开启系统代理。</li>\n<li>并且浏览器默认会使用系统代理。</li>\n</ul>\n<h2 id=\"启动界面\"><a class=\"markdownIt-Anchor\" href=\"#启动界面\">#</a> 启动界面</h2>\n<ul>\n<li>\n<img src=\"/posts/5e1f/1.png\" class=\"\" title=\"这是一张图片\">\n</li>\n</ul>\n<h2 id=\"配置代理服务器\"><a class=\"markdownIt-Anchor\" href=\"#配置代理服务器\">#</a> 配置代理服务器</h2>\n<p>工具栏 -&gt; Profile -&gt; Proxy Servers…</p>\n<ul>\n<li>\n<img src=\"/posts/5e1f/2.png\" class=\"\" title=\"这是一张图片\">\n</li>\n</ul>\n<p>添加代理服务器</p>\n<ul>\n<li>\n<img src=\"/posts/5e1f/3.png\" class=\"\" title=\"这是一张图片\">\n</li>\n<li>\n<img src=\"/posts/5e1f/4.png\" class=\"\" title=\"这是一张图片\">\n</li>\n</ul>\n<p>选择否</p>\n<ul>\n<li>\n<img src=\"/posts/5e1f/5.png\" class=\"\" title=\"这是一张图片\">\n</li>\n</ul>\n<p>点击 OK</p>\n<ul>\n<li>\n<img src=\"/posts/5e1f/6.png\" class=\"\" title=\"这是一张图片\">\n</li>\n</ul>\n<p>依然选择否</p>\n<ul>\n<li>\n<img src=\"/posts/5e1f/7.png\" class=\"\" title=\"这是一张图片\">\n</li>\n</ul>\n<h2 id=\"配置代理规则\"><a class=\"markdownIt-Anchor\" href=\"#配置代理规则\">#</a> 配置代理规则</h2>\n<p>工具栏 -&gt; Profile -&gt; Proxification Rules…</p>\n<ul>\n<li>\n\n</li>\n</ul>\n<p>添加代理规则，保持与我一致即可。<br>\n添加了一条代理规则 chrome 并启用。</p>\n<ul>\n<li>\n<img src=\"/posts/5e1f/9.png\" class=\"\" title=\"这是一张图片\">\n</li>\n<li>\n<img src=\"/posts/5e1f/10.png\" class=\"\" title=\"这是一张图片\">\n</li>\n</ul>\n<p>这里说明一下选项：<br>\nDirect：</p>\n<ul>\n<li>Proxifier 放行此规则的流量</li>\n</ul>\n<p>Block:</p>\n<ul>\n<li>Proxifier 拦截此规则的流量</li>\n</ul>\n<p>Proxy HTTPS 127.0.0.1:</p>\n<ul>\n<li>这里的选项是我们先前设置的代理服务器</li>\n<li>Proxifier 代理此规则的流量</li>\n</ul>\n<p>点击 OK，继续。</p>\n<h2 id=\"配置域名解析\"><a class=\"markdownIt-Anchor\" href=\"#配置域名解析\">#</a> 配置域名解析</h2>\n<p>工具栏 -&gt; Profile -&gt; Name Rusolution…</p>\n<ul>\n<li>\n<img src=\"/posts/5e1f/11.png\" class=\"\" title=\"这是一张图片\">\n</li>\n</ul>\n<p>指定通过代理解析域名。</p>\n<ul>\n<li>\n<img src=\"/posts/5e1f/12.png\" class=\"\" title=\"这是一张图片\">\n</li>\n</ul>\n<p>基本上大功告成。</p>\n<h2 id=\"访问测试\"><a class=\"markdownIt-Anchor\" href=\"#访问测试\">#</a> 访问测试</h2>\n<p>接下来通过浏览器访问网页，Fiddler 中就会看到来自 Proxifier 进程的流量。</p>\n<ul>\n<li>\n<img src=\"/posts/5e1f/13.png\" class=\"\" title=\"这是一张图片\">\n</li>\n</ul>\n<h1 id=\"fiddler抓取应用配置示例\"><a class=\"markdownIt-Anchor\" href=\"#fiddler抓取应用配置示例\">#</a> Fiddler 抓取应用配置示例</h1>\n<ol>\n<li>我们需要将目标端口为 <code>80</code>  和 <code>443</code>  的请求转发到 <code>Fiddler</code>  创建的代理服务器中。</li>\n<li>将 <code>Fiddler.exe</code>  设为过滤项，(因为 <code>Fiddler</code>  再次转发请求时，又会被 <code>Proxifier</code>  捕获，因此要将其过滤)，通过右边的 <code>↑</code>   <code>↓</code> 按钮调整其优先级为最高。</li>\n<li>这里另外示范了过滤 <code>Chrome.exe</code>  浏览器的情况，使浏览器的请求也不会被转发。</li>\n</ol>\n<ul>\n<li>\n<img src=\"/posts/5e1f/14.png\" class=\"\" title=\"这是一张图片\">\n</li>\n</ul>\n<h1 id=\"仍有缺陷\"><a class=\"markdownIt-Anchor\" href=\"#仍有缺陷\">#</a> 仍有缺陷</h1>\n<p>我们通过 <code>Proxifier</code>  配合 <code>Fiddler</code> ，能实现对应用 http/https 流量的强制抓包 / 解密。<br>\n但是需要注意的是， <code>Fiddler</code>  的原理是在操作系统中安装证书，以实现中间人攻击；<br>\n某些情况下，通过此方法抓包，应用如果无法正常上网，说明应用可能并不信任操作系统的证书，而是自己有一套证书用于校验。</p>\n",
            "tags": [
                "网络分析",
                "Proxifier"
            ]
        },
        {
            "id": "http://yuyuaqwq.github.io/posts/842e.html",
            "url": "http://yuyuaqwq.github.io/posts/842e.html",
            "title": "【MFC】视图与文档",
            "date_published": "2022-10-25T14:01:10.000Z",
            "content_html": "<h1 id=\"视图\"><a class=\"markdownIt-Anchor\" href=\"#视图\">#</a> 视图</h1>\n<h2 id=\"视图窗口简述\"><a class=\"markdownIt-Anchor\" href=\"#视图窗口简述\">#</a> 视图窗口简述</h2>\n<p>在 MFC 的设计中，图形的显示的这部分工作，交由 <code>视图窗口</code> 负责。<br>\n框架窗口则担容器之任，成为菜单、标题栏、视图窗口等窗口的容身之所，通常不直接在其客户区中绘制。</p>\n<emp>视图窗口就被设计为一个没有标题栏，只有客户区的窗口，通常覆盖在框架窗口的客户区上。</emp>\n<h2 id=\"cview\"><a class=\"markdownIt-Anchor\" href=\"#cview\">#</a> CView</h2>\n<p>在 MFC 中，视图窗口对应的类即 <code>CView</code> ，继承自 <code>CWnd</code> ；</p>\n<h3 id=\"cviewondraw\"><a class=\"markdownIt-Anchor\" href=\"#cviewondraw\">#</a> CView::OnDraw</h3>\n<p><code>CView</code>  中声明了一个纯虚函数 <code>CView::OnDraw</code> ，因此继承必须重写这个函数，用于处理绘制消息；<br>\n这个函数是由 <code>CView::OnPanit</code>  调用的。</p>\n<h2 id=\"使用视图窗口\"><a class=\"markdownIt-Anchor\" href=\"#使用视图窗口\">#</a> 使用视图窗口</h2>\n<details class=\"folding-tag\" blue><summary> 代码示例 </summary>\n              <div class='content'>\n              <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;afxwin.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;afxext.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">CMyView</span> : <span class=\"keyword\">public</span> CView &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">OnDraw</span><span class=\"params\">(CDC* pDC)</span></span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">CMyView::OnDraw</span><span class=\"params\">(CDC* pDC)</span> </span>&#123;</span><br><span class=\"line\">    pDC-&gt;<span class=\"built_in\">TextOut</span>(<span class=\"number\">100</span>, <span class=\"number\">100</span>, <span class=\"string\">L&quot;CMyView::OnDraw&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">CMyFrameWnd</span> : <span class=\"keyword\">public</span> CFrameWnd &#123;</span><br><span class=\"line\">    <span class=\"built_in\">DECLARE_MESSAGE_MAP</span>()</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">afx_msg <span class=\"type\">int</span> AFX_MSG_CALL <span class=\"title\">OnCreate</span><span class=\"params\">(LPCREATESTRUCT)</span></span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">BEGIN_MESSAGE_MAP</span>(CMyFrameWnd, CFrameWnd)</span><br><span class=\"line\">    <span class=\"built_in\">ON_WM_CREATE</span>()</span><br><span class=\"line\"><span class=\"built_in\">END_MESSAGE_MAP</span>()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> AFX_MSG_CALL <span class=\"title\">CMyFrameWnd::OnCreate</span><span class=\"params\">(LPCREATESTRUCT pCS)</span> </span>&#123;</span><br><span class=\"line\">    CMyView* pView = <span class=\"keyword\">new</span> CMyView;</span><br><span class=\"line\">    pView-&gt;<span class=\"built_in\">Create</span>(<span class=\"literal\">nullptr</span>, <span class=\"string\">L&quot;MFCView&quot;</span>, WS_CHILD | WS_VISIBLE | WS_BORDER,</span><br><span class=\"line\">        CRect&#123;&#125;, <span class=\"keyword\">this</span>, AFX_IDW_PANE_FIRST);     <span class=\"comment\">// AFX_IDW_PANE_FIRST及以上的id创建出来的视图窗口，边框将与客户区重叠，不使用我们传递的CRect对象</span></span><br><span class=\"line\">    m_pViewActive = pView;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> CFrameWnd::<span class=\"built_in\">OnCreate</span>(pCS);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">CMyWinApp</span> :<span class=\"keyword\">public</span> CWinApp &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">CMyWinApp</span>();</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> BOOL <span class=\"title\">InitInstance</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">CMyWinApp::<span class=\"built_in\">CMyWinApp</span>() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">BOOL <span class=\"title\">CMyWinApp::InitInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    CMyFrameWnd* frame = <span class=\"keyword\">new</span> CMyFrameWnd;</span><br><span class=\"line\">    frame-&gt;<span class=\"built_in\">Create</span>(<span class=\"literal\">nullptr</span>, <span class=\"string\">L&quot;MFCBase&quot;</span>);</span><br><span class=\"line\">    m_pMainWnd = frame;</span><br><span class=\"line\">    frame-&gt;<span class=\"built_in\">ShowWindow</span>(SW_SHOW);</span><br><span class=\"line\">    frame-&gt;<span class=\"built_in\">UpdateWindow</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> TRUE;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">CMyWinApp g_theApp;</span><br></pre></td></tr></table></figure>\n              </div>\n            </details>\n<p>老朋友了，相信读者阅读起来不会有什么困难，我们为框架窗口的客户区覆盖上了一个视图窗口。</p>\n<hr>\n<h1 id=\"文档\"><a class=\"markdownIt-Anchor\" href=\"#文档\">#</a> 文档</h1>\n<h2 id=\"文档简述\"><a class=\"markdownIt-Anchor\" href=\"#文档简述\">#</a> 文档简述</h2>\n<p>在 MFC 中，将数据的管理交给 <code>文档</code> 负责，再与负责显示数据的 <code>视图</code> 进行数据交互。</p>\n<h2 id=\"cdocument\"><a class=\"markdownIt-Anchor\" href=\"#cdocument\">#</a> CDocument</h2>\n<p>MFC 提供的文档类。</p>\n<p>一个文档可以同时与多个视图窗口交互</p>\n<ul>\n<li>内部维护了一个链表，连接所有与当前文档对象交互的视图对象。</li>\n</ul>\n<p>一个视图窗口只能与一个文档交互</p>\n<ul>\n<li>内部由一个成员变量指向交互的文档对象。</li>\n</ul>\n<h2 id=\"使用文档\"><a class=\"markdownIt-Anchor\" href=\"#使用文档\">#</a> 使用文档</h2>\n<details class=\"folding-tag\" blue><summary> 代码示例 </summary>\n              <div class='content'>\n              <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;afxwin.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;afxext.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;resource.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">CMyDoc</span> : <span class=\"keyword\">public</span> CDocument &#123;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">CMyView</span> : <span class=\"keyword\">public</span> CView &#123;</span><br><span class=\"line\">    <span class=\"built_in\">DECLARE_DYNCREATE</span>(CMyView);</span><br><span class=\"line\">    <span class=\"built_in\">DECLARE_MESSAGE_MAP</span>()</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> AFX_MSG_CALL <span class=\"title\">OnCreate</span><span class=\"params\">(LPCREATESTRUCT pCs)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">OnDraw</span><span class=\"params\">(CDC* pDC)</span></span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">IMPLEMENT_DYNCREATE</span>(CMyView, CView);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">BEGIN_MESSAGE_MAP</span>(CMyView, CView)</span><br><span class=\"line\">    <span class=\"built_in\">ON_WM_CREATE</span>()</span><br><span class=\"line\"><span class=\"built_in\">END_MESSAGE_MAP</span>()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> AFX_MSG_CALL <span class=\"title\">CMyView::OnCreate</span><span class=\"params\">(LPCREATESTRUCT pCs)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> CView::<span class=\"built_in\">OnCreate</span>(pCs);        <span class=\"comment\">// 在此函数内部，建立文档与当前视图的关联</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">CMyView::OnDraw</span><span class=\"params\">(CDC* pDC)</span> </span>&#123;</span><br><span class=\"line\">    pDC-&gt;<span class=\"built_in\">TextOut</span>(<span class=\"number\">100</span>, <span class=\"number\">100</span>, <span class=\"string\">L&quot;CMyView::OnDraw&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">CMyFrameWnd</span> : <span class=\"keyword\">public</span> CFrameWnd &#123;</span><br><span class=\"line\">    <span class=\"built_in\">DECLARE_MESSAGE_MAP</span>()</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">afx_msg <span class=\"type\">int</span> AFX_MSG_CALL <span class=\"title\">OnCreate</span><span class=\"params\">(LPCREATESTRUCT)</span></span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">BEGIN_MESSAGE_MAP</span>(CMyFrameWnd, CFrameWnd)</span><br><span class=\"line\">    <span class=\"built_in\">ON_WM_CREATE</span>()</span><br><span class=\"line\"><span class=\"built_in\">END_MESSAGE_MAP</span>()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> AFX_MSG_CALL <span class=\"title\">CMyFrameWnd::OnCreate</span><span class=\"params\">(LPCREATESTRUCT pCS)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> CFrameWnd::<span class=\"built_in\">OnCreate</span>(pCS);        <span class=\"comment\">// 在此函数内部，通过动态创建机制创建视图窗口，并挂接到框架窗口的主活动视图中。</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">CMyWinApp</span> :<span class=\"keyword\">public</span> CWinApp &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">CMyWinApp</span>();</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> BOOL <span class=\"title\">InitInstance</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">CMyWinApp::<span class=\"built_in\">CMyWinApp</span>() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">BOOL <span class=\"title\">CMyWinApp::InitInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    CMyFrameWnd* frame = <span class=\"keyword\">new</span> CMyFrameWnd;</span><br><span class=\"line\">    CMyDoc* pDoc = <span class=\"keyword\">new</span> CMyDoc;</span><br><span class=\"line\"></span><br><span class=\"line\">    CCreateContext createContext;</span><br><span class=\"line\">    createContext.m_pCurrentDoc = pDoc;     <span class=\"comment\">// 绑定文档类对象</span></span><br><span class=\"line\">    createContext.m_pNewViewClass = <span class=\"built_in\">RUNTIME_CLASS</span>(CMyView);     <span class=\"comment\">// 绑定视图类的静态成员变量</span></span><br><span class=\"line\"></span><br><span class=\"line\">    frame-&gt;<span class=\"built_in\">LoadFrame</span>(IDR_MENU_TOP, WS_OVERLAPPEDWINDOW, <span class=\"literal\">nullptr</span>, &amp;createContext);       <span class=\"comment\">// 创建框架窗口</span></span><br><span class=\"line\"></span><br><span class=\"line\">    m_pMainWnd = frame;</span><br><span class=\"line\"></span><br><span class=\"line\">    frame-&gt;<span class=\"built_in\">ShowWindow</span>(SW_SHOW);</span><br><span class=\"line\">    frame-&gt;<span class=\"built_in\">UpdateWindow</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> TRUE;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">CMyWinApp g_theApp;</span><br></pre></td></tr></table></figure>\n              </div>\n            </details>\n<p>这回，我们有了不少改动。</p>\n<p>首先，我们先从应用的实例初始化开始看起：</p>\n<details class=\"folding-tag\" blue><summary> CMyWinApp::InitInstance </summary>\n              <div class='content'>\n              <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">BOOL <span class=\"title\">CMyWinApp::InitInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    CMyFrameWnd* frame = <span class=\"keyword\">new</span> CMyFrameWnd;</span><br><span class=\"line\">    CMyDoc* pDoc = <span class=\"keyword\">new</span> CMyDoc;</span><br><span class=\"line\"></span><br><span class=\"line\">    CCreateContext createContext;</span><br><span class=\"line\">    createContext.m_pCurrentDoc = pDoc;     <span class=\"comment\">// 绑定文档类对象</span></span><br><span class=\"line\">    createContext.m_pNewViewClass = <span class=\"built_in\">RUNTIME_CLASS</span>(CMyView);     <span class=\"comment\">// 绑定视图类的静态成员变量</span></span><br><span class=\"line\"></span><br><span class=\"line\">    frame-&gt;<span class=\"built_in\">LoadFrame</span>(IDR_MENU_TOP, WS_OVERLAPPEDWINDOW, <span class=\"literal\">nullptr</span>, &amp;createContext);       <span class=\"comment\">// 创建框架窗口</span></span><br><span class=\"line\"></span><br><span class=\"line\">    m_pMainWnd = frame;</span><br><span class=\"line\"></span><br><span class=\"line\">    frame-&gt;<span class=\"built_in\">ShowWindow</span>(SW_SHOW);</span><br><span class=\"line\">    frame-&gt;<span class=\"built_in\">UpdateWindow</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> TRUE;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n              </div>\n            </details>\n<p>我们修改了 <code>CMyWinApp::InitInstance</code>  (及 <code>CMyView</code>  类)，通过 MFC 的 <code>动态创建机制</code> ，让 MFC 为我们创建视图窗口，并与主框架窗口建立关联。</p>\n<blockquote>\n<p>说实话，我觉得 MFC 整这么多种选择就很烦 = =，这个也要学哪个也要学，既然要封装不妨封装彻底一点。</p>\n</blockquote>\n<p>这里我们还建立了消息映射 <code>CMyFrameWnd::OnCreate</code> 、 <code>CMyView::OnCreate</code> ，但是并没有做别的事，只是调用了父类实现的消息映射；<br>\n实际上并不需要我们去建立消息映射然后调用父类的成员函数，这里是为了方便读者看得更明显。</p>\n<hr>\n<h1 id=\"多视图\"><a class=\"markdownIt-Anchor\" href=\"#多视图\">#</a> 多视图</h1>\n<p>在一个 <code>不规则框架窗口</code> 中，可以同时存在多个视图窗口。</p>\n<p>我们需要在主框架窗口的客户区中，放置不规则框架窗口；<br>\n再在不规则框架窗口中放置多个视图窗口。</p>\n<h2 id=\"csplitterwnd\"><a class=\"markdownIt-Anchor\" href=\"#csplitterwnd\">#</a> CSplitterWnd</h2>\n<p>拆分窗口类，即不规则框架窗口，<emp>其客户区可以放置多个视图窗口。</emp></p>\n<h2 id=\"尝试多视图\"><a class=\"markdownIt-Anchor\" href=\"#尝试多视图\">#</a> 尝试多视图</h2>\n<details class=\"folding-tag\" blue><summary> 代码示例 </summary>\n              <div class='content'>\n              <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;afxwin.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;afxext.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;resource.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">CMyDoc</span> : <span class=\"keyword\">public</span> CDocument &#123;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">CMyView</span> : <span class=\"keyword\">public</span> CView &#123;</span><br><span class=\"line\">    <span class=\"built_in\">DECLARE_DYNCREATE</span>(CMyView);</span><br><span class=\"line\">    <span class=\"built_in\">DECLARE_MESSAGE_MAP</span>()</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> AFX_MSG_CALL <span class=\"title\">OnCreate</span><span class=\"params\">(LPCREATESTRUCT pCs)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">OnDraw</span><span class=\"params\">(CDC* pDC)</span></span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">IMPLEMENT_DYNCREATE</span>(CMyView, CView);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">BEGIN_MESSAGE_MAP</span>(CMyView, CView)</span><br><span class=\"line\">    <span class=\"built_in\">ON_WM_CREATE</span>()</span><br><span class=\"line\"><span class=\"built_in\">END_MESSAGE_MAP</span>()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> AFX_MSG_CALL <span class=\"title\">CMyView::OnCreate</span><span class=\"params\">(LPCREATESTRUCT pCs)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> CView::<span class=\"built_in\">OnCreate</span>(pCs);        <span class=\"comment\">// 在此函数内部，建立文档与当前视图的关联</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">CMyView::OnDraw</span><span class=\"params\">(CDC* pDC)</span> </span>&#123;</span><br><span class=\"line\">    pDC-&gt;<span class=\"built_in\">TextOut</span>(<span class=\"number\">100</span>, <span class=\"number\">100</span>, <span class=\"string\">L&quot;CMyView::OnDraw&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">CMyFrameWnd</span> : <span class=\"keyword\">public</span> CFrameWnd &#123;</span><br><span class=\"line\">    <span class=\"built_in\">DECLARE_MESSAGE_MAP</span>()</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">afx_msg <span class=\"type\">int</span> AFX_MSG_CALL <span class=\"title\">OnCreate</span><span class=\"params\">(LPCREATESTRUCT)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> BOOL <span class=\"title\">OnCreateClient</span><span class=\"params\">(LPCREATESTRUCT pCs, CCreateContext* pContext)</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    CSplitterWnd m_pSplitWnd;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">BEGIN_MESSAGE_MAP</span>(CMyFrameWnd, CFrameWnd)</span><br><span class=\"line\">    <span class=\"built_in\">ON_WM_CREATE</span>()</span><br><span class=\"line\"><span class=\"built_in\">END_MESSAGE_MAP</span>()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> AFX_MSG_CALL <span class=\"title\">CMyFrameWnd::OnCreate</span><span class=\"params\">(LPCREATESTRUCT pCS)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> CFrameWnd::<span class=\"built_in\">OnCreate</span>(pCS);        <span class=\"comment\">// 在此函数内部，通过动态创建机制创建视图窗口</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 重写框架窗口创建客户区时调用的成员函数</span></span><br><span class=\"line\"><span class=\"function\">BOOL <span class=\"title\">CMyFrameWnd::OnCreateClient</span><span class=\"params\">(LPCREATESTRUCT pCs, CCreateContext* pContext)</span> </span>&#123;</span><br><span class=\"line\">    m_pSplitWnd.<span class=\"built_in\">CreateStatic</span>(<span class=\"keyword\">this</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>);       <span class=\"comment\">// 创建布局</span></span><br><span class=\"line\">    m_pSplitWnd.<span class=\"built_in\">CreateView</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"built_in\">RUNTIME_CLASS</span>(CMyView), <span class=\"built_in\">CSize</span>(<span class=\"number\">500</span>,<span class=\"number\">500</span>), pContext);</span><br><span class=\"line\">    m_pSplitWnd.<span class=\"built_in\">CreateView</span>(<span class=\"number\">0</span>, <span class=\"number\">1</span>, pContext-&gt;m_pNewViewClass, <span class=\"built_in\">CSize</span>(<span class=\"number\">500</span>, <span class=\"number\">500</span>), pContext);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> TRUE;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">CMyWinApp</span> :<span class=\"keyword\">public</span> CWinApp &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">CMyWinApp</span>();</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> BOOL <span class=\"title\">InitInstance</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">CMyWinApp::<span class=\"built_in\">CMyWinApp</span>() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">BOOL <span class=\"title\">CMyWinApp::InitInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    CMyFrameWnd* frame = <span class=\"keyword\">new</span> CMyFrameWnd;</span><br><span class=\"line\">    CMyDoc* pDoc = <span class=\"keyword\">new</span> CMyDoc;</span><br><span class=\"line\"></span><br><span class=\"line\">    CCreateContext createContext;</span><br><span class=\"line\">    createContext.m_pCurrentDoc = pDoc;     <span class=\"comment\">// 绑定文档类对象</span></span><br><span class=\"line\">    createContext.m_pNewViewClass = <span class=\"built_in\">RUNTIME_CLASS</span>(CMyView);     <span class=\"comment\">// 绑定视图类的静态成员变量</span></span><br><span class=\"line\"></span><br><span class=\"line\">    frame-&gt;<span class=\"built_in\">LoadFrame</span>(IDR_MENU_TOP, WS_OVERLAPPEDWINDOW, <span class=\"literal\">nullptr</span>, &amp;createContext);       <span class=\"comment\">// 创建框架窗口</span></span><br><span class=\"line\"></span><br><span class=\"line\">    m_pMainWnd = frame;</span><br><span class=\"line\"></span><br><span class=\"line\">    frame-&gt;<span class=\"built_in\">ShowWindow</span>(SW_SHOW);</span><br><span class=\"line\">    frame-&gt;<span class=\"built_in\">UpdateWindow</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> TRUE;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">CMyWinApp g_theApp;</span><br></pre></td></tr></table></figure>\n              </div>\n            </details>",
            "tags": [
                "MFC",
                "没饭吃",
                "C++",
                "界面开发"
            ]
        },
        {
            "id": "http://yuyuaqwq.github.io/posts/603c.html",
            "url": "http://yuyuaqwq.github.io/posts/603c.html",
            "title": "【MFC】探索运行时类信息机制的实现原理",
            "date_published": "2022-10-16T14:44:08.000Z",
            "content_html": "<p>空的哦</p>\n",
            "tags": []
        }
    ]
}